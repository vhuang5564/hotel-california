(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_AblyChatComponent_jsx"],{

/***/ "./components/AblyChatComponent.jsx":
/*!******************************************!*\
  !*** ./components/AblyChatComponent.jsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var C_Users_setha_Documents_GitHub_hotel_california_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var C_Users_setha_Documents_GitHub_hotel_california_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _AblyReactEffect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AblyReactEffect */ "./components/AblyReactEffect.js");
/* harmony import */ var _AblyChatComponent_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AblyChatComponent.module.css */ "./components/AblyChatComponent.module.css");
/* harmony import */ var _AblyChatComponent_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_AblyChatComponent_module_css__WEBPACK_IMPORTED_MODULE_5__);
/* module decorator */ module = __webpack_require__.hmd(module);




var _jsxFileName = "C:\\Users\\setha\\Documents\\GitHub\\hotel-california\\components\\AblyChatComponent.jsx",
    _this = undefined,
    _s = $RefreshSig$();





var AblyChatComponent = function AblyChatComponent() {
  _s();

  var inputBox = null;
  var messageEnd = null;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(""),
      messageText = _useState[0],
      setMessageText = _useState[1]; // bound to the text area where messages can be typed


  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)([]),
      receivedMessages = _useState2[0],
      setMessages = _useState2[1]; //Message history on screen


  var messageTextIsEmpty = messageText.trim().length === 0; //Disable the send button when text is empty

  var _useChannel = (0,_AblyReactEffect__WEBPACK_IMPORTED_MODULE_4__.useChannel)("chat-demo", function (message) {
    // Here we're computing the state that'll be drawn into the message history
    // We do that by slicing the last 199 messages from the receivedMessages buffer
    var history = receivedMessages.slice(-199);
    setMessages([].concat((0,C_Users_setha_Documents_GitHub_hotel_california_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__.default)(history), [message])); // Then finally, we take the message history, and combine it with the new message
    // This means we'll always have up to 199 message + 1 new message, stored using the
    // setMessages react useState hook
  }),
      _useChannel2 = (0,C_Users_setha_Documents_GitHub_hotel_california_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__.default)(_useChannel, 2),
      channel = _useChannel2[0],
      ably = _useChannel2[1];

  var sendChatMessage = function sendChatMessage(messageText) {
    //resposible for publishing new messages
    channel.publish({
      name: "chat-message",
      data: messageText
    });
    setMessageText("");
    inputBox.focus();
  };

  var handleFormSubmission = function handleFormSubmission(event) {
    //When triggered when the submit hutton is clicked calls send message to prevent the page for reloading
    event.preventDefault();
    sendChatMessage(messageText);
  };

  var handleKeyPress = function handleKeyPress(event) {
    //makes sure that if the user presses enter the sendchatmessage is triggered
    if (event.charCode !== 13 || messageTextIsEmpty) {
      return;
    }

    sendChatMessage(messageText);
    event.preventDefault();
  };

  var messages = receivedMessages.map(function (message, index) {
    //Will display messages that are sent
    var author = message.connectionId === ably.connection.id ? "me" : "other";
    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("span", {
      className: (_AblyChatComponent_module_css__WEBPACK_IMPORTED_MODULE_5___default().message),
      "data-author": author,
      children: message.data
    }, index, false, {
      fileName: _jsxFileName,
      lineNumber: 44,
      columnNumber: 16
    }, _this);
  });
  (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function () {
    messageEnd.scrollIntoView({
      behaviour: "smooth"
    });
  });
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
    className: (_AblyChatComponent_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatHolder),
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
      className: (_AblyChatComponent_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatText),
      children: [messages, /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("div", {
        ref: function ref(element) {
          messageEnd = element;
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 55,
        columnNumber: 17
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 53,
      columnNumber: 13
    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("form", {
      onSubmit: handleFormSubmission,
      className: (_AblyChatComponent_module_css__WEBPACK_IMPORTED_MODULE_5___default().form),
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("textarea", {
        ref: function ref(element) {
          inputBox = element;
        },
        value: messageText,
        placeholder: "Type a message...",
        onChange: function onChange(e) {
          return setMessageText(e.target.value);
        },
        onKeyPress: handleKeyPress,
        className: (_AblyChatComponent_module_css__WEBPACK_IMPORTED_MODULE_5___default().textarea)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 58,
        columnNumber: 17
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)("button", {
        type: "submit",
        className: (_AblyChatComponent_module_css__WEBPACK_IMPORTED_MODULE_5___default().button),
        disabled: messageTextIsEmpty,
        children: "Send"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 66,
        columnNumber: 17
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 57,
      columnNumber: 13
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 52,
    columnNumber: 9
  }, _this);
};

_s(AblyChatComponent, "UHCFF9ns1jrEPUyCddaISRIBzu0=", false, function () {
  return [_AblyReactEffect__WEBPACK_IMPORTED_MODULE_4__.useChannel];
});

_c = AblyChatComponent;
/* harmony default export */ __webpack_exports__["default"] = (AblyChatComponent);

var _c;

$RefreshReg$(_c, "AblyChatComponent");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./components/AblyReactEffect.js":
/*!***************************************!*\
  !*** ./components/AblyReactEffect.js ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useChannel": function() { return /* binding */ useChannel; }
/* harmony export */ });
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably/promises */ "./node_modules/ably/promises.js");
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ably_promises__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* module decorator */ module = __webpack_require__.hmd(module);
var _s = $RefreshSig$();



var ably = new (ably_promises__WEBPACK_IMPORTED_MODULE_0___default().Realtime.Promise)({
  authUrl: '/api/createTokenRequest'
});
function useChannel(channelName, callbackOnMessage) {
  _s();

  var channel = ably.channels.get(channelName);

  var onMount = function onMount() {
    channel.subscribe(function (msg) {
      callbackOnMessage(msg);
    });
  };

  var onUnmount = function onUnmount() {
    channel.unsubscribe();
  };

  var useEffectHook = function useEffectHook() {
    onMount();
    return function () {
      onUnmount();
    };
  };

  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(useEffectHook);
  return [channel, ably];
}

_s(useChannel, "OD7bBpZva5O2jO+Puf00hKivP7c=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/ably/browser/static/ably-commonjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/ably/browser/static/ably-commonjs.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*!
 * @license Copyright 2020, Ably
 * 
 * Ably JavaScript Library v1.2.4
 * https://github.com/ably/ably-js
 * 
 * Ably Realtime Messaging
 * https://www.ably.io
 * 
 * Released under the Apache Licence v2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_747__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_747__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_747__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_747__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_747__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_747__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_747__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_747__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_747__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_747__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_747__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_747__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_747__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_747__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_747__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_747__(__nested_webpack_require_747__.s = 47);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_4224__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4224__(3);


var Logger = (function() {
	var consoleLogger, errorLogger;

	/* Can't just check for console && console.log; fails in IE <=9 */
	if((typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||
		 (global.console && global.console.log && (typeof global.console.log.apply === 'function')) /* sensible browsers */) {
		consoleLogger = function() { console.log.apply(console, arguments); };
		errorLogger = console.warn ? function() { console.warn.apply(console, arguments); } : consoleLogger;
	} else if(global.console && global.console.log) {
		/* IE <= 9 with the console open -- console.log does not
		 * inherit from Function, so has no apply method */
		consoleLogger = errorLogger = function() { Function.prototype.apply.call(console.log, console, arguments); };
	} else {
		/* IE <= 9 when dev tools are closed - window.console not even defined */
		consoleLogger = errorLogger = function() {};
	}

	function pad(str, three) {
		return ('000' + str).slice(-2-(three || 0));
	}

	var LOG_NONE  = 0,
	LOG_ERROR = 1,
	LOG_MAJOR = 2,
	LOG_MINOR = 3,
	LOG_MICRO = 4;

	var LOG_DEFAULT = LOG_ERROR,
	LOG_DEBUG   = LOG_MICRO;

	var logLevel = LOG_DEFAULT;

	function getHandler(logger) {
		return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logTimestamps ?
			function(msg) {
				var time = new Date();
				logger(pad(time.getHours()) + ':' + pad(time.getMinutes()) + ':' + pad(time.getSeconds()) + '.' + pad(time.getMilliseconds(), true) + ' ' + msg);
			} : logger;
	}

	var logHandler = getHandler(consoleLogger),
		logErrorHandler = getHandler(errorLogger);

	/* public constructor */
	function Logger(args) {}

	/* public constants */
	Logger.LOG_NONE    = LOG_NONE,
	Logger.LOG_ERROR   = LOG_ERROR,
	Logger.LOG_MAJOR   = LOG_MAJOR,
	Logger.LOG_MINOR   = LOG_MINOR,
	Logger.LOG_MICRO   = LOG_MICRO;

	Logger.LOG_DEFAULT = LOG_DEFAULT,
	Logger.LOG_DEBUG   = LOG_DEBUG;

	/* public static functions */
	Logger.logAction = function(level, action, message) {
		if (Logger.shouldLog(level)) {
			(level === LOG_ERROR ? logErrorHandler : logHandler)('Ably: ' + action + ': ' + message);
		}
	};

	Logger.deprecated = function(original, replacement) {
		Logger.deprecatedWithMsg(original, "Please use '" + replacement + "' instead.");
	}

	Logger.deprecatedWithMsg = function(funcName, msg) {
		if (Logger.shouldLog(LOG_ERROR)) {
			logErrorHandler("Ably: Deprecation warning - '" + funcName + "' is deprecated and will be removed from a future version. " + msg);
		}
	}

	/* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
	   the object being serialised if the log level will not output the message */
	Logger.shouldLog = function(level) {
		return level <= logLevel;
	};

	Logger.setLog = function(level, handler) {
		if(level !== undefined) logLevel = level;
		if(handler !== undefined) logHandler = logErrorHandler = handler;
	};

	return Logger;
})();

/* harmony default export */ __webpack_exports__["a"] = (Logger);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_4224__(20)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_7543__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_7543__(3);
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_7543__(5);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_7543__(4);




var Utils = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function Utils() {}

	function randomPosn(arrOrStr) {
		return Math.floor(Math.random() * arrOrStr.length);
	}

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.mixin = function(target) {
		for(var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			if(!source) { break; }
			var hasOwnProperty = source.hasOwnProperty;
			for(var key in source) {
				if(!hasOwnProperty || hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}
		return target;
	};

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.copy = function(src) {
		return Utils.mixin({}, src);
	};

	/*
	 * Determine whether or not a given object is
	 * an array.
	 */
	Utils.isArray = Array.isArray || function(ob) {
		return Object.prototype.toString.call(ob) == '[object Array]';
	};

	/*
	 * Ensures that an Array object is always returned
	 * returning the original Array of obj is an Array
	 * else wrapping the obj in a single element Array
	 */
	Utils.ensureArray = function(obj) {
		if(Utils.isEmptyArg(obj)) {
			return [];
		}
		if(Utils.isArray(obj)) {
			return obj;
		}
		return [obj];
	}

	/* ...Or an Object (in the narrow sense) */
	Utils.isObject = function(ob) {
		return Object.prototype.toString.call(ob) == '[object Object]';
	};

	/*
	 * Determine whether or not an object contains
	 * any enumerable properties.
	 * ob: the object
	 */
	Utils.isEmpty = function(ob) {
		for(var prop in ob)
			return false;
		return true;
	};

	Utils.isOnlyPropIn = function(ob, property) {
		for(var prop in ob) {
			if(prop !== property) {
				return false;
			}
		}
		return true;
	};

	/*
	 * Determine whether or not an argument to an overloaded function is
	 * undefined (missing) or null.
	 * This method is useful when constructing functions such as (WebIDL terminology):
	 *   off([TreatUndefinedAs=Null] DOMString? event)
	 * as you can then confirm the argument using:
	 *   Utils.isEmptyArg(event)
	 */

	Utils.isEmptyArg = function(arg) {
		return arg === null || arg === undefined;
	}

	/*
	 * Perform a simple shallow clone of an object.
	 * Result is an object irrespective of whether
	 * the input is an object or array. All
	 * enumerable properties are copied.
	 * ob: the object
	 */
	Utils.shallowClone = function(ob) {
		var result = new Object();
		for(var prop in ob)
			result[prop] = ob[prop];
		return result;
	};

	/*
	 * Clone an object by creating a new object with the
	 * given object as its prototype. Optionally
	 * a set of additional own properties can be
	 * supplied to be added to the newly created clone.
	 * ob:            the object to be cloned
	 * ownProperties: optional object with additional
	 *                properties to add
	 */
	Utils.prototypicalClone = function(ob, ownProperties) {
		function F() {}
		F.prototype = ob;
		var result = new F();
		if(ownProperties)
			Utils.mixin(result, ownProperties);
		return result;
	};

	/*
	 * Declare a constructor to represent a subclass
	 * of another constructor
	 * If platform has a built-in version we use that from Platform, else we
	 * define here (so can make use of other Utils fns)
	 * See node.js util.inherits
	 */
	Utils.inherits = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits || function(ctor, superCtor) {
		ctor.super_ = superCtor;
		ctor.prototype = Utils.prototypicalClone(superCtor.prototype, { constructor: ctor });
	};

	/*
	 * Determine whether or not an object has an enumerable
	 * property whose value equals a given value.
	 * ob:  the object
	 * val: the value to find
	 */
	Utils.containsValue = function(ob, val) {
		for(var i in ob) {
			if(ob[i] == val)
				return true;
		}
		return false;
	};

	Utils.intersect = function(arr, ob) { return Utils.isArray(ob) ? Utils.arrIntersect(arr, ob) : Utils.arrIntersectOb(arr, ob); };

	Utils.arrIntersect = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var member = arr1[i];
			if(Utils.arrIndexOf(arr2, member) != -1)
				result.push(member);
		}
		return result;
	};

	Utils.arrIntersectOb = function(arr, ob) {
		var result = [];
		for(var i = 0; i < arr.length; i++) {
			var member = arr[i];
			if(member in ob)
				result.push(member);
		}
		return result;
	};

	Utils.arrSubtract = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var element = arr1[i];
			if(Utils.arrIndexOf(arr2, element) == -1)
				result.push(element);
		}
		return result;
	};

	Utils.arrIndexOf = Array.prototype.indexOf
		? function(arr, elem, fromIndex) {
			return arr.indexOf(elem,  fromIndex);
		}
		: function(arr, elem, fromIndex) {
			fromIndex = fromIndex || 0;
			var len = arr.length;
			for(;fromIndex < len; fromIndex++) {
				if(arr[fromIndex] === elem) {
					return fromIndex;
				}
			}
			return -1;
		};

	Utils.arrIn = function(arr, val) {
		return Utils.arrIndexOf(arr, val) !== -1;
	};

	Utils.arrDeleteValue = function(arr, val) {
		var idx = Utils.arrIndexOf(arr, val);
		var res = (idx != -1);
		if(res)
			arr.splice(idx, 1);
		return res;
	};

	Utils.arrWithoutValue = function(arr, val) {
		var newArr = arr.slice();
		Utils.arrDeleteValue(newArr, val);
		return newArr;
	};

	/*
	 * Construct an array of the keys of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.keysArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !ob.hasOwnProperty(prop)) continue;
			result.push(prop);
		}
		return result;
	};

	/*
	 * Construct an array of the values of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.valuesArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !ob.hasOwnProperty(prop)) continue;
			result.push(ob[prop]);
		}
		return result;
	};

	Utils.forInOwnNonNullProps = function(ob, fn) {
		for (var prop in ob) {
			if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {
				fn(prop);
			}
		}
	};

	Utils.arrForEach = Array.prototype.forEach ?
		function(arr, fn) {
			arr.forEach(fn);
		} :
		function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				fn(arr[i], i, arr);
			}
		};

	/* Useful when the function may mutate the array */
	Utils.safeArrForEach = function(arr, fn) {
		return Utils.arrForEach(arr.slice(), fn);
	};

	Utils.arrMap = Array.prototype.map ?
		function(arr, fn) {
			return arr.map(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				result.push(fn(arr[i], i, arr));
			}
			return result;
		};

	Utils.arrFilter = Array.prototype.filter ?
		function(arr, fn) {
			return arr.filter(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				if(fn(arr[i])) {
					result.push(arr[i]);
				}
			}
			return result;
		};

	Utils.arrEvery = Array.prototype.every ?
		function(arr, fn) {
			return arr.every(fn);
		} : function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				if(!fn(arr[i], i, arr)) {
					return false;
				};
			}
			return true;
		};

	Utils.allSame = function(arr, prop) {
		if(arr.length === 0) {
			return true;
		}
		var first = arr[0][prop];
		return Utils.arrEvery(arr, function(item) {
			return item[prop] === first;
		});
	};

	Utils.nextTick = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick;

	var contentTypes = {
		json:   'application/json',
		jsonp:  'application/javascript',
		xml:    'application/xml',
		html:   'text/html',
		msgpack: 'application/x-msgpack'
	};

	Utils.defaultGetHeaders = function(format) {
		var accept = contentTypes[format || 'json'];
		return {
			accept: accept,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'X-Ably-Lib': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].libstring
		};
	};

	Utils.defaultPostHeaders = function(format) {
		var accept, contentType;
		accept = contentType = contentTypes[format || 'json'];

		return {
			accept: accept,
			'content-type': contentType,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'X-Ably-Lib': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].libstring
		};
	};

	Utils.arrPopRandomElement = function(arr) {
		return arr.splice(randomPosn(arr), 1)[0];
	};

	Utils.toQueryString = function(params) {
		var parts = [];
		if(params) {
			for(var key in params)
				parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
		}
		return parts.length ? '?' + parts.join('&') : '';
	};

	Utils.parseQueryString = function(query) {
		var match,
			search = /([^?&=]+)=?([^&]*)/g,
			result = {};

		while (match = search.exec(query))
			result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);

 		return result;
	};

	Utils.now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	Utils.inspect = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect;

	Utils.isErrorInfo = function(err) {
		return err.constructor.name == 'ErrorInfo'
	};

	Utils.inspectError = function(x) {
		/* redundant, but node vmcontext issue makes instanceof unreliable, and
		 * can't use just constructor test as could be a TypeError constructor etc. */
		return (x && (Utils.isErrorInfo(x) ||
			x.constructor.name == 'Error' ||
			x instanceof Error)) ?
			x.toString() :
			Utils.inspect(x);
	};

	Utils.inspectBody = function(body) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(body)) {
			return body.toString();
		} else if(typeof body === 'string') {
			return body;
		} else {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(body);
		}
	};

	/* Data is assumed to be either a string or a buffer. */
	Utils.dataSizeBytes = function(data) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].byteLength(data);
		}
		if(typeof data === 'string') {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringByteSize(data);
		}
		throw new Error("Expected input of Utils.dataSizeBytes to be a buffer or string, but was: " + (typeof data));
	};

	Utils.cheapRandStr = function() {
		return String(Math.random()).substr(2);
	};

	/* Takes param the minimum number of bytes of entropy the string must
	 * include, not the length of the string. String length produced is not
	 * guaranteed. */
	Utils.randomString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(uIntArr);
		} : function(numBytes) {
			/* Old browser; fall back to Math.random. Could just use a
			 * CryptoJS version of the above, but want this to still work in nocrypto
			 * versions of the library */
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64CharSet;
			/* base64 has 33% overhead; round length up */
			var length = Math.round(numBytes * 4/3);
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	Utils.randomHexString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexEncode(uIntArr);
		} : function(numBytes) {
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexCharSet;
			var length = numBytes * 2;
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	/* Pick n elements at random without replacement from an array */
	Utils.arrChooseN = function(arr, n) {
		var numItems = Math.min(n, arr.length),
			mutableArr = arr.slice(),
			result = [];
		for(var i = 0; i < numItems; i++) {
			result.push(Utils.arrPopRandomElement(mutableArr));
		}
		return result;
	};

	Utils.trim = String.prototype.trim ? function(str) {
		return str.trim();
	} : function(str) {
		return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	};

	Utils.promisify = function(ob, fnName, args) {
		return new Promise(function(resolve, reject) {
			ob[fnName].apply(ob, Array.prototype.slice.call(args).concat(function(err, res) {
				err ? reject(err) : resolve(res);
			}));
		});
	};

	Utils.decodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.decode(body) : JSON.parse(String(body));
	};

	Utils.encodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.encode(body, true) : JSON.stringify(body);
	};

	Utils.allToLowerCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toLowerCase();
		});
	};

	Utils.allToUpperCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toUpperCase();
		});
	};

	return Utils;
})();

/* harmony default export */ __webpack_exports__["a"] = (Utils);


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_21963__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_21963__(1);


var ErrorInfo = (function() {

	function ErrorInfo(message, code, statusCode, cause) {
		this.message = message;
		this.code = code;
		this.statusCode = statusCode;
		this.cause = cause;
		this.href = undefined;
	}

	ErrorInfo.prototype.toString = function() {
		var result = '[' + this.constructor.name;
		if(this.message) result += ': ' + this.message;
		if(this.statusCode) result += '; statusCode=' + this.statusCode;
		if(this.code) result += '; code=' + this.code;
		if(this.cause) result += '; cause=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(this.cause);
		if(this.href && !(this.message && this.message.indexOf('help.ably.io') > -1)) result += '; see ' + this.href + ' ';
		result += ']';
		return result;
	};

	ErrorInfo.fromValues = function(values) {
		var result = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ErrorInfo(), values);
		if (values instanceof Error) {
			/* Error.message is not enumerable, so mixin loses the message */
			result.message = values.message;
		}
		if(result.code && !result.href) {
			result.href = 'https://help.ably.io/error/' + result.code;
		}
		return result;
	};

	return ErrorInfo;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorInfo);


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_23425__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_23425__(24);


if(typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {
	console.log("Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm");
}

function allowComet() {
	/* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg
	 * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask
	 * So if websockets are supported, then just forget about comet transports and use that */
	var loc = global.location;
	return (!global.WebSocket || !loc || !loc.origin || loc.origin.indexOf("http") > -1);
}

var userAgent = global.navigator && global.navigator.userAgent.toString();
var currentUrl = global.location && global.location.href;

var Platform = {
	libver: 'js-web',
	logTimestamps: true,
	userAgent: userAgent,
	currentUrl: currentUrl,
	noUpgrade: userAgent && userAgent.match(/MSIE\s8\.0/),
	binaryType: 'arraybuffer',
	WebSocket: global.WebSocket || global.MozWebSocket,
	xhrSupported: global.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),
	jsonpSupported: typeof(document) !== 'undefined',
	allowComet: allowComet(),
	streamingSupported: true,
	useProtocolHeartbeats: true,
	createHmac: null,
	msgpack: _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
	supportsBinary: !!global.TextDecoder,
	preferBinary: false,
	ArrayBuffer: global.ArrayBuffer,
	atob: global.atob,
	nextTick: function(f) { setTimeout(f, 0); },
	addEventListener: global.addEventListener,
	inspect: JSON.stringify,
	stringByteSize: function(str) {
		/* str.length will be an underestimate for non-ascii strings. But if we're
		 * in a browser too old to support TextDecoder, not much we can do. Better
		 * to underestimate, so if we do go over-size, the server will reject the
		 * message */
		return global.TextDecoder &&
			(new global.TextEncoder().encode(str)).length ||
			str.length;
	},
	TextEncoder: global.TextEncoder,
	TextDecoder: global.TextDecoder,
	Promise: global.Promise,
	getRandomValues: (function(crypto) {
		if (crypto === undefined) {
			return undefined;
		}
		return function(arr, callback) {
			crypto.getRandomValues(arr);
			if(callback) {
				callback(null);
			}
		};
	})(global.crypto || global.msCrypto) // mscrypto for IE11
};

/* harmony default export */ __webpack_exports__["a"] = (Platform);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_23425__(20)))

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_26140__) {

"use strict";
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_26140__(32);
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_26140__.n(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_26140__(33);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_26140__.n(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_26140__(17);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_26140__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_26140__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_26140__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_26140__(3);






var BufferUtils = (function() {
	var ArrayBuffer = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].ArrayBuffer;
	var atob = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].atob;
	var TextEncoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextEncoder;
	var TextDecoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextDecoder;
	var base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	var hexCharSet = '0123456789abcdef';

	function isWordArray(ob) { return ob !== null && ob !== undefined && ob.sigBytes !== undefined; }
	function isArrayBuffer(ob) { return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer; }
	function isTypedArray(ob) { return ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(ob); }

	// https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
	function uint8ViewToBase64(bytes) {
		var base64    = ''
		var encodings = base64CharSet;

		var byteLength    = bytes.byteLength
		var byteRemainder = byteLength % 3
		var mainLength    = byteLength - byteRemainder

		var a, b, c, d
		var chunk

		// Main loop deals with bytes in chunks of 3
		for (var i = 0; i < mainLength; i = i + 3) {
			// Combine the three bytes into a single integer
			chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

			// Use bitmasks to extract 6-bit segments from the triplet
			a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
			b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
			c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
			d = chunk & 63               // 63       = 2^6 - 1

			// Convert the raw binary segments to the appropriate ASCII encoding
			base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
		}

		// Deal with the remaining bytes and padding
		if (byteRemainder == 1) {
			chunk = bytes[mainLength]

			a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

			// Set the 4 least significant bits to zero
			b = (chunk & 3)   << 4 // 3   = 2^2 - 1

			base64 += encodings[a] + encodings[b] + '=='
		} else if (byteRemainder == 2) {
			chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

			a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
			b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

			// Set the 2 least significant bits to zero
			c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

			base64 += encodings[a] + encodings[b] + encodings[c] + '='
		}

		return base64
	}

	function base64ToArrayBuffer(base64) {
		var binary_string =  atob(base64);
		var len = binary_string.length;
		var bytes = new Uint8Array( len );
		for (var i = 0; i < len; i++)        {
			var ascii = binary_string.charCodeAt(i);
			bytes[i] = ascii;
		}
		return bytes.buffer;
	}

	/* Most BufferUtils methods that return a binary object return an ArrayBuffer
	 * if supported, else a CryptoJS WordArray. The exception is toBuffer, which
	 * returns a Uint8Array (and won't work on browsers too old to support it) */
	function BufferUtils() {}

	BufferUtils.base64CharSet = base64CharSet;
	BufferUtils.hexCharSet = hexCharSet;

	var isBuffer = BufferUtils.isBuffer = function(buf) { return isArrayBuffer(buf) || isWordArray(buf) || isTypedArray(buf); };

	/* In browsers, returns a Uint8Array */
	var toBuffer = BufferUtils.toBuffer = function(buf) {
		if(!ArrayBuffer) {
			throw new Error("Can't convert to Buffer: browser does not support the necessary types");
		}

		if(isArrayBuffer(buf)) {
			return new Uint8Array(buf);
		}

		if(isTypedArray(buf)) {
			return new Uint8Array(buf.buffer);
		}

		if(isWordArray(buf)) {
			/* Backported from unreleased CryptoJS
			* https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */
			var arrayBuffer = new ArrayBuffer(buf.sigBytes);
			var uint8View = new Uint8Array(arrayBuffer);

			for (var i = 0; i < buf.sigBytes; i++) {
				uint8View[i] = (buf.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			}

			return uint8View;
		};

		throw new Error("BufferUtils.toBuffer expected an arraybuffer, typed array, or CryptoJS wordarray");
	};

	BufferUtils.toArrayBuffer = function(buf) {
		if(isArrayBuffer(buf)) {
			return buf;
		}
		return toBuffer(buf).buffer;
	};

	BufferUtils.toWordArray = function(buf) {
		if(isTypedArray(buf)) {
			buf = buf.buffer;
		}
		return isWordArray(buf) ? buf : crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default.a.create(buf);
	};

	BufferUtils.base64Encode = function(buf) {
		if(isWordArray(buf)) {
			return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["stringify"])(buf);
		}
		return uint8ViewToBase64(toBuffer(buf));
	};

	BufferUtils.base64Decode = function(str) {
		if(ArrayBuffer && atob) {
			return base64ToArrayBuffer(str);
		}
		return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["parse"])(str);
	};

	BufferUtils.hexEncode = function(buf) {
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["stringify"])(buf);
	};

	BufferUtils.hexDecode = function(string) {
		var wordArray = Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["parse"])(string);
		return ArrayBuffer ? BufferUtils.toArrayBuffer(wordArray) : wordArray;
	};

	BufferUtils.utf8Encode = function(string) {
		if(TextEncoder) {
			return (new TextEncoder()).encode(string).buffer;
		}
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["parse"])(string);
	};

	/* For utf8 decoding we apply slightly stricter input validation than to
	 * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
	 * can take (in particular allowing strings, which are just interpreted as
	 * binary); here we ensure that the input is actually a buffer since trying
	 * to utf8-decode a string to another string is almost certainly a mistake */
	BufferUtils.utf8Decode = function(buf) {
		if(!isBuffer(buf)) {
			throw new Error("Expected input of utf8decode to be an arraybuffer, typed array, or CryptoJS wordarray");
		}
		if(TextDecoder && !isWordArray(buf)) {
			return (new TextDecoder()).decode(buf);
		}
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["stringify"])(buf);
	};

	BufferUtils.bufferCompare = function(buf1, buf2) {
		if(!buf1) return -1;
		if(!buf2) return 1;
		buf1 = BufferUtils.toWordArray(buf1);
		buf2 = BufferUtils.toWordArray(buf2);
		buf1.clamp(); buf2.clamp();

		var cmp = buf1.sigBytes - buf2.sigBytes;
		if(cmp != 0) return cmp;
		buf1 = buf1.words; buf2 = buf2.words;
		for(var i = 0; i < buf1.length; i++) {
			cmp = buf1[i] - buf2[i];
			if(cmp != 0) return cmp;
		}
		return 0;
	};

	BufferUtils.byteLength = function(buf) {
		if(isArrayBuffer(buf) || isTypedArray(buf)) {
			return buf.byteLength
		} else if(isWordArray(buf)) {
			return buf.sigBytes;
		}
	};

	/* Returns ArrayBuffer on browser and Buffer on Node.js */
	BufferUtils.typedArrayToBuffer = function(typedArray) {
		return typedArray.buffer;
	};

	return BufferUtils;
})();

/* harmony default export */ __webpack_exports__["a"] = (BufferUtils);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_34673__) {

"use strict";

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_34673__(3);

// CONCATENATED MODULE: ./browser/lib/util/defaults.js


var Defaults = {
	internetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',
	jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',
	/* Order matters here: the base transport is the leftmost one in the
	 * intersection of baseTransportOrder and the transports clientOption that's
	 * supported.  This is not quite the same as the preference order -- e.g.
	 * xhr_polling is preferred to jsonp, but for browsers that support it we want
	 * the base transport to be xhr_polling, not jsonp */
	defaultTransports: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	baseTransportOrder: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	transportPreferenceOrder: ['jsonp', 'xhr_polling', 'xhr_streaming', 'web_socket'],
	upgradeTransports: ['xhr_streaming', 'web_socket']
};

/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -
* while it can do streaming, the low max http-connections-per-host limit means
* that the polling transport is crippled during the upgrade process. So just
* leave it at the base transport */
if(platform_browser["a" /* default */].noUpgrade) {
	Defaults.upgradeTransports = [];
}

/* harmony default export */ var defaults = (Defaults);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_34673__(1);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_34673__(4);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_34673__(0);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_34673__(2);

// CONCATENATED MODULE: ./common/lib/util/defaults.js







defaults.ENVIRONMENT              = '';
defaults.REST_HOST                = 'rest.ably.io';
defaults.REALTIME_HOST            = 'realtime.ably.io';
defaults.FALLBACK_HOSTS           = ['A.ably-realtime.com', 'B.ably-realtime.com', 'C.ably-realtime.com', 'D.ably-realtime.com', 'E.ably-realtime.com'];
defaults.PORT                     = 80;
defaults.TLS_PORT                 = 443;
defaults.TIMEOUTS = {
	/* Documented as options params: */
	disconnectedRetryTimeout   : 15000,
	suspendedRetryTimeout      : 30000,
	/* Undocumented, but part of the api and can be used by customers: */
	httpRequestTimeout         : 15000,
	channelRetryTimeout        : 15000,
	fallbackRetryTimeout       : 600000,
	/* For internal / test use only: */
	connectionStateTtl         : 120000,
	realtimeRequestTimeout     : 10000,
	recvTimeout                : 90000,
	preferenceConnectTimeout   : 6000,
	parallelUpgradeDelay       : 6000
};
defaults.httpMaxRetryCount = 3;
defaults.maxMessageSize    = 65536;

defaults.errorReportingUrl = 'https://errors.ably.io/api/15/store/';
defaults.errorReportingHeaders = {
	"X-Sentry-Auth": "Sentry sentry_version=7, sentry_key=a04e33c8674c451f8a310fbec029acf5, sentry_client=ably-js/0.1",
	"Content-Type": "application/json"
};

defaults.version          = '1.2.5-beta.1';
defaults.libstring        = platform_browser["a" /* default */].libver + '-' + defaults.version;
defaults.apiVersion       = '1.2';

defaults.getHost = function(options, host, ws) {
	if(ws)
		host = ((host == options.restHost) && options.realtimeHost) || host || options.realtimeHost;
	else
		host = host || options.restHost;

	return host;
};

defaults.getPort = function(options, tls) {
	return (tls || options.tls) ? options.tlsPort : options.port;
};

defaults.getHttpScheme = function(options) {
	return options.tls ? 'https://' : 'http://';
};

// construct environment fallback hosts as per RSC15i
defaults.environmentFallbackHosts = function(environment) {
	return [
		environment + '-a-fallback.ably-realtime.com',
		environment + '-b-fallback.ably-realtime.com',
		environment + '-c-fallback.ably-realtime.com',
		environment + '-d-fallback.ably-realtime.com',
		environment + '-e-fallback.ably-realtime.com'
	];
};

defaults.getFallbackHosts = function(options) {
	var fallbackHosts = options.fallbackHosts,
		httpMaxRetryCount = typeof(options.httpMaxRetryCount) !== 'undefined' ? options.httpMaxRetryCount : defaults.httpMaxRetryCount;

	return fallbackHosts ? utils["a" /* default */].arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
};

defaults.getHosts = function(options) {
	return [options.restHost].concat(defaults.getFallbackHosts(options));
};

function checkHost(host) {
	if(typeof host !== 'string') {
		throw new errorinfo["a" /* default */]('host must be a string; was a ' + typeof host, 40000, 400);
	};
	if(!host.length) {
		throw new errorinfo["a" /* default */]('host must not be zero-length', 40000, 400);
	};
}

defaults.objectifyOptions = function(options) {
	if(typeof options == 'string') {
		return (options.indexOf(':') == -1) ? {token: options} : {key: options};
	}
	return options;
};

defaults.normaliseOptions = function(options) {
	/* Deprecated options */
	if(options.host) {
		logger["a" /* default */].deprecated('host', 'restHost');
		options.restHost = options.host;
	}
	if(options.wsHost) {
		logger["a" /* default */].deprecated('wsHost', 'realtimeHost');
		options.realtimeHost = options.wsHost;
	}
	if(options.queueEvents) {
		logger["a" /* default */].deprecated('queueEvents', 'queueMessages');
		options.queueMessages = options.queueEvents;
	}

	if(options.fallbackHostsUseDefault) {
		/* fallbackHostsUseDefault and fallbackHosts are mutually exclusive as per TO3k7 */
		if(options.fallbackHosts) {
			var msg = 'fallbackHosts and fallbackHostsUseDefault cannot both be set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* default fallbacks can't be used with custom ports */
		if(options.port || options.tlsPort) {
			var msg = 'fallbackHostsUseDefault cannot be set when port or tlsPort are set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* emit an appropriate deprecation warning */
		if(options.environment) {
			logger["a" /* default */].deprecatedWithMsg('fallbackHostsUseDefault', 'There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.');
		} else {
			logger["a" /* default */].deprecated('fallbackHostsUseDefault', 'fallbackHosts: Ably.Defaults.FALLBACK_HOSTS');
		}

		/* use the default fallback hosts as requested */
		options.fallbackHosts = defaults.FALLBACK_HOSTS;
	}

	if(options.recover === true) {
		logger["a" /* default */].deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');
		options.recover = function(lastConnectionDetails, cb) { cb(true); };
	}

	if(typeof options.recover === 'function' && options.closeOnUnload === true) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');
		options.recover = null;
	}

	if(!('closeOnUnload' in options)) {
		/* Have closeOnUnload default to true unless we have any indication that
		 * the user may want to recover the connection */
		options.closeOnUnload = !options.recover;
	}

	if(options.transports && utils["a" /* default */].arrIn(options.transports, 'xhr')) {
		logger["a" /* default */].deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
		utils["a" /* default */].arrDeleteValue(options.transports, 'xhr');
		options.transports.push('xhr_streaming');
	}

	if(!('queueMessages' in options))
		options.queueMessages = true;

	/* infer hosts and fallbacks based on the configured environment */
	var environment = (options.environment && String(options.environment).toLowerCase()) || defaults.ENVIRONMENT;
	var production = !environment || (environment === 'production');

	if(!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
		options.fallbackHosts = production ? defaults.FALLBACK_HOSTS : defaults.environmentFallbackHosts(environment);
	}

	if(!options.realtimeHost) {
		/* prefer setting realtimeHost to restHost as a custom restHost typically indicates
		 * a development environment is being used that can't be inferred by the library */
		if(options.restHost) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_WARN, 'Defaults.normaliseOptions', 'restHost is set to "' + options.restHost + '" but realtimeHost is not set, so setting realtimeHost to "' + options.restHost + '" too. If this is not what you want, please set realtimeHost explicitly.');
			options.realtimeHost = options.restHost
		} else {
			options.realtimeHost = production ? defaults.REALTIME_HOST : environment + '-' + defaults.REALTIME_HOST;
		}
	}

	if(!options.restHost) {
		options.restHost = production ? defaults.REST_HOST : environment + '-' + defaults.REST_HOST;
	}

	utils["a" /* default */].arrForEach((options.fallbackHosts || []).concat(options.restHost, options.realtimeHost), checkHost);

	options.port = options.port || defaults.PORT;
	options.tlsPort = options.tlsPort || defaults.TLS_PORT;
	options.maxMessageSize = options.maxMessageSize || defaults.maxMessageSize;
	if(!('tls' in options)) options.tls = true;

	/* Allow values passed in options to override default timeouts */
	options.timeouts = {};
	for(var prop in defaults.TIMEOUTS) {
		options.timeouts[prop] = options[prop] || defaults.TIMEOUTS[prop];
	};

	if('useBinaryProtocol' in options) {
		options.useBinaryProtocol = platform_browser["a" /* default */].supportsBinary && options.useBinaryProtocol;
	} else {
		options.useBinaryProtocol = platform_browser["a" /* default */].preferBinary;
	}

	if(options.clientId) {
		var headers = options.headers = options.headers || {};
		headers['X-Ably-ClientId'] = bufferutils["a" /* default */].base64Encode(bufferutils["a" /* default */].utf8Encode(options.clientId));
	}

	if(!('idempotentRestPublishing' in options)) {
		options.idempotentRestPublishing = true;
	}

	if(options.promises && !platform_browser["a" /* default */].Promise) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', '{promises: true} was specified, but no Promise constructor found; disabling promises');
		options.promises = false;
	}

	return options;
};

/* harmony default export */ var util_defaults = __webpack_exports__["a"] = (defaults);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_45517__) {

"use strict";
/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_45517__(1);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_45517__(5);



var Http = (function() {
	var noop = function() {};

	function Http() {}

	var now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	function shouldFallback(err) {
		var statusCode = err.statusCode;
		/* 400 + no code = a generic xhr onerror. Browser doesn't give us enough
		 * detail to know whether it's fallback-fixable, but it may be (eg if a
		 * network issue), so try just in case */
		return (statusCode === 408 && !err.code) ||
			(statusCode === 400 && !err.code)      ||
			(statusCode >= 500 && statusCode <= 504);
	}

	function getHosts(client) {
		/* If we're a connected realtime client, try the endpoint we're connected
		 * to first -- but still have fallbacks, being connected is not an absolute
		 * guarantee that a datacenter has free capacity to service REST requests. */
		var connection = client.connection,
			connectionHost = connection && connection.connectionManager.host;

		if(connectionHost) {
			return [connectionHost].concat(_common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getFallbackHosts(client.options));
		}

		return _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getHosts(client.options);
	}
	Http._getHosts = getHosts;

	Http.methods = ['get', 'delete', 'post', 'put', 'patch'];
	Http.methodsWithoutBody = ['get', 'delete'];
	Http.methodsWithBody = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrSubtract(Http.methods, Http.methodsWithoutBody);

	/* - Http.get, Http.post, Http.put, ...
	 * Perform an HTTP request for a given path against prime and fallback Ably hosts
	 * @param rest
	 * @param path the full path
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 *
	 * - Http.getUri, Http.postUri, Http.putUri, ...
	 * Perform an HTTP request for a given full URI
	 * @param rest
	 * @param uri the full URI
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 */
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithoutBody, function(method) {
		Http[method] = function(rest, path, headers, params, callback) {
			Http['do'](method, rest, path, headers, null, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, params, callback) {
			Http.doUri(method, rest, uri, headers, null, params, callback);
		};
	});

	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithBody, function(method) {
		Http[method] = function(rest, path, headers, body, params, callback) {
			Http['do'](method, rest, path, headers, body, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, body, params, callback) {
			Http.doUri(method, rest, uri, headers, body, params, callback);
		};
	});

	/* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */
	Http['do'] = function(method, rest, path, headers, body, params, callback) {
		callback = callback || noop;
		var uriFromHost = (typeof(path) == 'function') ? path : function(host) { return rest.baseUri(host) + path; };
		var binary = (headers && headers.accept != 'application/json');
		var doArgs = arguments;

		var currentFallback = rest._currentFallback;
		if(currentFallback) {
			if(currentFallback.validUntil > now()) {
				/* Use stored fallback */
				Http.Request(method, rest, uriFromHost(currentFallback.host), headers, params, body, function(err) {
					if(err && shouldFallback(err)) {
						/* unstore the fallback and start from the top with the default sequence */
						rest._currentFallback = null;
						Http['do'].apply(Http, doArgs);
						return;
					}
					callback.apply(null, arguments);
				});
				return;
			} else {
				/* Fallback expired; remove it and fallthrough to normal sequence */
				rest._currentFallback = null;
			}
		}

		var hosts = getHosts(rest);

		/* if there is only one host do it */
		if(hosts.length == 1) {
			Http.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);
			return;
		}

		/* hosts is an array with preferred host plus at least one fallback */
		var tryAHost = function(candidateHosts, persistOnSuccess) {
			var host = candidateHosts.shift();
			Http.doUri(method, rest, uriFromHost(host), headers, body, params, function(err) {
				if(err && shouldFallback(err) && candidateHosts.length) {
					tryAHost(candidateHosts, true);
					return;
				}
				if(persistOnSuccess) {
					/* RSC15f */
					rest._currentFallback = {
						host: host,
						validUntil: now() + rest.options.timeouts.fallbackRetryTimeout
					};
				}
				callback.apply(null, arguments);
			});
		};
		tryAHost(hosts);
	};

	Http.doUri = function(method, rest, uri, headers, body, params, callback) {
		Http.Request(method, rest, uri, headers, params, body, callback);
	};

	Http.supportsAuthHeaders = false;
	Http.supportsLinkHeaders = false;
	return Http;
})();

/* harmony default export */ __webpack_exports__["a"] = (Http);


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_51106__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_51106__(1);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_51106__(0);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_51106__(3);




var EventEmitter = (function() {

	/* public constructor */
	function EventEmitter() {
		this.any = [];
		this.events = {};
		this.anyOnce = [];
		this.eventsOnce = {};
	}

	/* Call the listener, catch any exceptions and log, but continue operation*/
	function callListener(eventThis, listener, args) {
		try {
			listener.apply(eventThis, args);
		} catch(e) {
			_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
		}
	}

	/**
	 * Remove listeners that match listener
	 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
	 * @param listener the listener callback to remove
	 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
	 */
	function removeListener(targetListeners, listener, eventFilter) {
		var listeners, idx, eventName, targetListenersIndex;

		for (targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
			listeners = targetListeners[targetListenersIndex];
			if (eventFilter) { listeners = listeners[eventFilter]; }

			if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners)) {
				while ((idx = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIndexOf(listeners, listener)) !== -1) {
					listeners.splice(idx, 1);
				}
				/* If events object has an event name key with no listeners then
				   remove the key to stop the list growing indefinitely */
				if (eventFilter && (listeners.length === 0)) {
					delete targetListeners[targetListenersIndex][eventFilter];
				}
			} else if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isObject(listeners)) {
				/* events */
				for (eventName in listeners) {
					if (listeners.hasOwnProperty(eventName) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners[eventName])) {
						removeListener([listeners], listener, eventName);
					}
				}
			}
		}
	}

	/**
	 * Add an event listener
	 * @param event (optional) the name of the event to listen to
	 *        if not supplied, all events trigger a call to the listener
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.on = function(event, listener) {
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.any.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.any.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.on(ev, listener);
			});
		} else {
			var listeners = (this.events[event] || (this.events[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Remove one or more event listeners
	 * @param event (optional) the name of the event whose listener
	 *        is to be removed. If not supplied, the listener is
	 *        treated as an 'any' listener
	 * @param listener (optional) the listener to remove. If not
	 *        supplied, all listeners are removed.
	 */
	EventEmitter.prototype.off = function(event, listener) {
		if(arguments.length == 0 || (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(listener))) {
			this.any = [];
			this.events = {};
			this.anyOnce = [];
			this.eventsOnce = {};
			return;
		}
		if(arguments.length == 1) {
			if(typeof(event) == 'function') {
				/* we take this to be the listener and treat the event as "any" .. */
				listener = event;
				event = null;
			}
			/* ... or we take event to be the actual event name and listener to be all */
		}

		if(listener && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
			return;
		}

		if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.off(ev, listener);
			});
		}

		/* "normal" case where event is an actual event */
		if(listener) {
			removeListener([this.events, this.eventsOnce], listener, event);
		} else {
			delete this.events[event];
			delete this.eventsOnce[event];
		}
	};

	/**
	 * Get the array of listeners for a given event; excludes once events
	 * @param event (optional) the name of the event, or none for 'any'
	 * @return array of events, or null if none
	 */
	EventEmitter.prototype.listeners = function(event) {
		if(event) {
			var listeners = (this.events[event] || []);
			if(this.eventsOnce[event])
				Array.prototype.push.apply(listeners, this.eventsOnce[event]);
			return listeners.length ? listeners : null;
		}
		return this.any.length ? this.any : null;
	};

	/**
	 * Emit an event
	 * @param event the event name
	 * @param args the arguments to pass to the listener
	 */
	EventEmitter.prototype.emit = function(event  /* , args... */) {
		var args = Array.prototype.slice.call(arguments, 1);
		var eventThis = {event:event};
		var listeners = [];

		if(this.anyOnce.length) {
			Array.prototype.push.apply(listeners, this.anyOnce);
			this.anyOnce = [];
		}
		if(this.any.length) {
			Array.prototype.push.apply(listeners, this.any);
		}
		var eventsOnceListeners = this.eventsOnce[event];
		if(eventsOnceListeners) {
			Array.prototype.push.apply(listeners, eventsOnceListeners);
			delete this.eventsOnce[event];
		}
		var eventsListeners = this.events[event];
		if(eventsListeners) {
			Array.prototype.push.apply(listeners, eventsListeners);
		}

		_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(listeners, function(listener) {
			callListener(eventThis, listener, args);
		});
	};

	/**
	 * Listen for a single occurrence of an event
	 * @param event the name of the event to listen to
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.once = function(event, listener) {
		var argCount = arguments.length, self = this;
		if((argCount === 0 || (argCount === 1 && typeof event !== 'function')) && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				self.once(event, resolve);
			});
		}
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.anyOnce.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.anyOnce.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)){
			throw("Arrays of events can only be used with on(), not once()");
		} else {
			var listeners = (this.eventsOnce[event] || (this.eventsOnce[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Private API
	 *
	 * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
	 * @param targetState the name of the state event to listen to
	 * @param currentState the name of the current state of this object
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.whenState = function(targetState, currentState, listener /* ...listenerArgs */) {
		var eventThis = {event:targetState},
			self = this,
			listenerArgs = Array.prototype.slice.call(arguments, 3);

		if((typeof(targetState) !== 'string') || (typeof(currentState) !== 'string')) {
			throw("whenState requires a valid event String argument");
		}
		if(typeof listener !== 'function' && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				EventEmitter.prototype.whenState.apply(self, [targetState, currentState, resolve].concat(listenerArgs));
			});
		}
		if(targetState === currentState) {
			callListener(eventThis, listener, listenerArgs);
		} else {
			this.once(targetState, listener);
		}
	}

	return EventEmitter;
})();

/* harmony default export */ __webpack_exports__["a"] = (EventEmitter);


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_59761__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_59761__(1);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_59761__(2);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_59761__(9);
/* harmony import */ var _presencemessage__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_59761__(11);





var ProtocolMessage = (function() {

	function ProtocolMessage() {
		this.action = undefined;
		this.flags = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.count = undefined;
		this.error = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.connectionSerial = undefined;
		this.channel = undefined;
		this.channelSerial = undefined;
		this.msgSerial = undefined;
		this.messages = undefined;
		this.presence = undefined;
		this.auth = undefined;
		this.params = undefined;
	}

	var actions = ProtocolMessage.Action = {
		'HEARTBEAT' : 0,
		'ACK' : 1,
		'NACK' : 2,
		'CONNECT' : 3,
		'CONNECTED' : 4,
		'DISCONNECT' : 5,
		'DISCONNECTED' : 6,
		'CLOSE' : 7,
		'CLOSED' : 8,
		'ERROR' : 9,
		'ATTACH' : 10,
		'ATTACHED' : 11,
		'DETACH' : 12,
		'DETACHED' : 13,
		'PRESENCE' : 14,
		'MESSAGE' : 15,
		'SYNC' : 16,
		'AUTH' : 17
	};

	ProtocolMessage.channelModes = [ 'PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE' ];

	ProtocolMessage.ActionName = [];
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(ProtocolMessage.Action, true), function(name) {
		ProtocolMessage.ActionName[actions[name]] = name;
	});

	var flags = {
		/* Channel attach state flags */
		'HAS_PRESENCE':       1 << 0,
		'HAS_BACKLOG':        1 << 1,
		'RESUMED':            1 << 2,
		'TRANSIENT':          1 << 4,
		'ATTACH_RESUME':      1 << 5,
		/* Channel mode flags */
		'PRESENCE':           1 << 16,
		'PUBLISH':            1 << 17,
		'SUBSCRIBE':          1 << 18,
		'PRESENCE_SUBSCRIBE': 1 << 19
	};
	var flagNames = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(flags);
	flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;

	ProtocolMessage.prototype.hasFlag = function(flag) {
		return ((this.flags & flags[flag]) > 0);
	};

	ProtocolMessage.prototype.setFlag = function(flag) {
		return this.flags = this.flags | flags[flag];
	};

	ProtocolMessage.prototype.getMode = function() {
		return this.flags && (this.flags & flags.MODE_ALL);
	};

	ProtocolMessage.prototype.encodeModesToFlags = function(modes) {
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(modes, function(mode) {
			self.setFlag(mode);
		});
	};

	ProtocolMessage.prototype.decodeModesFromFlags = function() {
		var modes = [],
			self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(ProtocolMessage.channelModes, function(mode) {
			if(self.hasFlag(mode)) {
				modes.push(mode);
			}
		});
		return modes.length > 0 ? modes : undefined;
	};

	ProtocolMessage.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].encodeBody;

	ProtocolMessage.deserialize = function(serialized, format) {
		var deserialized = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].decodeBody(serialized, format);
		return ProtocolMessage.fromDeserialized(deserialized);
	};

	ProtocolMessage.fromDeserialized = function(deserialized) {
		var error = deserialized.error;
		if(error) deserialized.error = _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(error);
		var messages = deserialized.messages;
		if(messages) for(var i = 0; i < messages.length; i++) messages[i] = _message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValues(messages[i]);
		var presence = deserialized.presence;
		if(presence) for(var i = 0; i < presence.length; i++) presence[i] = _presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(presence[i], true);
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), deserialized);
	};

	ProtocolMessage.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), values);
	};

	function toStringArray(array) {
		var result = [];
		if (array) {
			for (var i = 0; i < array.length; i++) {
				result.push(array[i].toString());
			}
		}
		return '[ ' + result.join(', ') + ' ]';
	}

	var simpleAttributes = 'id channel channelSerial connectionId connectionKey connectionSerial count msgSerial timestamp'.split(' ');

	ProtocolMessage.stringify = function(msg) {
		var result = '[ProtocolMessage';
		if(msg.action !== undefined)
			result += '; action=' + ProtocolMessage.ActionName[msg.action] || 0;

		var attribute;
		for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
			attribute = simpleAttributes[attribIndex];
			if(msg[attribute] !== undefined)
				result += '; ' + attribute + '=' + msg[attribute];
		}

		if(msg.messages)
			result += '; messages=' + toStringArray(_message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValuesArray(msg.messages));
		if(msg.presence)
			result += '; presence=' + toStringArray(_presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValuesArray(msg.presence));
		if(msg.error)
			result += '; error=' + _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(msg.error).toString();
		if(msg.auth && msg.auth.accessToken)
			result += '; token=' + msg.auth.accessToken;
		if(msg.flags)
			result += '; flags=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrFilter(flagNames, function(flag) {
				return msg.hasFlag(flag);
			}).join(',');
		if(msg.params) {
			var stringifiedParams = '';
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].forInOwnNonNullProps(msg.params, function(prop) {
				if (stringifiedParams.length > 0) {
					stringifiedParams += '; ';
				}
				stringifiedParams += prop + '=' + msg.params[prop];
			});
			if (stringifiedParams.length > 0) {
				result += '; params=[' + stringifiedParams + ']';
			}
		}
		result += ']';
		return result;
	};

	/* Only valid for channel messages */
	ProtocolMessage.isDuplicate = function(a, b) {
		if (a && b) {
			if ((a.action === actions.MESSAGE || a.action === actions.PRESENCE) &&
				(a.action === b.action) &&
				(a.channel === b.channel) &&
				(a.id === b.id)) {
				if (a.action === actions.PRESENCE) {
					return true;
				} else if (a.messages.length === b.messages.length) {
					for (var i = 0; i < a.messages.length; i++) {
						var aMessage = a.messages[i];
						var bMessage = b.messages[i];
						if ((aMessage.extras && aMessage.extras.delta && aMessage.extras.delta.format) !==
							(bMessage.extras && bMessage.extras.delta && bMessage.extras.delta.format)) {
							return false;
						}
					}

					return true;
				}
			}
		}

		return false;
	};

	return ProtocolMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (ProtocolMessage);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_66965__) {

"use strict";
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_66965__(4);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_66965__(1);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_66965__(0);
/* harmony import */ var platform_crypto__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_66965__(18);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_66965__(2);






var Message = (function() {

	function Message() {
		this.name = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.extras = undefined;
		this.size = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	Message.prototype.toJSON = function() {
		var result = {
			name: this.name,
			id: this.id,
			clientId: this.clientId,
			connectionId: this.connectionId,
			connectionKey: this.connectionKey,
			encoding: this.encoding,
			extras: this.extras
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	Message.prototype.toString = function() {
		var result = '[Message';
		if(this.name)
			result += '; name=' + this.name;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.extras)
			result += '; extras =' + JSON.stringify(this.extras);
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		if(this.extras)
			result += '; extras=' + JSON.stringify(this.extras);
		result += ']';
		return result;
	};

	Message.encrypt = function(msg, options, callback) {
		var data = msg.data,
			encoding = msg.encoding,
			cipher = options.channelCipher;

		encoding = encoding ? (encoding + '/') : '';
		if(!platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(String(data));
			encoding = encoding + 'utf-8/';
		}
		cipher.encrypt(data, function(err, data) {
			if (err) {
				callback(err);
				return;
			}
			msg.data = data;
			msg.encoding = encoding + 'cipher+' + cipher.algorithm;
			callback(null, msg);
		});
	};

	Message.encode = function(msg, options, callback) {
		var data = msg.data, encoding,
			nativeDataType = typeof(data) == 'string' || platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data) || data === null || data === undefined;

		if (!nativeDataType) {
			if (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isObject(data) || _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isArray(data)) {
				msg.data = JSON.stringify(data);
				msg.encoding = (encoding = msg.encoding) ? (encoding + '/json') : 'json';
			} else {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Data type is unsupported', 40013, 400);
			}
		}

		if(options != null && options.cipher) {
			Message.encrypt(msg, options, callback);
		} else {
			callback(null, msg);
		}
	};

	Message.encodeArray = function(messages, options, callback) {
		var processed = 0;
		for (var i = 0; i < messages.length; i++) {
			Message.encode(messages[i], options, function(err, msg) {
				if (err) {
					callback(err);
					return;
				}
				processed++;
				if (processed == messages.length) {
					callback(null, messages);
				}
			});
		}
	};

	Message.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].encodeBody;

	Message.decode = function(message, context) {
		/* The second argument could be either EncodingDecodingContext that contains ChannelOptions or ChannelOptions */
		if(!context || !context.channelOptions) {
			var channelOptions = context;
			context = {
				channelOptions: channelOptions,
				plugins: { },
				baseEncodedPreviousPayload: undefined
			};
		}

		var lastPayload = message.data;
		var encoding = message.encoding;
		if(encoding) {
			var xforms = encoding.split('/'),
				lastProcessedEncodingIndex, encodingsToProcess = xforms.length,
				data = message.data;

			try {
				while((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
					var match = xforms[--encodingsToProcess].match(/([\-\w]+)(\+([\w\-]+))?/);
					if(!match) break;
					var xform = match[1];
					switch(xform) {
						case 'base64':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Decode(String(data));
							if(lastProcessedEncodingIndex == xforms.length) {
								lastPayload = data;
							}
							continue;
						case 'utf-8':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Decode(data);
							continue;
						case 'json':
							data = JSON.parse(data);
							continue;
						case 'cipher':
							if(context.channelOptions != null && context.channelOptions.cipher) {
								var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
								/* don't attempt to decrypt unless the cipher params are compatible */
								if(xformAlgorithm != cipher.algorithm) {
									throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');
								}
								data = cipher.decrypt(data);
								continue;
							} else {
								throw new Error('Unable to decrypt message; not an encrypted channel');
							}
						case 'vcdiff':
							if(!context.plugins || !context.plugins.vcdiff) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);
							}
							if(typeof Uint8Array === 'undefined') {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)', 40020, 400);
							}
							try {
								var deltaBase = context.baseEncodedPreviousPayload;
								if(typeof deltaBase === 'string') {
									deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(deltaBase);
								}

								/* vcdiff expects Uint8Arrays, can't copy with ArrayBuffers. (also, if we
								 * don't have a TextDecoder, deltaBase might be a WordArray here, so need
								 * to process it into a buffer anyway) */
								deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(deltaBase);
								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);

								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
								lastPayload = data;
							} catch(e) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Vcdiff delta decode failed with ' + e, 40018, 400);
							}
							continue;
						default:
							throw new Error("Unknown encoding");
					}
					break;
				}
			} catch(e) {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Error processing the ' + xform + ' encoding, decoder returned ' + e.message + '', e.code || 40013, 400);
			} finally {
				message.encoding = (lastProcessedEncodingIndex <= 0) ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');
				message.data = data;
			}
		}
		context.baseEncodedPreviousPayload = lastPayload;
	};

	Message.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = Message.fromValues(body[i]);
			try {
				Message.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	Message.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(new Message(), values);
	};

	Message.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = Message.fromValues(values[i]);
		return result;
	};

	function normalizeCipherOptions(options) {
		if(options && options.cipher && !options.cipher.channelCipher) {
			if(!platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		}
	}

	Message.fromEncoded = function(encoded, options) {
		var msg = Message.fromValues(encoded);
		normalizeCipherOptions(options);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			Message.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromEncoded()', e.toString());
		}
		return msg;
	};

	Message.fromEncodedArray = function(encodedArray, options) {
		normalizeCipherOptions(options);
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return Message.fromEncoded(encoded, options);
		});
	};

	function getMessageSize(msg) {
		var size = 0;
		if(msg.name) {
			size += msg.name.length;
		}
		if(msg.clientId) {
			size += msg.clientId.length;
		}
		if(msg.extras) {
			size += JSON.stringify(msg.extras).length;
		}
		if(msg.data) {
			size += _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].dataSizeBytes(msg.data);
		}
		return size;
	};

	/* This should be called on encode()d (and encrypt()d) Messages (as it
	 * assumes the data is a string or buffer) */
	Message.getMessagesSize = function(messages) {
		var msg, total = 0;
		for(var i=0; i<messages.length; i++) {
			msg = messages[i];
			total += (msg.size || (msg.size = getMessageSize(msg)))
		}
		return total;
	};

	return Message;
})();

/* harmony default export */ __webpack_exports__["a"] = (Message);


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_78788__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_78788__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_80940__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_80940__(3);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_80940__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_80940__(4);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_80940__(9);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_80940__(1);






var PresenceMessage = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function toActionValue(actionString) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrIndexOf(PresenceMessage.Actions, actionString)
	}

	function PresenceMessage() {
		this.action = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.size = undefined;
	}

	PresenceMessage.Actions = [
		'absent',
		'present',
		'enter',
		'leave',
		'update'
	];

	/* Returns whether this presenceMessage is synthesized, i.e. was not actually
	 * sent by the connection (usually means a leave event sent 15s after a
	 * disconnection). This is useful because synthesized messages cannot be
	 * compared for newness by id lexicographically - RTP2b1
	 */
	PresenceMessage.prototype.isSynthesized = function() {
		return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
	};

	/* RTP2b2 */
	PresenceMessage.prototype.parseId = function() {
		var parts = this.id.split(':');
		return {
			connectionId: parts[0],
			msgSerial: parseInt(parts[1], 10),
			index: parseInt(parts[2], 10)
		};
	};

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PresenceMessage.prototype.toJSON = function() {
		var result = {
			clientId: this.clientId,
			/* Convert presence action back to an int for sending to Ably */
			action: toActionValue(this.action),
			encoding: this.encoding
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	PresenceMessage.prototype.toString = function() {
		var result = '[PresenceMessage';
		result += '; action=' + this.action;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		result += ']';
		return result;
	};
	PresenceMessage.encode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].encode;
	PresenceMessage.decode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].decode;

	PresenceMessage.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = PresenceMessage.fromValues(body[i], true);
			try {
				PresenceMessage.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	/* Creates a PresenceMessage from specified values, with a string presence action */
	PresenceMessage.fromValues = function(values, stringifyAction) {
		if(stringifyAction) {
			values.action = PresenceMessage.Actions[values.action]
		}
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].mixin(new PresenceMessage(), values);
	};

	PresenceMessage.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PresenceMessage.fromValues(values[i]);
		return result;
	};

	PresenceMessage.fromEncoded = function(encoded, options) {
		var msg = PresenceMessage.fromValues(encoded, true);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			PresenceMessage.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());
		}
		return msg;
	};

	PresenceMessage.fromEncodedArray = function(encodedArray, options) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return PresenceMessage.fromEncoded(encoded, options);
		});
	};

	PresenceMessage.getMessagesSize = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getMessagesSize;

	return PresenceMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (PresenceMessage);


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_87173__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_87173__(42);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_87173__(20)))

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_110552__) {

"use strict";
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_110552__(2);


var ConnectionError = {
	disconnected: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80003,
		message: 'Connection to server temporarily unavailable'
	}),
	suspended: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80002,
		message: 'Connection to server unavailable'
	}),
	failed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80000,
		message: 'Connection failed or disconnected by server'
	}),
	closing: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closing'
	}),
	closed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closed'
	}),
	unknownConnectionErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50002,
		message: 'Internal connection error'
	}),
	unknownChannelErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50001,
		message: 'Internal channel error'
	})
};

/* harmony default export */ __webpack_exports__["a"] = (ConnectionError);


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_112073__) {

"use strict";

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_112073__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_112073__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_112073__(1);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_112073__(6);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var multicaster = __nested_webpack_require_112073__(22);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_112073__(4);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_112073__(2);

// CONCATENATED MODULE: ./browser/lib/util/base64.js
/*
 Copyright (c) 2008 Fred Palmer fred.palmer_at_gmail.com

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 */
var Base64 = (function() {
	function StringBuffer()
	{
		this.buffer = [];
	}

	StringBuffer.prototype.append = function append(string)
	{
		this.buffer.push(string);
		return this;
	};

	StringBuffer.prototype.toString = function toString()
	{
		return this.buffer.join("");
	};

	var Base64 =
	{
		codex : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

		encode : function (input)
		{
			var output = new StringBuffer();
			var codex = Base64.codex;

			var enumerator = new Utf8EncodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var chr1 = enumerator.current;

				enumerator.moveNext();
				var chr2 = enumerator.current;

				enumerator.moveNext();
				var chr3 = enumerator.current;

				var enc1 = chr1 >> 2;
				var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
				var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
				var enc4 = chr3 & 63;

				if (isNaN(chr2))
				{
					enc3 = enc4 = 64;
				}
				else if (isNaN(chr3))
				{
					enc4 = 64;
				}

				output.append(codex.charAt(enc1) + codex.charAt(enc2) + codex.charAt(enc3) + codex.charAt(enc4));
			}

			return output.toString();
		},

		decode : function (input)
		{
			var output = new StringBuffer();

			var enumerator = new Base64DecodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var charCode = enumerator.current;

				if (charCode < 128)
					output.append(String.fromCharCode(charCode));
				else if ((charCode > 191) && (charCode < 224))
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 31) << 6) | (charCode2 & 63)));
				}
				else
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					enumerator.moveNext();
					var charCode3 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 15) << 12) | ((charCode2 & 63) << 6) | (charCode3 & 63)));
				}
			}

			return output.toString();
		}
	};

	function Utf8EncodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Utf8EncodeEnumerator.prototype =
	{
		current: Number.NaN,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = Number.NaN;
				return false;
			}
			else
			{
				var charCode = this._input.charCodeAt(++this._index);

				// "\r\n" -> "\n"
				//
				if ((charCode == 13) && (this._input.charCodeAt(this._index + 1) == 10))
				{
					charCode = 10;
					this._index += 2;
				}

				if (charCode < 128)
				{
					this.current = charCode;
				}
				else if ((charCode > 127) && (charCode < 2048))
				{
					this.current = (charCode >> 6) | 192;
					this._buffer.push((charCode & 63) | 128);
				}
				else
				{
					this.current = (charCode >> 12) | 224;
					this._buffer.push(((charCode >> 6) & 63) | 128);
					this._buffer.push((charCode & 63) | 128);
				}

				return true;
			}
		}
	};

	function Base64DecodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Base64DecodeEnumerator.prototype =
	{
		current: 64,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = 64;
				return false;
			}
			else
			{
				var enc1 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc2 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc3 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc4 = Base64.codex.indexOf(this._input.charAt(++this._index));

				var chr1 = (enc1 << 2) | (enc2 >> 4);
				var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
				var chr3 = ((enc3 & 3) << 6) | enc4;

				this.current = chr1;

				if (enc3 != 64)
					this._buffer.push(chr2);

				if (enc4 != 64)
					this._buffer.push(chr3);

				return true;
			}
		}
	};

	return Base64;
})();

/* harmony default export */ var base64 = (Base64);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/hmac-sha256.js
var hmac_sha256 = __nested_webpack_require_112073__(38);
var hmac_sha256_default = /*#__PURE__*/__nested_webpack_require_112073__.n(hmac_sha256);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/enc-base64.js
var enc_base64 = __nested_webpack_require_112073__(17);

// CONCATENATED MODULE: ./common/lib/client/auth.js











var auth_Auth = (function() {
	var MAX_TOKEN_LENGTH = Math.pow(2, 17);
	function noop() {}
	function random() { return ('000000' + Math.floor(Math.random() * 1E16)).slice(-16); }
	function normaliseAuthcallbackError(err) {
		/* A client auth callback may give errors in any number of formats; normalise to an errorinfo */
		if(!utils["a" /* default */].isErrorInfo(err)) {
			return new errorinfo["a" /* default */](utils["a" /* default */].inspectError(err), err.code || 40170, err.statusCode || 401);
		}
		/* network errors will not have an inherent error code */
		if(!err.code) {
			if(err.statusCode === 403) {
				err.code = 40300;
			} else {
				err.code = 40170;
				/* normalise statusCode to 401 per RSA4e */
				err.statusCode = 401;
			}
		}
		return err;
	}

	var hmac, toBase64;
	if(platform_browser["a" /* default */].createHmac) {
		toBase64 = function(str) { return (Buffer.from(str, 'ascii')).toString('base64'); };
		hmac = function(text, key) {
			var inst = platform_browser["a" /* default */].createHmac('SHA256', key);
			inst.update(text);
			return inst.digest('base64');
		};
	} else {
		toBase64 = base64.encode;
		hmac = function(text, key) {
			return Object(enc_base64["stringify"])(hmac_sha256_default()(text, key));
		};
	}

	function c14n(capability) {
		if(!capability)
			return '';

		if(typeof(capability) == 'string')
			capability = JSON.parse(capability);

		var c14nCapability = {};
		var keys = utils["a" /* default */].keysArray(capability, true);
		if(!keys)
			return '';
		keys.sort();
		for(var i = 0; i < keys.length; i++) {
			c14nCapability[keys[i]] = capability[keys[i]].sort();
		}
		return JSON.stringify(c14nCapability);
	}

	function logAndValidateTokenAuthMethod(authOptions) {
		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authCallback');
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authUrl');
		} else if(authOptions.key) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with client-side signing');
		} else if(authOptions.tokenDetails) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with supplied token only');
		} else {
			var msg = 'authOptions must include valid authentication parameters';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
			throw new Error(msg);
		}
	}

	function basicAuthForced(options) {
		return 'useTokenAuth' in options && !options.useTokenAuth;
	}

	/* RSA4 */
	function useTokenAuth(options) {
		return options.useTokenAuth ||
			(!basicAuthForced(options) &&
			 (options.authCallback ||
			  options.authUrl      ||
			  options.token        ||
			  options.tokenDetails))
	}

	/* RSA4a */
	function noWayToRenew(options) {
		return !options.key &&
			!options.authCallback &&
			!options.authUrl;
	}

	var trId = 0;
	function getTokenRequestId() {
		return trId++;
	}

	function Auth(client, options) {
		this.client = client;
		this.tokenParams = options.defaultTokenParams || {};
		/* The id of the current token request if one is in progress, else null */
		this.currentTokenRequestId = null;
		this.waitingForTokenRequest = null;

		if(useTokenAuth(options)) {
			/* Token auth */
			if(options.key && !hmac) {
				var msg = 'client-side token request signing not supported';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new Error(msg);
			}
			if(noWayToRenew(options)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			}
			this._saveTokenOptions(options.defaultTokenParams, options);
			logAndValidateTokenAuthMethod(this.authOptions);
		} else {
			/* Basic auth */
			if(!options.key) {
				var msg = 'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new errorinfo["a" /* default */](msg, 40160, 401);
			}
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'anonymous, using basic auth');
			this._saveBasicOptions(options);
		}
	}

	/**
	 * Instructs the library to get a token immediately and ensures Token Auth
	 * is used for all future requests, storing the tokenParams and authOptions
	 * given as the new defaults for subsequent use.
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 *
	 * - ttl:        (optional) the requested life of any new token in ms. If none
	 *               is specified a default of 1 hour is provided. The maximum lifetime
	 *               is 24hours; any request exceeeding that lifetime will be rejected
	 *               with an error.
	 *
	 * - capability: (optional) the capability to associate with the access token.
	 *               If none is specified, a token will be requested with all of the
	 *               capabilities of the specified key.
	 *
	 * - clientId:   (optional) a client Id to associate with the token
	 *
	 * - timestamp:  (optional) the time in ms since the epoch. If none is specified,
	 *               the system will be queried for a time value to use.
	 *
	 * @param authOptions
	 * an object containing auth options relevant to token auth:
	 *
	 * - queryTime   (optional) boolean indicating that the Ably system should be
	 *               queried for the current time when none is specified explicitly.
	 *
	 * - tokenDetails: (optional) object: An authenticated TokenDetails object.
	 *
	 * - token:        (optional) string: the `token` property of a tokenDetails object
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.authorize = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback) {
			if(this.client.options.promises) {
				return utils["a" /* default */].promisify(this, 'authorize', arguments);
			}
			callback = noop;
		}
		var self = this;

		/* RSA10a: authorize() call implies token auth. If a key is passed it, we
		 * just check if it doesn't clash and assume we're generating a token from it */
		if(authOptions && authOptions.key && (this.authOptions.key !== authOptions.key)) {
			throw new errorinfo["a" /* default */]('Unable to update auth options with incompatible key', 40102, 401);
		}

		if(authOptions && ('force' in authOptions)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');
			/* Emulate the old behaviour: if 'force' was the only member of authOptions,
			 * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */
			if(utils["a" /* default */].isOnlyPropIn(authOptions, 'force')) {
				authOptions = null;
			}
		}

		this._forceNewToken(tokenParams, authOptions, function(err, tokenDetails) {
			if(err) {
				if(self.client.connection) {
					/* We interpret RSA4d as including requests made by a client lib to
					 * authenticate triggered by an explicit authorize() or an AUTH received from
					 * ably, not just connect-sequence-triggered token fetches */
					self.client.connection.connectionManager.actOnErrorFromAuthorize(err);
				}
				callback(err);
				return;
			}

			/* RTC8
			 * - When authorize called by an end user and have a realtime connection,
			 * don't call back till new token has taken effect.
			 * - Use self.client.connection as a proxy for (self.client instanceof Realtime),
			 * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */
			if(self.client.connection) {
				self.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback);
			} else {
				callback(null, tokenDetails);
			}
		})
	};

	Auth.prototype.authorise = function() {
		logger["a" /* default */].deprecated('Auth.authorise', 'Auth.authorize');
		this.authorize.apply(this, arguments);
	};

	/* For internal use, eg by connectionManager - useful when want to call back
	 * as soon as we have the new token, rather than waiting for it to take
	 * effect on the connection as #authorize does */
	Auth.prototype._forceNewToken = function(tokenParams, authOptions, callback) {
		var self = this;

		/* get rid of current token even if still valid */
		this.tokenDetails = null;

		/* _save normalises the tokenParams and authOptions and updates the auth
		 * object. All subsequent operations should use the values on `this`,
		 * not the passed in ones. */
		this._saveTokenOptions(tokenParams, authOptions);

		logAndValidateTokenAuthMethod(this.authOptions);

		this._ensureValidAuthCredentials(true, function(err, tokenDetails) {
			/* RSA10g */
			delete self.tokenParams.timestamp;
			delete self.authOptions.queryTime;
			callback(err, tokenDetails);
		});
	}

	/**
	 * Request an access token
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use.
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.requestToken = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		}
		else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'requestToken', arguments);
		}

		/* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);
		callback = callback || noop;

		/* first set up whatever callback will be used to get signed
		 * token requests */
		var tokenRequestCallback, client = this.client;

		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');
			tokenRequestCallback = authOptions.authCallback;
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');
			tokenRequestCallback = function(params, cb) {
				var authHeaders = utils["a" /* default */].mixin({accept: 'application/json, text/plain'}, authOptions.authHeaders),
					usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';
				if(!usePost) {
					/* Combine authParams with any qs params given in the authUrl */
					var queryIdx = authOptions.authUrl.indexOf('?');
					if(queryIdx > -1) {
						var providedQsParams = utils["a" /* default */].parseQueryString(authOptions.authUrl.slice(queryIdx));
						authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
						/* In case of conflict, authParams take precedence over qs params in the authUrl */
						authOptions.authParams = utils["a" /* default */].mixin(providedQsParams, authOptions.authParams);
					}
				}
				/* RSA8c2 */
				var authParams = utils["a" /* default */].mixin({}, authOptions.authParams || {}, params);
				var authUrlRequestCallback = function(err, body, headers, unpacked) {
					var contentType;
					if (err) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error: ' + utils["a" /* default */].inspectError(err));
					} else {
						contentType = headers['content-type'];
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; content-type: ' + contentType + '; body: ' + utils["a" /* default */].inspectBody(body));
					}
					if(err || unpacked) return cb(err, body);
					if(bufferutils["a" /* default */].isBuffer(body)) body = body.toString();
					if(!contentType) {
						cb(new errorinfo["a" /* default */]('authUrl response is missing a content-type header', 40170, 401));
						return;
					}
					var json = contentType.indexOf('application/json') > -1,
						text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;
					if(!json && !text) {
						cb(new errorinfo["a" /* default */]('authUrl responded with unacceptable content-type ' + contentType + ', should be either text/plain, application/jwt or application/json', 40170, 401));
						return;
					}
					if(json) {
						if(body.length > MAX_TOKEN_LENGTH) {
							cb(new errorinfo["a" /* default */]('authUrl response exceeded max permitted length', 40170, 401));
							return;
						}
						try {
							body = JSON.parse(body);
						} catch(e) {
							cb(new errorinfo["a" /* default */]('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));
							return;
						}
					}
					cb(null, body, contentType);
				};
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Requesting token from ' + authOptions.authUrl + '; Params: ' + JSON.stringify(authParams) + '; method: ' + (usePost ? 'POST' : 'GET'));
				if(usePost) {
					/* send body form-encoded */
					var headers = authHeaders || {};
					headers['content-type'] = 'application/x-www-form-urlencoded';
					var body = utils["a" /* default */].toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */
					http["a" /* default */].postUri(client, authOptions.authUrl, headers, body, {}, authUrlRequestCallback);
				} else {
					http["a" /* default */].getUri(client, authOptions.authUrl, authHeaders || {}, authParams, authUrlRequestCallback);
				}
			};
		} else if(authOptions.key) {
			var self = this;
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');
			tokenRequestCallback = function(params, cb) { self.createTokenRequest(params, authOptions, cb); };
		} else {
			var msg = "Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)";
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			callback(new errorinfo["a" /* default */](msg, 40171, 403));
			return;
		}

		/* normalise token params */
		if('capability' in tokenParams)
			tokenParams.capability = c14n(tokenParams.capability);

		var tokenRequest = function(signedTokenParams, tokenCb) {
			var keyName = signedTokenParams.keyName,
				path = '/keys/' + keyName + '/requestToken',
				tokenUri = function(host) { return client.baseUri(host) + path; };

			var requestHeaders = utils["a" /* default */].defaultPostHeaders();
			if(authOptions.requestHeaders) utils["a" /* default */].mixin(requestHeaders, authOptions.requestHeaders);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams));
			signedTokenParams = JSON.stringify(signedTokenParams);
			http["a" /* default */].post(client, tokenUri, requestHeaders, signedTokenParams, null, tokenCb);
		};

		var tokenRequestCallbackTimeoutExpired = false,
			timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,
			tokenRequestCallbackTimeout = setTimeout(function() {
				tokenRequestCallbackTimeoutExpired = true;
				var msg = 'Token request callback timed out after ' + (timeoutLength / 1000) + ' seconds';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
			}, timeoutLength);

		tokenRequestCallback(tokenParams, function(err, tokenRequestOrDetails, contentType) {
			if(tokenRequestCallbackTimeoutExpired) return;
			clearTimeout(tokenRequestCallbackTimeout);

			if(err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + utils["a" /* default */].inspectError(err));
				callback(normaliseAuthcallbackError(err));
				return;
			}
			/* the response from the callback might be a token string, a signed request or a token details */
			if(typeof(tokenRequestOrDetails) === 'string') {
				if(tokenRequestOrDetails.length === 0) {
					callback(new errorinfo["a" /* default */]('Token string is empty', 40170, 401));
				} else if(tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
					callback(new errorinfo["a" /* default */]('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));
				} else if(tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {
					/* common failure mode with poorly-implemented authCallbacks */
					callback(new errorinfo["a" /* default */]('Token string was literal null/undefined', 40170, 401));
				} else if((tokenRequestOrDetails[0] === '{') && !(contentType && contentType.indexOf('application/jwt') > -1)) {
					callback(new errorinfo["a" /* default */]('Token was double-encoded; make sure you\'re not JSON-encoding an already encoded token request or details', 40170, 401));
				} else {
					callback(null, {token: tokenRequestOrDetails});
				}
				return;
			}
			if(typeof(tokenRequestOrDetails) !== 'object') {
				var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' + typeof(tokenRequestOrDetails);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			var objectSize = JSON.stringify(tokenRequestOrDetails).length;
			if(objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
				callback(new errorinfo["a" /* default */]('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));
				return;
			}
			if('issued' in tokenRequestOrDetails) {
				/* a tokenDetails object */
				callback(null, tokenRequestOrDetails);
				return;
			}
			if(!('keyName' in tokenRequestOrDetails)) {
				var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			/* it's a token request, so make the request */
			tokenRequest(tokenRequestOrDetails, function(err, tokenResponse, headers, unpacked) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + utils["a" /* default */].inspectError(err));
					callback(normaliseAuthcallbackError(err));
					return;
				}
				if(!unpacked) tokenResponse = JSON.parse(tokenResponse);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'token received');
				callback(null, tokenResponse);
			});
		});
	};

	/**
	 * Create and sign a token request based on the given options.
	 * NOTE this can only be used when the key value is available locally.
	 * Otherwise, signed token requests must be obtained from the key
	 * owner (either using the token request callback or url).
	 *
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use. If not specified, a key passed in constructing
	 *                  the Rest interface will be used
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:       (optional) the requested life of the token in ms. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 */
	Auth.prototype.createTokenRequest = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'createTokenRequest', arguments);
		}

		/* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);

		var key = authOptions.key;
		if(!key) {
			callback(new errorinfo["a" /* default */]('No key specified', 40101, 403));
			return;
		}
		var keyParts = key.split(':'),
			keyName = keyParts[0],
			keySecret = keyParts[1];

		if(!keySecret) {
			callback(new errorinfo["a" /* default */]('Invalid key specified', 40101, 403));
			return;
		}

		if(tokenParams.clientId === '') {
			callback(new errorinfo["a" /* default */]('clientId cant be an empty string', 40012, 400));
			return;
		}

		if('capability' in tokenParams) {
			tokenParams.capability = c14n(tokenParams.capability);
		}

		var request = utils["a" /* default */].mixin({ keyName: keyName }, tokenParams),
			clientId = tokenParams.clientId || '',
			ttl = tokenParams.ttl || '',
			capability = tokenParams.capability || '',
			self = this;

		(function(authoriseCb) {
			if(request.timestamp) {
				authoriseCb();
				return;
			};
			self.getTimestamp(authOptions && authOptions.queryTime, function(err, time) {
				if(err) {callback(err); return;}
				request.timestamp = time;
				authoriseCb();
			});
		})(function() {
			/* nonce */
			/* NOTE: there is no expectation that the client
			 * specifies the nonce; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			var nonce = request.nonce || (request.nonce = random()),
				timestamp = request.timestamp;

			var signText
			=	request.keyName + '\n'
			+	ttl + '\n'
			+	capability + '\n'
			+	clientId + '\n'
			+	timestamp + '\n'
			+	nonce + '\n';

			/* mac */
			/* NOTE: there is no expectation that the client
			 * specifies the mac; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			request.mac = request.mac || hmac(signText, keySecret);

			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');
			callback(null, request);
		});
	};

	/**
	 * Get the auth query params to use for a websocket connection,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthParams = function(callback) {
		if(this.method == 'basic')
			callback(null, {key: this.key});
		else
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {access_token: tokenDetails.token});
			});
	};

	/**
	 * Get the authorization header to use for a REST or comet request,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthHeaders = function(callback) {
		if(this.method == 'basic') {
			callback(null, {authorization: 'Basic ' + this.basicKey});
		} else {
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {authorization: 'Bearer ' + toBase64(tokenDetails.token)});
			});
		}
	};

	/**
	 * Get the current time based on the local clock,
	 * or if the option queryTime is true, return the server time.
	 * The server time offset from the local time is stored so that
	 * only one request to the server to get the time is ever needed
	 */
	Auth.prototype.getTimestamp = function(queryTime, callback) {
		if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
			this.client.time(callback);
		} else {
			callback(null, this.getTimestampUsingOffset());
		}
	};

	Auth.prototype.getTimestampUsingOffset = function() {
		return utils["a" /* default */].now() + (this.client.serverTimeOffset || 0);
	};

	Auth.prototype.isTimeOffsetSet = function() {
		return this.client.serverTimeOffset !== null;
	};

	Auth.prototype._saveBasicOptions = function(authOptions) {
		this.method = 'basic';
		this.key = authOptions.key;
		this.basicKey = toBase64(authOptions.key);
		this.authOptions = authOptions || {};
		if('clientId' in authOptions) {
			this._userSetClientId(authOptions.clientId);
		}
	}

	Auth.prototype._saveTokenOptions = function(tokenParams, authOptions) {
		this.method = 'token';

		if(tokenParams) {
			/* We temporarily persist tokenParams.timestamp in case a new token needs
			 * to be requested, then null it out in the callback of
			 * _ensureValidAuthCredentials for RSA10g compliance */
			this.tokenParams = tokenParams;
		}

		if(authOptions) {
			/* normalise */
			if(authOptions.token) {
				/* options.token may contain a token string or, for convenience, a TokenDetails */
				authOptions.tokenDetails = (typeof(authOptions.token) === 'string') ? {token: authOptions.token} : authOptions.token;
			}

			if(authOptions.tokenDetails) {
				this.tokenDetails = authOptions.tokenDetails;
			}

			if('clientId' in authOptions) {
				this._userSetClientId(authOptions.clientId);
			}

			this.authOptions = authOptions;
		}
	};

	/* @param forceSupersede: force a new token request even if there's one in
	 * progress, making all pending callbacks wait for the new one */
	Auth.prototype._ensureValidAuthCredentials = function(forceSupersede, callback) {
		var self = this,
			token = this.tokenDetails;

		if(token) {
			if(this._tokenClientIdMismatch(token.clientId)) {
				/* 403 to trigger a permanently failed client - RSA15c */
				callback(new errorinfo["a" /* default */]('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 403));
				return;
			}
			/* RSA4b1 -- if we have a server time offset set already, we can
			 * autoremove expired tokens. Else just use the cached token. If it is
			 * expired Ably will tell us and we'll discard it then. */
			if(!this.isTimeOffsetSet() || !token.expires || (token.expires >= this.getTimestampUsingOffset())) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);
				callback(null, token);
				return;
			}
			/* expired, so remove and fallthrough to getting a new one */
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'deleting expired token');
			this.tokenDetails = null;
		}

		(this.waitingForTokenRequest || (this.waitingForTokenRequest = Object(multicaster["a" /* default */])())).push(callback);
		if(this.currentTokenRequestId !== null && !forceSupersede) {
			return;
		}

		/* Request a new token */
		var tokenRequestId = this.currentTokenRequestId = getTokenRequestId();
		this.requestToken(this.tokenParams, this.authOptions, function(err, tokenResponse) {
			if(self.currentTokenRequestId > tokenRequestId) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth._ensureValidAuthCredentials()', 'Discarding token request response; overtaken by newer one');
				return;
			}
			self.currentTokenRequestId = null;
			var callbacks = self.waitingForTokenRequest || noop;
			self.waitingForTokenRequest = null;
			if(err) {
				callbacks(err);
				return;
			}
			callbacks(null, (self.tokenDetails = tokenResponse));
		});
	};


	/* User-set: check types, '*' is disallowed, throw any errors */
	Auth.prototype._userSetClientId = function(clientId) {
		if(!(typeof(clientId) === 'string' || clientId === null)) {
			throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
		} else if(clientId === '*') {
			throw new errorinfo["a" /* default */]('Cant use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
		} else {
			var err = this._uncheckedSetClientId(clientId);
			if(err) throw err;
		}
	};

	/* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
	Auth.prototype._uncheckedSetClientId = function(clientId) {
		if(this._tokenClientIdMismatch(clientId)) {
			/* Should never happen in normal circumstances as realtime should
			 * recognise mismatch and return an error */
			var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;
			var err = new errorinfo["a" /* default */](msg, 40102, 401);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);
			return err;
		} else {
			/* RSA7a4: if options.clientId is provided and is not
			 * null, it overrides defaultTokenParams.clientId */
			this.clientId = this.tokenParams.clientId = clientId;
			return null;
		}
	};

	Auth.prototype._tokenClientIdMismatch = function(tokenClientId) {
		return this.clientId &&
			(this.clientId !== '*') &&
			tokenClientId &&
			(tokenClientId !== '*') &&
			(this.clientId !== tokenClientId);
	};

	Auth.isTokenErr = function(error) {
		return error.code && (error.code >= 40140) && (error.code < 40150);
	};

	return Auth;
})();

/* harmony default export */ var auth = __webpack_exports__["a"] = (auth_Auth);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_153444__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_153444__(1);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_153444__(8);
/* harmony import */ var _transport_transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_153444__(19);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_153444__(0);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_153444__(5);
/* harmony import */ var _connectionerror__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_153444__(13);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_153444__(14);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_153444__(2);









var CometTransport = (function() {

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	/* TODO: can remove once realtime sends protocol message responses for comet errors */
	function shouldBeErrorAction(err) {
		var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
		if(err.code) {
			if(_client_auth__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].isTokenErr(err)) return false;
			if(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIn(UNRESOLVABLE_ERROR_CODES, err.code)) return true;
			return (err.code >= 40000 && err.code < 50000);
		} else {
			/* Likely a network or transport error of some kind. Certainly not fatal to the connection */
			return false;
		}
	}

	function protocolMessageFromRawError(err) {
		/* err will be either a legacy (non-protocolmessage) comet error response
		 * (which will have an err.code), or a xhr/network error (which won't). */
		if(shouldBeErrorAction(err)) {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.ERROR, error: err})];
		} else {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.DISCONNECTED, error: err})];
		}
	}

	/*
	 * A base comet transport class
	 */
	function CometTransport(connectionManager, auth, params) {
		/* binary not supported for comet, so just fall back to default */
		params.format = undefined;
		params.heartbeats = true;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		/* streaming defaults to true */
		this.stream = ('stream' in params) ? params.stream : true;
		this.sendRequest = null;
		this.recvRequest = null;
		this.pendingCallback = null;
		this.pendingItems = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(CometTransport, _transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	CometTransport.REQ_SEND = REQ_SEND;
	CometTransport.REQ_RECV = REQ_RECV;
	CometTransport.REQ_RECV_POLL = REQ_RECV_POLL;
	CometTransport.REQ_RECV_STREAM = REQ_RECV_STREAM;

	/* public instance methods */
	CometTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'starting');
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var host = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getHost(options, params.host);
		var port = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getPort(options);
		var cometScheme = options.tls ? 'https://' : 'http://';

		this.baseUri = cometScheme + host + ':' + port + '/comet/';
		var connectUri = this.baseUri + 'connect';
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(err) {
				self.disconnect(err);
				return;
			}
			if(self.isDisposed) {
				return;
			}
			self.authParams = authParams;
			var connectParams = self.params.getConnectParams(authParams);
			if('stream' in connectParams) self.stream = connectParams.stream;
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(connectParams));

			/* this will be the 'recvRequest' so this connection can stream messages */
			var preconnected = false,
				connectRequest = self.recvRequest = self.createRequest(connectUri, null, connectParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV));

			connectRequest.on('data', function(data) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					return;
				}
				if(!preconnected) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onData(data);
			});
			connectRequest.on('complete', function(err, _body, headers) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					err = err || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]('Request cancelled', 80003, 400);
				}
				self.recvRequest = null;
				/* Connect request may complete without a emitting 'data' event since that is not
				 * emitted for e.g. a non-streamed error response. Still implies preconnect. */
				if(!preconnected && !err) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onActivity();
				if(err) {
					if(err.code) {
						/* A protocol error received from realtime. TODO: once realtime
						 * consistendly sends errors wrapped in protocol messages, should be
						 * able to remove this */
						self.onData(protocolMessageFromRawError(err));
					} else {
						/* A network/xhr error. Don't bother wrapping in a protocol message,
						 * just disconnect the transport */
						self.disconnect(err);
					}
					return;
				}
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					self.recv();
				});
			});
			connectRequest.exec();
		});
	};

	CometTransport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestClose()');
		this._requestCloseOrDisconnect(true);
	};

	CometTransport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestDisconnect()');
		this._requestCloseOrDisconnect(false);
	};

	CometTransport.prototype._requestCloseOrDisconnect = function(closing) {
		var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
		if(closeOrDisconnectUri) {
			var self = this,
				request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, REQ_SEND);

			request.on('complete', function (err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
					self.finish('disconnected', err);
				}
			});
			request.exec();
		}
	};

	CometTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', '');
		if(!this.isDisposed) {
			this.isDisposed = true;
			if(this.recvRequest) {
				_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');
				this.recvRequest.abort();
				this.recvRequest = null;
			}
			/* In almost all cases the transport will be finished before it's
			 * disposed. Finish here just to make sure. */
			this.finish('disconnected', _connectionerror__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].disconnected);
			var self = this;
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.emit('disposed');
			});
		}
	};

	CometTransport.prototype.onConnect = function(message) {
		/* if this transport has been disposed whilst awaiting connection, do nothing */
		if(this.isDisposed) {
			return;
		}

		/* the connectionKey in a comet connected response is really
		 * <instId>-<connectionKey> */
		var connectionStr = message.connectionKey;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.onConnect.call(this, message);

		var baseConnectionUri =  this.baseUri + connectionStr;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri + '; connectionKey = ' + message.connectionKey);
		this.sendUri = baseConnectionUri + '/send';
		this.recvUri = baseConnectionUri + '/recv';
		this.closeUri = baseConnectionUri + '/close';
		this.disconnectUri = baseConnectionUri + '/disconnect';
	};

	CometTransport.prototype.send = function(message) {
		if(this.sendRequest) {
			/* there is a pending send, so queue this message */
			this.pendingItems = this.pendingItems || [];
			this.pendingItems.push(message);
			return;
		}
		/* send this, plus any pending, now */
		var pendingItems = this.pendingItems || [];
		pendingItems.push(message);
		this.pendingItems = null;

		this.sendItems(pendingItems);
	};

	CometTransport.prototype.sendAnyPending = function() {
		var pendingItems = this.pendingItems;

		if(!pendingItems) {
			return;
		}

		this.pendingItems = null;
		this.sendItems(pendingItems);
	}

	CometTransport.prototype.sendItems = function(items) {
		var self = this,
			sendRequest = this.sendRequest = self.createRequest(self.sendUri, null, self.authParams, this.encodeRequest(items), REQ_SEND);

		sendRequest.on('complete', function(err, data) {
			if(err) _util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
			self.sendRequest = null;

			/* the result of the request, even if a nack, is usually a protocol response
			 * contained in the data. An err is anomolous, and indicates some issue with the
			 * network,transport, or connection */
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}

			if(data) {
				self.onData(data);
			}

			if(self.pendingItems) {
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					/* If there's a new send request by now, any pending items will have
					 * been picked up by that; any new ones added since then will be
					 * picked up after that one completes */
					if(!self.sendRequest) {
						self.sendAnyPending();
					}
				});
			}
		});
		sendRequest.exec();
	};

	CometTransport.prototype.recv = function() {
		/* do nothing if there is an active request, which might be streaming */
		if(this.recvRequest)
			return;

		/* If we're no longer connected, do nothing */
		if(!this.isConnected)
			return;

		var self = this,
			recvRequest = this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV_POLL));

		recvRequest.on('data', function(data) {
			self.onData(data);
		});
		recvRequest.on('complete', function(err) {
			self.recvRequest = null;
			/* A request completing must be considered activity, as realtime sends
			 * heartbeats every 15s since a request began, not every 15s absolutely */
			self.onActivity();
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.recv();
			});
		});
		recvRequest.exec();
	};

	CometTransport.prototype.onData = function(responseData) {
		try {
			var items = this.decodeResponse(responseData);
			if(items && items.length)
				for(var i = 0; i < items.length; i++)
					this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromDeserialized(items[i]));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);
		}
	};

	CometTransport.prototype.encodeRequest = function(requestItems) {
		return JSON.stringify(requestItems);
	};

	CometTransport.prototype.decodeResponse = function(responseData) {
		if(typeof(responseData) == 'string')
			responseData = JSON.parse(responseData);
		return responseData;
	};

	/* For comet, we could do the auth update by aborting the current recv and
	 * starting a new one with the new token, that'd be sufficient for realtime.
	 * Problem is JSONP - you can't cancel truly abort a recv once started. So
	 * we need to send an AUTH for jsonp. In which case it's simpler to keep all
	 * comet transports the same and do it for all of them. So we send the AUTH
	 * instead, and don't need to abort the recv */
	CometTransport.prototype.onAuthUpdated = function(tokenDetails) {
		this.authParams = {access_token: tokenDetails.token};
	};

	return CometTransport;
})();

/* harmony default export */ __webpack_exports__["a"] = (CometTransport);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_168261__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_168261__(1);


var WebStorage = (function() {
	var sessionSupported,
		localSupported,
		test = 'ablyjs-storage-test';

	/* Even just accessing the session/localStorage object can throw a
	 * security exception in some circumstances with some browsers. In
	 * others, calling setItem will throw. So have to check in this
	 * somewhat roundabout way. (If unsupported or no global object,
	 * will throw on accessing a property of undefined) */
	try {
		global.sessionStorage.setItem(test, test);
		global.sessionStorage.removeItem(test);
		sessionSupported = true;
	} catch(e) {
		sessionSupported = false;
	}

	try {
		global.localStorage.setItem(test, test);
		global.localStorage.removeItem(test);
		localSupported = true;
	} catch(e) {
		localSupported = false;
	}

	function WebStorage() {}

	function storageInterface(session) {
		return session ? global.sessionStorage : global.localStorage;
	}

	function set(name, value, ttl, session) {
		var wrappedValue = {value: value};
		if(ttl) {
			wrappedValue.expires = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now() + ttl;
		}
		return storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
	}

	function get(name, session) {
		var rawItem = storageInterface(session).getItem(name);
		if(!rawItem) return null;
		var wrappedValue = JSON.parse(rawItem);
		if(wrappedValue.expires && (wrappedValue.expires < _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now())) {
			storageInterface(session).removeItem(name);
			return null;
		}
		return wrappedValue.value;
	}

	function remove(name, session) {
		return storageInterface(session).removeItem(name);
	}

	if(localSupported) {
		WebStorage.set    = function(name, value, ttl) { return set(name, value, ttl, false); };
		WebStorage.get    = function(name) { return get(name, false); };
		WebStorage.remove = function(name) { return remove(name, false); };
	}

	if(sessionSupported) {
		WebStorage.setSession    = function(name, value, ttl) { return set(name, value, ttl, true); };
		WebStorage.getSession    = function(name) { return get(name, true); };
		WebStorage.removeSession = function(name) { return remove(name, true); };
	}

	return WebStorage;
})();

/* harmony default export */ __webpack_exports__["a"] = (WebStorage);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_168261__(20)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_170855__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_170855__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        }
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_174891__) {

"use strict";
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_174891__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_174891__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_174891__(17);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_174891__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_174891__(28);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_174891__.n(crypto_js_build__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_174891__(3);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_174891__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_174891__(4);







var Crypto = (function() {
	var DEFAULT_ALGORITHM = 'aes';
	var DEFAULT_KEYLENGTH = 256; // bits
	var DEFAULT_MODE = 'cbc';
	var DEFAULT_BLOCKLENGTH = 16; // bytes
	var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words
	var UINT32_SUP = 0x100000000;
	var INT32_SUP = 0x80000000;

	/**
	 * Internal: generate an array of secure random words corresponding to the given length of bytes
	 * @param bytes
	 * @param callback
	 */
	var generateRandom;
	if(platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray) {
		generateRandom = platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray;
	} else if(typeof Uint32Array !== 'undefined' && platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues) {
		var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
		generateRandom = function(bytes, callback) {
			var words = bytes / 4, nativeArray = (words == DEFAULT_BLOCKLENGTH_WORDS) ? blockRandomArray : new Uint32Array(words);
			platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues(nativeArray, function(err) {
				callback(err, platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(nativeArray))
			});
		};
	} else {
		generateRandom = function(bytes, callback) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MAJOR, 'Ably.Crypto.generateRandom()', 'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()');
			var words = bytes / 4, array = new Array(words);
			for(var i = 0; i < words; i++) {
				/* cryptojs wordarrays use signed ints. When WordArray.create is fed a
				* Uint32Array unsigned are converted to signed automatically, but when
				* fed a normal array they aren't, so need to do so ourselves by
				* subtracting INT32_SUP */
				array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;
			}

			callback(null, crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(array));
		};
	}

	/**
	 * Internal: calculate the padded length of a given plaintext
	 * using PKCS5.
	 * @param plaintextLength
	 * @return
	 */
	function getPaddedLength(plaintextLength) {
		return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;
	}

	/**
	 * Internal: checks that the cipherParams are a valid combination. Currently
	 * just checks that the calculated keyLength is a valid one for aes-cbc
	 */
	function validateCipherParams(params) {
		if(params.algorithm === 'aes' && params.mode === 'cbc') {
			if(params.keyLength === 128 || params.keyLength === 256) {
				return;
			}
			throw new Error('Unsupported key length ' + params.keyLength + ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)');
		}
	}

	function normaliseBase64(string) {
		/* url-safe base64 strings use _ and - instread of / and + */
		return string.replace('_', '/').replace('-', '+');
	}

	/**
	 * Internal: a block containing zeros
	 */
	var emptyBlock = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0,0,0,0]);

	/**
	 * Internal: obtain the pkcs5 padding string for a given padded length;
	 */
	var pkcs5Padding = [
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x01000000], 1),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x02020000], 2),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x03030300], 3),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x04040404], 4),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x05050505,0x05000000], 5),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x06060606,0x06060000], 6),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x07070707,0x07070700], 7),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x08080808,0x08080808], 8),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x09090909,0x09090909,0x09000000], 9),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0a0a0a0a,0x0a0a0a0a,0x0a0a0000], 10),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0b0b0b0b,0x0b0b0b0b,0x0b0b0b00], 11),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0c0c0c0c,0x0c0c0c0c,0x0c0c0c0c], 12),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0d0d0d0d,0x0d0d0d0d,0x0d0d0d0d,0x0d000000], 13),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0e0e0e0e,0x0e0e0e0e,0x0e0e0e0e,0x0e0e0000], 14),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f], 15),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16)
	];

	/**
	 * Utility classes and interfaces for message payload encryption.
	 *
	 * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits
	 * but supporting other keylengths. Other algorithms and chaining modes are
	 * not supported directly, but supportable by extending/implementing the base
	 * classes and interfaces here.
	 *
	 * Secure random data for creation of Initialization Vectors (IVs) and keys
	 * is obtained from window.crypto.getRandomValues if available, or from
	 * Math.random() if not. Clients who do not want to depend on Math.random()
	 * should polyfill window.crypto.getRandomValues with a library that seeds
	 * a PRNG with real entropy.
	 *
	 * Each message payload is encrypted with an IV in CBC mode, and the IV is
	 * concatenated with the resulting raw ciphertext to construct the "ciphertext"
	 * data passed to the recipient.
	 */
	function Crypto() {}

	/**
	 * A class encapsulating the client-specifiable parameters for
	 * the cipher.
	 *
	 * algorithm is the name of the algorithm in the default system provider,
	 * or the lower-cased version of it; eg "aes" or "AES".
	 *
	 * Clients are recommended to not call this directly, but instead to use the
	 * Crypto.getDefaultParams helper, which will fill in any fields not supplied
	 * with default values and validation the result.
	 */
	function CipherParams() {
		this.algorithm = null;
		this.keyLength = null;
		this.mode = null;
		this.key = null;
	}
	Crypto.CipherParams = CipherParams;

	/**
	 * Obtain a complete CipherParams instance from the provided params, filling
	 * in any not provided with default values, calculating a keyLength from
	 * the supplied key, and validating the result.
	 * @param params an object containing at a minimum a `key` key with value the
	 * key, as either a binary (ArrayBuffer, Array, WordArray) or a
	 * base64-encoded string. May optionally also contain: algorithm (defaults to
	 * AES), mode (defaults to 'cbc')
	 */
	Crypto.getDefaultParams = function(params) {
		var key;
		/* Backward compatibility */
		if((typeof(params) === 'function') || (typeof(params) === 'string')) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');
			if(typeof(params) === 'function') {
				Crypto.generateRandomKey(function(key) {
					params(null, Crypto.getDefaultParams({key: key}));
				})
			} else if(typeof arguments[1] === 'function') {
				arguments[1](null, Crypto.getDefaultParams({key: params}));
			} else {
				throw new Error('Invalid arguments for Crypto.getDefaultParams');
			}
			return;
		}

		if(!params.key) {
			throw new Error('Crypto.getDefaultParams: a key is required');
		}

		if (typeof(params.key) === 'string') {
			key = Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__["parse"])(normaliseBase64(params.key));
		} else {
			key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point
		}

		var cipherParams = new CipherParams();
		cipherParams.key = key;
		cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
		cipherParams.keyLength = key.words.length * (4 * 8);
		cipherParams.mode = params.mode || DEFAULT_MODE;

		if(params.keyLength && params.keyLength !== cipherParams.keyLength) {
			throw new Error('Crypto.getDefaultParams: a keyLength of ' + params.keyLength + ' was specified, but the key actually has length ' + cipherParams.keyLength);
		}

		validateCipherParams(cipherParams);
		return cipherParams;
	};

	/**
	 * Generate a random encryption key from the supplied keylength (or the
	 * default keyLength if none supplied) as a CryptoJS WordArray
	 * @param keyLength (optional) the required keyLength in bits
	 * @param callback (err, key)
	 */
	Crypto.generateRandomKey = function(keyLength, callback) {
		if(arguments.length == 1 && typeof(keyLength) == 'function') {
			callback = keyLength;
			keyLength = undefined;
		}
		generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, callback);
	};

	/**
	 * Internal; get a ChannelCipher instance based on the given cipherParams
	 * @param params either a CipherParams instance or some subset of its
	 * fields that includes a key
	 */
	Crypto.getCipher = function(params) {
		var cipherParams = (params instanceof CipherParams) ?
		                   params :
		                   Crypto.getDefaultParams(params);

		return {cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv)};
	};

	function CBCCipher(params, blockLengthWords, iv) {
		this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;
		this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\d+$/, '');
		this.key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key);
		if(iv) {
			this.iv = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(iv).clone();
		}
		this.blockLengthWords = blockLengthWords;
	}

	CBCCipher.prototype.encrypt = function(plaintext, callback) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.encrypt()', '');
		plaintext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(plaintext);
		var plaintextLength = plaintext.sigBytes,
			paddedLength = getPaddedLength(plaintextLength),
			self = this;

		var then = function() {
			self.getIv(function(err, iv) {
				if (err) {
					callback(err);
					return;
				}
				var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));
				var ciphertext = iv.concat(cipherOut);
				callback(null, ciphertext);
			});
		};

		if (!this.encryptCipher) {
			if(this.iv) {
				this.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });
				then();
			} else {
				generateRandom(DEFAULT_BLOCKLENGTH, function(err, iv) {
					if (err) {
						callback(err);
						return;
					}
					self.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });
					self.iv = iv;
					then();
				});
			}
		} else {
			then();
		}
	};

	CBCCipher.prototype.decrypt = function(ciphertext) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.decrypt()', '');
		ciphertext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(ciphertext);
		var blockLengthWords = this.blockLengthWords,
			ciphertextWords = ciphertext.words,
			iv = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(0, blockLengthWords)),
			ciphertextBody = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(blockLengthWords));

		var decryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });
		var plaintext = decryptCipher.process(ciphertextBody);
		var epilogue = decryptCipher.finalize();
		decryptCipher.reset();
		if(epilogue && epilogue.sigBytes) plaintext.concat(epilogue);
		return plaintext;
	};

	CBCCipher.prototype.getIv = function(callback) {
		if(this.iv) {
			var iv = this.iv;
			this.iv = null;
			callback(null, iv);
			return;
		}

		/* Since the iv for a new block is the ciphertext of the last, this
		* sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as
		* returning it */
		var self = this;
		generateRandom(DEFAULT_BLOCKLENGTH, function(err, randomBlock) {
			if (err) {
				callback(err);
				return;
			} 
			callback(null, self.encryptCipher.process(randomBlock));
		});
	};

	return Crypto;
})();

/* harmony default export */ __webpack_exports__["a"] = (Crypto);


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_189584__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_189584__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_189584__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_189584__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_189584__(0);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_189584__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_189584__(2);







var Transport = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var closeMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.CLOSE});
	var disconnectMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.DISCONNECT});
	var noop = function() {};

	/*
	 * EventEmitter, generates the following events:
	 *
	 * event name       data
	 * closed           error
	 * failed           error
	 * disposed
	 * connected        null error, connectionSerial, connectionId, connectionDetails
	 * sync             connectionSerial, connectionId
	 * event            channel message object
	 */

	/* public constructor */
	function Transport(connectionManager, auth, params) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.connectionManager = connectionManager;
		connectionManager.registerProposedTransport(this);
		this.auth = auth;
		this.params = params;
		this.timeouts = params.options.timeouts;
		this.format = params.format;
		this.isConnected = false;
		this.isFinished = false;
		this.isDisposed = false;
		this.maxIdleInterval = null;
		this.idleTimer = null;
		this.lastActivity = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Transport, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Transport.prototype.connect = function() {};

	Transport.prototype.close = function() {
		if(this.isConnected) {
			this.requestClose();
		}
		this.finish('closed', _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].closed);
	};

	Transport.prototype.disconnect = function(err) {
		/* Used for network/transport issues that need to result in the transport
		 * being disconnected, but should not affect the connection */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('disconnected', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].disconnected);
	};

	Transport.prototype.fail = function(err) {
		/* Used for client-side-detected fatal connection issues */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('failed', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].failed);
	};

	Transport.prototype.finish = function(event, err) {
		if(this.isFinished) {
			return;
		}

		this.isFinished = true;
		this.isConnected = false;
		this.maxIdleInterval = null;
		clearTimeout(this.idleTimer);
		this.idleTimer = null;
		this.emit(event, err);
		this.dispose();
	};

	Transport.prototype.onProtocolMessage = function(message) {
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' + this.shortName + ': ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(message) + '; connectionId = ' + this.connectionManager.connectionId);
		}
		this.onActivity();

		switch(message.action) {
		case actions.HEARTBEAT:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId);
			this.emit('heartbeat', message.id);
			break;
		case actions.CONNECTED:
			this.onConnect(message);
			this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);
			break;
		case actions.CLOSED:
			this.onClose(message);
			break;
		case actions.DISCONNECTED:
			this.onDisconnect(message);
			break;
		case actions.ACK:
			this.emit('ack', message.msgSerial, message.count);
			break;
		case actions.NACK:
			this.emit('nack', message.msgSerial, message.count, message.error);
			break;
		case actions.SYNC:
			if(message.connectionId !== undefined) {
				/* a transport SYNC */
				this.emit('sync', message.connectionId, message);
				break;
			}
			/* otherwise it's a channel SYNC, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		case actions.AUTH:
			this.auth.authorize(function(err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
				}
			});
			break;
		case actions.ERROR:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionId = ' + this.connectionManager.connectionId + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(message.error) + (message.channel ? (', channel: ' +  message.channel) : ''));
			if(message.channel === undefined) {
				this.onFatalError(message);
				break;
			}
			/* otherwise it's a channel-specific error, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		default:
			/* all other actions are channel-specific */
			this.connectionManager.onChannelMessage(message, this);
		}
	};

	Transport.prototype.onConnect = function(message) {
		this.isConnected = true;
		var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
		if(maxPromisedIdle) {
			this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
			this.onActivity();
		}
		/* else Realtime declines to guarantee any maximum idle interval - CD2h */
	};

	Transport.prototype.onDisconnect = function(message) {
		/* Used for when the server has disconnected the client (usually with a
		 * DISCONNECTED action) */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('disconnected', err);
	};

	Transport.prototype.onFatalError = function(message) {
		/* On receipt of a fatal connection error, we can assume that the server
		 * will close the connection and the transport, and do not need to request
		 * a disconnection - RTN15i */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onFatalError()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('failed', err);
	};

	Transport.prototype.onClose = function(message) {
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onClose()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('closed', err);
	};

	Transport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestClose()', '');
		this.send(closeMessage);
	};

	Transport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestDisconnect()', '');
		this.send(disconnectMessage);
	};

	Transport.prototype.ping = function(id) {
		var msg = {action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action.HEARTBEAT};
		if(id) msg.id = id;
		this.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues(msg));
	};

	Transport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.dispose()', '');
		this.isDisposed = true;
		this.off();
	};

	Transport.prototype.onActivity = function() {
		if(!this.maxIdleInterval) { return; }
		this.lastActivity = this.connectionManager.lastActivity = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
		this.setIdleTimer(this.maxIdleInterval + 100);
	};

	Transport.prototype.setIdleTimer = function(timeout) {
		var self = this;
		if(!this.idleTimer) {
			this.idleTimer = setTimeout(function() {
				self.onIdleTimerExpire();
			}, timeout);
		}
	};

	Transport.prototype.onIdleTimerExpire = function() {
		this.idleTimer = null;
		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity,
			timeRemaining = this.maxIdleInterval - sinceLast;
		if(timeRemaining <= 0) {
			var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);
			this.disconnect(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"](msg, 80003, 408));
		} else {
			this.setIdleTimer(timeRemaining + 100);
		}
	};

	Transport.prototype.onAuthUpdated = function() {};

	return Transport;
})();

/* harmony default export */ __webpack_exports__["a"] = (Transport);


/***/ }),
/* 20 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var ConnectionStateChange = (function() {

	/* public constructor */
	function ConnectionStateChange(previous, current, retryIn, reason) {
		this.previous = previous;
		this.current = current;
		if(retryIn) this.retryIn = retryIn;
		if(reason) this.reason = reason;
	}

	return ConnectionStateChange;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionStateChange);


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_201194__) {

"use strict";
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_201194__(0);


var Multicaster = (function() {

	function Multicaster(members) {
		members = members || [];

		var handler = function() {
			for(var i = 0; i < members.length; i++) {
				var member = members[i];
				if(member) {
					try {
						member.apply(null, arguments);
					} catch(e){
						_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);
					}
				}
			}
		};

		handler.push = function() {
			Array.prototype.push.apply(members, arguments);
		};
		return handler;
	}

	return Multicaster;
})();

/* harmony default export */ __webpack_exports__["a"] = (Multicaster);


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_202134__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_202134__(1);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_202134__(3);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_202134__(5);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_202134__(0);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_202134__(6);






var ErrorReporter = (function() {
	function ErrorReporter() {}

	var levels = ErrorReporter.levels = [
		'fatal',
		'error',
		'warning',
		'info',
		'debug'
	];

	/* (level: typeof ErrorReporter.levels[number], message: string, fingerprint?: string, tags?: {[key: string]: string}): void */
	ErrorReporter.report = function(level, message, fingerprint, tags) {
		var eventId = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].randomHexString(16);

		var event = {
			event_id: eventId,
			tags: _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin({
				lib: platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].libver
			}, tags),
			platform: 'javascript',
			level: level,
			release: _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].version,
			fingerprint: fingerprint && [ fingerprint ],
			message: message,
			request: {
				headers: {
					'User-Agent': platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].userAgent
				},
				url: platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].currentUrl
			}
		};

		_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter: ' + message);
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].postUri(null, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingUrl, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingHeaders, JSON.stringify(event), {}, function(err, res) {
			_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter resulted in: ' +
				(err ? _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err) : _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectBody(res))
			);
		});
	};

	return ErrorReporter;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorReporter);


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var msgpack = (function() {
	"use strict";

	var exports = {};

	exports.inspect = inspect;
	function inspect(buffer) {
		if (buffer === undefined)
			return "undefined";
		var view;
		var type;
		if ( buffer instanceof ArrayBuffer) {
			type = "ArrayBuffer";
			view = new DataView(buffer);
		} else if ( buffer instanceof DataView) {
			type = "DataView";
			view = buffer;
		}
		if (!view)
			return JSON.stringify(buffer);
		var bytes = [];
		for (var i = 0; i < buffer.byteLength; i++) {
			if (i > 20) {
				bytes.push("...");
				break;
			}
			var byte_ = view.getUint8(i).toString(16);
			if (byte_.length === 1)
				byte_ = "0" + byte_;
			bytes.push(byte_);
		}
		return "<" + type + " " + bytes.join(" ") + ">";
	}

	// Encode string as utf8 into dataview at offset
	exports.utf8Write = utf8Write;
	function utf8Write(view, offset, string) {
		var byteLength = view.byteLength;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);

			// One byte of UTF-8
			if (codePoint < 0x80) {
				view.setUint8(offset++, codePoint >>> 0 & 0x7f | 0x00);
				continue;
			}

			// Two bytes of UTF-8
			if (codePoint < 0x800) {
				view.setUint8(offset++, codePoint >>> 6 & 0x1f | 0xc0);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Three bytes of UTF-8.
			if (codePoint < 0x10000) {
				view.setUint8(offset++, codePoint >>> 12 & 0x0f | 0xe0);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Four bytes of UTF-8
			if (codePoint < 0x110000) {
				view.setUint8(offset++, codePoint >>> 18 & 0x07 | 0xf0);
				view.setUint8(offset++, codePoint >>> 12 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
	}


	exports.utf8Read = utf8Read;
	function utf8Read(view, offset, length) {
		var string = "";
		for (var i = offset, end = offset + length; i < end; i++) {
			var byte_ = view.getUint8(i);
			// One byte character
			if ((byte_ & 0x80) === 0x00) {
				string += String.fromCharCode(byte_);
				continue;
			}
			// Two byte character
			if ((byte_ & 0xe0) === 0xc0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));
				continue;
			}
			// Three byte character
			if ((byte_ & 0xf0) === 0xe0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			// Four byte character
			if ((byte_ & 0xf8) === 0xf0) {
				string += String.fromCharCode(((byte_ & 0x07) << 18) | ((view.getUint8(++i) & 0x3f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			throw new Error("Invalid byte " + byte_.toString(16));
		}
		return string;
	}


	exports.utf8ByteCount = utf8ByteCount;
	function utf8ByteCount(string) {
		var count = 0;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);
			if (codePoint < 0x80) {
				count += 1;
				continue;
			}
			if (codePoint < 0x800) {
				count += 2;
				continue;
			}
			if (codePoint < 0x10000) {
				count += 3;
				continue;
			}
			if (codePoint < 0x110000) {
				count += 4;
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
		return count;
	}


	exports.encode = function(value, sparse) {
		var size = sizeof(value, sparse);
		if(size == 0)
			return undefined;
		var buffer = new ArrayBuffer(size);
		var view = new DataView(buffer);
		encode(value, view, 0, sparse);
		return buffer;
	};

	exports.decode = decode;

	var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
	function getInt64(view, offset) {
		offset = offset || 0;
		return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function getUint64(view, offset) {
		offset = offset || 0;
		return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function setInt64(view, offset, val) {
		if (val < 0x8000000000000000) {
			view.setInt32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0x7fffffff);
			view.setUint32(offset + 4, 0x7fffffff);
		}
	}

	function setUint64(view, offset, val) {
		if (val < 0x10000000000000000) {
			view.setUint32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0xffffffff);
			view.setUint32(offset + 4, 0xffffffff);
		}
	}

// https://gist.github.com/frsyuki/5432559 - v5 spec
//
// I've used one extension point from `fixext 1` to store `undefined`. On the wire this
// should translate to exactly 0xd40000
//
// +--------+--------+--------+
// |  0xd4  |  0x00  |  0x00  |
// +--------+--------+--------+
//    ^ fixext |        ^ value part unused (fixed to be 0)
//             ^ indicates undefined value
//

	function Decoder(view, offset) {
		this.offset = offset || 0;
		this.view = view;
	}


	Decoder.prototype.map = function(length) {
		var value = {};
		for (var i = 0; i < length; i++) {
			var key = this.parse();
			value[key] = this.parse();
		}
		return value;
	};

	Decoder.prototype.bin = Decoder.prototype.buf = function(length) {
		var value = new ArrayBuffer(length);
		(new Uint8Array(value)).set(new Uint8Array(this.view.buffer, this.offset, length), 0);
		this.offset += length;
		return value;
	};

	Decoder.prototype.str = function(length) {
		var value = utf8Read(this.view, this.offset, length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.array = function(length) {
		var value = new Array(length);
		for (var i = 0; i < length; i++) {
			value[i] = this.parse();
		}
		return value;
	};

	Decoder.prototype.ext = function(length) {
		var value = {};
		// Get the type byte
		value['type'] = this.view.getInt8(this.offset);
		this.offset++;
		// Get the data array (length)
		value['data'] = this.buf(length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.parse = function() {
		var type = this.view.getUint8(this.offset);
		var value, length;

		// Positive FixInt - 0xxxxxxx
		if ((type & 0x80) === 0x00) {
			this.offset++;
			return type;
		}

		// FixMap - 1000xxxx
		if ((type & 0xf0) === 0x80) {
			length = type & 0x0f;
			this.offset++;
			return this.map(length);
		}

		// FixArray - 1001xxxx
		if ((type & 0xf0) === 0x90) {
			length = type & 0x0f;
			this.offset++;
			return this.array(length);
		}

		// FixStr - 101xxxxx
		if ((type & 0xe0) === 0xa0) {
			length = type & 0x1f;
			this.offset++;
			return this.str(length);
		}

		// Negative FixInt - 111xxxxx
		if ((type & 0xe0) === 0xe0) {
			value = this.view.getInt8(this.offset);
			this.offset++;
			return value;
		}

		switch (type) {

			// nil
			case 0xc0:
				this.offset++;
				return null;

			// 0xc1 never used - use for undefined (NON-STANDARD)
			case 0xc1:
				this.offset++;
				return undefined;

			// false
			case 0xc2:
				this.offset++;
				return false;

			// true
			case 0xc3:
				this.offset++;
				return true;

			// bin 8
			case 0xc4:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.bin(length);

			// bin 16
			case 0xc5:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.bin(length);

			// bin 32
			case 0xc6:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.bin(length);

			// ext 8
			case 0xc7:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.ext(length);

			// ext 16
			case 0xc8:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.ext(length);

			// ext 32
			case 0xc9:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.ext(length);

			// float 32
			case 0xca:
				value = this.view.getFloat32(this.offset + 1);
				this.offset += 5;
				return value;

			// float 64
			case 0xcb:
				value = this.view.getFloat64(this.offset + 1);
				this.offset += 9;
				return value;

			// uint8
			case 0xcc:
				value = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return value;

			// uint 16
			case 0xcd:
				value = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return value;

			// uint 32
			case 0xce:
				value = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return value;

			// uint 64
			case 0xcf:
				value = getUint64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// int 8
			case 0xd0:
				value = this.view.getInt8(this.offset + 1);
				this.offset += 2;
				return value;

			// int 16
			case 0xd1:
				value = this.view.getInt16(this.offset + 1);
				this.offset += 3;
				return value;

			// int 32
			case 0xd2:
				value = this.view.getInt32(this.offset + 1);
				this.offset += 5;
				return value;

			// int 64
			case 0xd3:
				value = getInt64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// fixext 1
			case 0xd4:
				length = 1;
				this.offset++;
				return this.ext(length);

			// fixext 2
			case 0xd5:
				length = 2;
				this.offset++;
				return this.ext(length);

			// fixext 4
			case 0xd6:
				length = 4;
				this.offset++;
				return this.ext(length);

			// fixext 8
			case 0xd7:
				length = 8;
				this.offset++;
				return this.ext(length);

			// fixext 16
			case 0xd8:
				length = 16;
				this.offset++;
				return this.ext(length);

			// str8
			case 0xd9:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.str(length);

			// str 16
			case 0xda:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.str(length);

			// str 32
			case 0xdb:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.str(length);

			// array 16
			case 0xdc:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.array(length);

			// array 32
			case 0xdd:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.array(length);

			// map 16
			case 0xde:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.map(length);

			// map 32
			case 0xdf:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.map(length);
		}
		throw new Error("Unknown type 0x" + type.toString(16));
	};

	function decode(buffer) {
		var view = new DataView(buffer);
		var decoder = new Decoder(view);
		var value = decoder.parse();
		if (decoder.offset !== buffer.byteLength)
			throw new Error((buffer.byteLength - decoder.offset) + " trailing bytes");
		return value;
	}

	function encodeableKeys(value, sparse) {
		var keys = []; // TODO: use Object.keys when we are able to transpile to ES3
		for (var key in value) {
			if (!value.hasOwnProperty(key)) continue;
			keys.push(key);
		}
		return keys.filter(function (e) {
			var val = value[e], type = typeof(val);
			return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);
		})
	}

	function encode(value, view, offset, sparse) {
		var type = typeof value;

		// Strings Bytes
		// There are four string types: fixstr/str8/str16/str32
		if (type === "string") {
			var length = utf8ByteCount(value);

			// fixstr
			if (length < 0x20) {
				view.setUint8(offset, length | 0xa0);
				utf8Write(view, offset + 1, value);
				return 1 + length;
			}

			// str8
			if (length < 0x100) {
				view.setUint8(offset, 0xd9);
				view.setUint8(offset + 1, length);
				utf8Write(view, offset + 2, value);
				return 2 + length;
			}

			// str16
			if (length < 0x10000) {
				view.setUint8(offset, 0xda);
				view.setUint16(offset + 1, length);
				utf8Write(view, offset + 3, value);
				return 3 + length;
			}
			// str32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xdb);
				view.setUint32(offset + 1, length);
				utf8Write(view, offset + 5, value);
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// There are three bin types: bin8/bin16/bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;

			// bin8
			if (length < 0x100) {
				view.setUint8(offset, 0xc4);
				view.setUint8(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 2);
				return 2 + length;
			}

			// bin16
			if (length < 0x10000) {
				view.setUint8(offset, 0xc5);
				view.setUint16(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 3);
				return 3 + length;
			}

			// bin 32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xc6);
				view.setUint32(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 5);
				return 5 + length;
			}
		}

		if (type === "number") {

			// Floating Point
			// NOTE: We're always using float64
			if (Math.floor(value) !== value) {
				view.setUint8(offset, 0xcb);
				view.setFloat64(offset + 1, value);
				return 9;
			}

			// Integers
			if (value >= 0) {
				// positive fixnum
				if (value < 0x80) {
					view.setUint8(offset, value);
					return 1;
				}
				// uint 8
				if (value < 0x100) {
					view.setUint8(offset, 0xcc);
					view.setUint8(offset + 1, value);
					return 2;
				}
				// uint 16
				if (value < 0x10000) {
					view.setUint8(offset, 0xcd);
					view.setUint16(offset + 1, value);
					return 3;
				}
				// uint 32
				if (value < 0x100000000) {
					view.setUint8(offset, 0xce);
					view.setUint32(offset + 1, value);
					return 5;
				}
				// uint 64
				if (value < 0x10000000000000000) {
					view.setUint8(offset, 0xcf);
					setUint64(view, offset + 1, value);
					return 9;
				}
				throw new Error("Number too big 0x" + value.toString(16));
			}

			// negative fixnum
			if (value >= -0x20) {
				view.setInt8(offset, value);
				return 1;
			}
			// int 8
			if (value >= -0x80) {
				view.setUint8(offset, 0xd0);
				view.setInt8(offset + 1, value);
				return 2;
			}
			// int 16
			if (value >= -0x8000) {
				view.setUint8(offset, 0xd1);
				view.setInt16(offset + 1, value);
				return 3;
			}
			// int 32
			if (value >= -0x80000000) {
				view.setUint8(offset, 0xd2);
				view.setInt32(offset + 1, value);
				return 5;
			}
			// int 64
			if (value >= -0x8000000000000000) {
				view.setUint8(offset, 0xd3);
				setInt64(view, offset + 1, value);
				return 9;
			}
			throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
		}

		// undefined - use d4 (NON-STANDARD)
		if (type === "undefined") {
			if(sparse) return 0;
			view.setUint8(offset, 0xd4);
			view.setUint8(offset + 1, 0x00);
			view.setUint8(offset + 2, 0x00);
			return 3;
		}

		// null
		if (value === null) {
			if(sparse) return 0;
			view.setUint8(offset, 0xc0);
			return 1;
		}

		// Boolean
		if (type === "boolean") {
			view.setUint8(offset, value ? 0xc3 : 0xc2);
			return 1;
		}

		if('function' === typeof value.toJSON)
			return encode(value.toJSON(), view, offset, sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			var isArray = Array.isArray(value);

			if (isArray) {
				length = value.length;
			} else {
				var keys = encodeableKeys(value, sparse);
				length = keys.length;
			}

			var size;
			if (length < 0x10) {
				view.setUint8(offset, length | ( isArray ? 0x90 : 0x80));
				size = 1;
			} else if (length < 0x10000) {
				view.setUint8(offset, isArray ? 0xdc : 0xde);
				view.setUint16(offset + 1, length);
				size = 3;
			} else if (length < 0x100000000) {
				view.setUint8(offset, isArray ? 0xdd : 0xdf);
				view.setUint32(offset + 1, length);
				size = 5;
			}

			if (isArray) {
				for (var i = 0; i < length; i++) {
					size += encode(value[i], view, offset + size, sparse);
				}
			} else {
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += encode(key, view, offset + size);
					size += encode(value[key], view, offset + size, sparse);
				}
			}

			return size;
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	function sizeof(value, sparse) {
		var type = typeof value;

		// fixstr or str8 or str16 or str32
		if (type === "string") {
			var length = utf8ByteCount(value);
			if (length < 0x20) {
				return 1 + length;
			}
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// bin8 or bin16 or bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if (type === "number") {
			// Floating Point (32 bits)
			// double
			if (Math.floor(value) !== value)
				return 9;

			// Integers
			if (value >= 0) {
				// positive fixint
				if (value < 0x80)
					return 1;
				// uint 8
				if (value < 0x100)
					return 2;
				// uint 16
				if (value < 0x10000)
					return 3;
				// uint 32
				if (value < 0x100000000)
					return 5;
				// uint 64
				if (value < 0x10000000000000000)
					return 9;
				// Too big
				throw new Error("Number too big 0x" + value.toString(16));
			}
			// negative fixint
			if (value >= -0x20)
				return 1;
			// int 8
			if (value >= -0x80)
				return 2;
			// int 16
			if (value >= -0x8000)
				return 3;
			// int 32
			if (value >= -0x80000000)
				return 5;
			// int 64
			if (value >= -0x8000000000000000)
				return 9;
			// Too small
			throw new Error("Number too small -0x" + value.toString(16).substr(1));
		}

		// Boolean
		if (type === "boolean") return 1;

		// undefined, null
		if (value === null) return sparse ? 0 : 1;
		if (value === undefined) return sparse ? 0 : 3;

		if('function' === typeof value.toJSON)
			return sizeof(value.toJSON(), sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			if (Array.isArray(value)) {
				length = value.length;
				for (var i = 0; i < length; i++) {
					size += sizeof(value[i], sparse);
				}
			} else {
				var keys = encodeableKeys(value, sparse)
				length = keys.length;
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += sizeof(key) + sizeof(value[key], sparse);
				}
			}
			if (length < 0x10) {
				return 1 + size;
			}
			if (length < 0x10000) {
				return 3 + size;
			}
			if (length < 0x100000000) {
				return 5 + size;
			}
			throw new Error("Array or object too long 0x" + length.toString(16));
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	return exports;
})();

/* harmony default export */ __webpack_exports__["a"] = (msgpack);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_224003__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_224003__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_224003__(1);
/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_224003__(34);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_224003__(5);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_224003__(3);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_224003__(7);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_224003__(26);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_224003__(0);
/* harmony import */ var _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_224003__(21);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_224003__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_224003__(2);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_224003__(14);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_224003__(6);
/* harmony import */ var _types_message__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_224003__(9);
/* harmony import */ var _util_multicaster__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_224003__(22);
/* harmony import */ var _util_errorreporter__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_224003__(23);
/* harmony import */ var platform_webstorage__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_224003__(16);
/* harmony import */ var platform_transports__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_224003__(41);
/* harmony import */ var _websockettransport__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_224003__(40);




















var ConnectionManager = (function() {
	var haveWebStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get);
	var haveSessionStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession);
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var PendingMessage = _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].PendingMessage;
	var noop = function() {};
	var transportPreferenceOrder = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].transportPreferenceOrder;
	var optimalTransport = transportPreferenceOrder[transportPreferenceOrder.length - 1];
	var transportPreferenceName = 'ably-transport-preference';

	var sessionRecoveryName = 'ably-connection-recovery';
	function getSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession(sessionRecoveryName);
	}
	function setSessionRecoverData(value) {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].setSession(sessionRecoveryName, value);
	}
	function clearSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].removeSession(sessionRecoveryName);
	}

	function betterTransportThan(a, b) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, a.shortName) >
		   _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, b.shortName);
	}

	function TransportParams(options, host, mode, connectionKey) {
		this.options = options;
		this.host = host;
		this.mode = mode;
		this.connectionKey = connectionKey;
		this.format = options.useBinaryProtocol ? 'msgpack' : 'json';

		this.connectionSerial = undefined;
		this.timeSerial = undefined;
	}

	TransportParams.prototype.getConnectParams = function(authParams) {
		var params = authParams ? _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].copy(authParams) : {};
		var options = this.options;
		switch(this.mode) {
			case 'upgrade':
				params.upgrade = this.connectionKey;
				break;
			case 'resume':
				params.resume = this.connectionKey;
				if(this.timeSerial !== undefined) {
					params.timeSerial = this.timeSerial;
				} else if(this.connectionSerial !== undefined) {
					params.connectionSerial = this.connectionSerial;
				}
				break;
			case 'recover':
				var match = options.recover.split(':');
				if(match) {
					params.recover = match[0];
					var recoverSerial = match[1];
					if(isNaN(recoverSerial)) {
						params.timeSerial = recoverSerial;
					} else {
						params.connectionSerial = recoverSerial;
					}
				}
				break;
			default:
		}
		if(options.clientId !== undefined) {
			params.clientId = options.clientId;
		}
		if(options.echoMessages === false) {
			params.echo = 'false';
		}
		if(this.format !== undefined) {
			params.format = this.format;
		}
		if(this.stream !== undefined) {
			params.stream = this.stream;
		}
		if(this.heartbeats !== undefined) {
			params.heartbeats = this.heartbeats;
		}
		params.v = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].apiVersion;
		params.lib = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].libstring;
		if(options.transportParams !== undefined) {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(params, options.transportParams);
		}
		return params;
	};

	TransportParams.prototype.toString = function() {
		var result = '[mode=' + this.mode;
		if(this.host) { result += (',host=' + this.host); }
		if(this.connectionKey) { result += (',connectionKey=' + this.connectionKey); }
		if(this.connectionSerial !== undefined) { result += (',connectionSerial=' + this.connectionSerial); }
		if(this.timeSerial) { result += (',timeSerial=' + this.timeSerial); }
		if(this.format) { result += (',format=' + this.format); }
		result += ']';

		return result;
	};

	/* public constructor */
	function ConnectionManager(realtime, options) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].call(this);
		this.realtime = realtime;
		this.options = options;
		var timeouts = options.timeouts;
		var self = this;
		/* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the
		 * preference transport, then realtimeRequestTimeout (~10s) to establish
		 * the base transport in case that fails */
		var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
		this.states = {
			initialized:   {state: 'initialized',   terminal: false, queueEvents: true,  sendEvents: false, failState: 'disconnected'},
			connecting:    {state: 'connecting',    terminal: false, queueEvents: true,  sendEvents: false, retryDelay: connectingTimeout, failState: 'disconnected'},
			connected:     {state: 'connected',     terminal: false, queueEvents: false, sendEvents: true,  failState: 'disconnected'},
			synchronizing: {state: 'connected',     terminal: false, queueEvents: true,  sendEvents: false, forceQueueEvents: true, failState: 'disconnected'},
			disconnected:  {state: 'disconnected',  terminal: false, queueEvents: true,  sendEvents: false, retryDelay: timeouts.disconnectedRetryTimeout, failState: 'disconnected'},
			suspended:     {state: 'suspended',     terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.suspendedRetryTimeout, failState: 'suspended'},
			closing:       {state: 'closing',       terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.realtimeRequestTimeout, failState: 'closed'},
			closed:        {state: 'closed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'closed'},
			failed:        {state: 'failed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'failed'}
		};
		this.state = this.states.initialized;
		this.errorReason = null;

		this.queuedMessages = new _messagequeue__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]();
		this.msgSerial = 0;
		this.connectionDetails = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.timeSerial = undefined;
		this.connectionSerial = undefined;
		this.connectionStateTtl = timeouts.connectionStateTtl;
		this.maxIdleInterval = null;

		this.transports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect((options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports), ConnectionManager.supportedTransports);
		/* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list
		* that's both requested and supported. Normally this will be xhr_polling;
		* if xhr isn't supported it will be jsonp. If the user has forced a
		* transport, it'll just be that one. */
		this.baseTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].baseTransportOrder, this.transports)[0];
		this.upgradeTransports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(this.transports, _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports);
		this.transportPreference = null;

		this.httpHosts = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHosts(options);
		this.activeProtocol = null;
		this.proposedTransports = [];
		this.pendingTransports = [];
		this.host = null;
		this.lastAutoReconnectAttempt = null;
		this.lastActivity = null;
		this.mostRecentMsg = null;
		this.forceFallbackHost = false;
		this.connectCounter = 0;

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'Realtime.ConnectionManager()', 'started');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports) + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + this.transports + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + this.httpHosts + ']');

		if(!this.transports.length) {
			var msg = 'no requested transports available';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'realtime.ConnectionManager()', msg);
			throw new Error(msg);
		}

		var addEventListener = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].addEventListener;
		if(addEventListener) {
			/* intercept close event in browser to persist connection id if requested */
			if(haveSessionStorage && typeof options.recover === 'function') {
				/* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */
				addEventListener('beforeunload', this.persistConnection.bind(this));
			}

			if(options.closeOnUnload === true) {
				addEventListener('beforeunload', function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR, 'Realtime.ConnectionManager()', 'beforeunload event has triggered the connection to close as closeOnUnload is true');
					self.requestState({state: 'closing'});
				});
			}

			/* Listen for online and offline events */
			addEventListener('online', function() {
				if(self.state == self.states.disconnected || self.state == self.states.suspended) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser online event', 'reattempting connection');
					self.requestState({state: 'connecting'});
				}
			});
			addEventListener('offline', function() {
				if(self.state == self.states.connected) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser offline event', 'disconnecting active transport');
					// Not sufficient to just go to the 'disconnected' state, want to
					// force all transports to reattempt the connection. Will immediately
					// retry.
					self.disconnectAllTransports();
				}
			});
		}
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(ConnectionManager, _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);

	/*********************
	 * transport management
	 *********************/

	ConnectionManager.supportedTransports = {};

	Object(_websockettransport__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(ConnectionManager);
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(platform_transports__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"], function (initFn) {
		initFn(ConnectionManager);
	});

	ConnectionManager.prototype.createTransportParams = function(host, mode) {
		var params = new TransportParams(this.options, host, mode, this.connectionKey);
		if(this.timeSerial) {
			params.timeSerial = this.timeSerial;
		} else if(this.connectionSerial !== undefined) {
			params.connectionSerial = this.connectionSerial;
		}
		return params;
	};

	ConnectionManager.prototype.getTransportParams = function(callback) {
		var self = this;

		function decideMode(modeCb) {
			if(self.connectionKey) {
				modeCb('resume');
				return;
			}

			if(typeof self.options.recover === 'string') {
				modeCb('recover');
				return;
			}

			var recoverFn = self.options.recover,
				lastSessionData = getSessionRecoverData();
			if(lastSessionData && typeof(recoverFn) === 'function') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');
				recoverFn(lastSessionData, function(shouldRecover) {
					if(shouldRecover) {
						self.options.recover = lastSessionData.recoveryKey;
						modeCb('recover');
					} else {
						modeCb('clean');
					}
				});
				return;
			}
			modeCb('clean');
		}

		decideMode(function(mode) {
			var transportParams = self.createTransportParams(null, mode);
			if(mode === 'recover') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = recover; recoveryKey = ' + self.options.recover);
				var match = self.options.recover.split(':');
				if(match && match[2]) {
					self.msgSerial = match[2];
				}
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport params = ' + transportParams.toString());
			}
			callback(transportParams);
		});
	};

	/**
	 * Attempt to connect using a given transport
	 * @param transportParams
	 * @param candidate, the transport to try
	 * @param callback
	 */
	ConnectionManager.prototype.tryATransport = function(transportParams, candidate, callback) {
		var self = this, host = transportParams.host;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);
		(ConnectionManager.supportedTransports[candidate]).tryConnect(this, this.realtime.auth, transportParams, function(wrappedErr, transport) {
			var state = self.state;
			if(state == self.states.closing || state == self.states.closed || state == self.states.failed) {
				if(transport) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);
					transport.close();
				}
				callback(true);
				return;
			}

			if(wrappedErr) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());

				/* Comet transport onconnect token errors can be dealt with here.
				* Websocket ones only happen after the transport claims to be viable,
				* so are dealt with as non-onconnect token errors */
				if(_client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(wrappedErr.error) && !(self.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(self.errorReason))) {
					self.errorReason = wrappedErr.error;
					/* re-get a token and try again */
					self.realtime.auth._forceNewToken(null, null, function(err) {
						if(err) {
							self.actOnErrorFromAuthorize(err);
							return;
						}
						self.tryATransport(transportParams, candidate, callback);
					});
				} else if(wrappedErr.event === 'failed') {
					/* Error that's fatal to the connection */
					self.notifyState({state: 'failed', error: wrappedErr.error});
					callback(true);
				} else if(wrappedErr.event === 'disconnected') {
					/* Error with that transport only */
					callback(false);
				}
				return;
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'viable transport ' + candidate + '; setting pending');
			self.setTransportPending(transport, transportParams);
			callback(null, transport);
		});
	};


	/**
	 * Called when a transport is indicated to be viable, and the connectionmanager
	 * expects to activate this transport as soon as it is connected.
	 * @param host
	 * @param transportParams
	 */
	ConnectionManager.prototype.setTransportPending = function(transport, transportParams) {
		var mode = transportParams.mode;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport);
		this.pendingTransports.push(transport);

		var self = this;
		transport.once('connected', function(error, connectionId, connectionDetails, connectionPosition) {
			if(mode == 'upgrade' && self.activeProtocol) {
				/*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */
				if(transport.shortName !== optimalTransport && _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(self.getUpgradePossibilities(), optimalTransport)) {
					setTimeout(function() {
						self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
					}, self.options.timeouts.parallelUpgradeDelay);
				} else {
					self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
				}
			} else {
				self.activateTransport(error, transport, connectionId, connectionDetails, connectionPosition);

				/* allow connectImpl to start the upgrade process if needed, but allow
				 * other event handlers, including activating the transport, to run first */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.connectImpl(transportParams);
				});
			}

			if(mode === 'recover' && self.options.recover) {
				/* After a successful recovery, we unpersist, as a recovery key cannot
				* be used more than once */
				self.options.recover = null;
				self.unpersistConnection();
			}
		});

		transport.on(['disconnected', 'closed', 'failed'], function(error) {
			self.deactivateTransport(transport, this.event, error);
		});

		this.emit('transport.pending', transport);
	};

	/**
	 * Called when an upgrade transport is connected,
	 * to schedule the activation of that transport.
	 * @param error
	 * @param transport
	 * @param connectionId
	 * @param connectionDetails
	 * @param connectedMessage
	 */
	ConnectionManager.prototype.scheduleTransportActivation = function(error, transport, connectionId, connectionDetails, upgradeConnectionPosition) {
		var self = this,
			currentTransport = this.activeProtocol && this.activeProtocol.getTransport(),
			abandon = function() {
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			};

		if(this.state !== this.states.connected && this.state !== this.states.connecting) {
			/* This is most likely to happen for the delayed xhrs, when xhrs and ws are scheduled in parallel*/
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + this.state.state + (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
			abandon();
			return;
		}

		if(currentTransport && !betterTransportThan(transport, currentTransport)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + ' is no better than current active transport ' + currentTransport.shortName + ' - abandoning upgrade');
			abandon();
			return;
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);

		this.realtime.channels.onceNopending(function(err) {
			var oldProtocol;
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unable to activate transport; transport = ' + transport + '; err = ' + err);
				return;
			}

			if(!transport.isConnected) {
				/* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');
				abandon();
				return;
			}

			if(self.state === self.states.connected) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');
				self.state = self.states.synchronizing;
				oldProtocol = self.activeProtocol;
			} else if(self.state !== self.states.connecting) {
				/* Note: upgrading from the connecting state is valid if the old active
				* transport was deactivated after the upgrade transport first connected;
				* see logic in deactivateTransport */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + self.state.state + (self.state === self.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
				abandon();
				return;
			}

			/* If the connectionId has changed, the upgrade hasn't worked. But as
			* it's still an upgrade, realtime still expects a sync - it just needs to
			* be a sync with the new connection position. (And it
			* needs to be set in the library, which is done by activateTransport). */
			var connectionReset = connectionId !== self.connectionId,
				syncPosition = connectionReset ? upgradeConnectionPosition : self;

			if(connectionReset) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Upgrade resulted in new connectionId; resetting library connection position from ' + (self.timeSerial || self.connectionSerial) + ' to ' + (syncPosition.timeSerial || syncPosition.connectionSerial) + '; upgrade error was ' + error);
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);
			self.sync(transport, syncPosition, function(syncErr, connectionId, postSyncPosition) {
				/* If there's been some problem with syncing (and the connection hasn't
				 * closed or something in the meantime), we have a problem -- we can't
				 * just fall back on the old transport, as we don't know whether
				 * realtime got the sync -- if it did, the old transport is no longer
				 * valid. To be safe, we disconnect both and start again from scratch. */
				if(syncErr) {
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unexpected error attempting to sync transport; transport = ' + transport + '; err = ' + syncErr);
						self.disconnectAllTransports();
					}
					return;
				}
				var finishUpgrade = function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);
					self.activateTransport(error, transport, connectionId, connectionDetails, postSyncPosition);
					/* Restore pre-sync state. If state has changed in the meantime,
					 * don't touch it -- since the websocket transport waits a tick before
					 * disposing itself, it's possible for it to have happily synced
					 * without err while, unknown to it, the connection has closed in the
					 * meantime and the ws transport is scheduled for death */
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);
						self.state = self.states.connected;
					} else {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + self.state.state + ', so leaving unchanged');
					}
					if(self.state.sendEvents) {
						self.sendQueuedMessages();
					}
				};

				/* Wait until sync is done and old transport is idle before activating new transport. This
				 * guarantees that messages arrive at realtime in the same order they are sent.
				 *
				 * If a message times out on the old transport, since it's still the active transport the
				 * message will be requeued. deactivateTransport will see the pending transport and notify
				 * the `connecting` state without starting a new connection, so the new transport can take
				 * over once deactivateTransport clears the old protocol's queue.
				 *
				 * If there is no old protocol, that meant that we weren't in the connected state at the
				 * beginning of the sync - likely the base transport died just before the sync. So can just
				 * finish the upgrade. If we're actually in closing/failed rather than connecting, that's
				 * fine, activatetransport will deal with that. */
				if(oldProtocol) {
				 /* Most of the time this will be already true: the new-transport sync will have given
				 * enough time for in-flight messages on the old transport to complete. */
					oldProtocol.onceIdle(finishUpgrade);
				} else {
					finishUpgrade();
				}
			});
		});
	};

	/**
	 * Called when a transport is connected, and the connectionmanager decides that
	 * it will now be the active transport. Returns whether or not it activated
	 * the transport (if the connection is closing/closed it will choose not to).
	 * @param transport the transport instance
	 * @param connectionId the id of the new active connection
	 * @param connectionDetails the details of the new active connection
	 * @param connectionPosition the position at the point activation; either {connectionSerial: <serial>} or {timeSerial: <serial>}
	 */
	ConnectionManager.prototype.activateTransport = function(error, transport, connectionId, connectionDetails, connectionPosition) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);
		if(error) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);
		}
		if(connectionId) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);
		}
		if(connectionDetails) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));
		}
		if(connectionPosition) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'serial =  ' + (connectionPosition.timeSerial || connectionPosition.connectionSerial));
		}

		this.persistTransportPreference(transport);

		/* if the connectionmanager moved to the closing/closed state before this
		 * connection event, then we won't activate this transport */
		var existingState = this.state,
			connectedState = this.states.connected.state;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);
		if(existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');
			transport.disconnect();
			return false;
		}

		/* remove this transport from pending transports */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);

		/* if the transport is not connected (eg because it failed during a
		 * scheduleTransportActivation#onceNoPending wait) then don't activate it */
		if(!transport.isConnected) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');
			return false;
		}

		/* the given transport is connected; this will immediately
		 * take over as the active transport */
		var existingActiveProtocol = this.activeProtocol;
		this.activeProtocol = new _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](transport);
		this.host = transport.params.host;

		var connectionKey = connectionDetails.connectionKey;
		if(connectionKey && this.connectionKey != connectionKey)  {
			this.setConnection(connectionId, connectionDetails, connectionPosition, !!error);
		}

		/* Rebroadcast any new connectionDetails from the active transport, which
		 * can come at any time (eg following a reauth), and emit an RTN24 UPDATE
		 * event. (Listener added on nextTick because we're in a transport.on('connected')
		 * callback at the moment; if we add it now we'll be adding it to the end
		 * of the listeners array and it'll be called immediately) */
		this.onConnectionDetailsUpdate(connectionDetails, transport);
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			transport.on('connected', function(connectedErr, _connectionId, connectionDetails) {
				self.onConnectionDetailsUpdate(connectionDetails, transport);
				self.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, connectedErr));
			});
		})

		/* If previously not connected, notify the state change (including any
		 * error). */
		if(existingState.state === this.states.connected.state) {
			if(error) {
				/* if upgrading without error, leave any existing errorReason alone */
				this.errorReason = this.realtime.connection.errorReason = error;
				/* Only bother emitting an upgrade if there's an error; otherwise it's
				 * just a transport upgrade, so auth details won't have changed */
				this.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, error));
			}
		} else {
			this.notifyState({state: 'connected', error: error});
			this.errorReason = this.realtime.connection.errorReason = error || null;
		}

		/* Send after the connection state update, as Channels hooks into this to
		 * resend attaches on a new transport if necessary */
		this.emit('transport.active', transport);

		/* Gracefully terminate existing protocol */
		if(existingActiveProtocol) {
			if(existingActiveProtocol.messageQueue.count() > 0) {
				/* We could just requeue pending messages on the new transport, but
				 * actually this should never happen: transports should only take over
				 * from other active transports when upgrading, and upgrading waits for
				 * the old transport to be idle. So log an error. */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' + existingActiveProtocol.transport.shortName + ', new one is ' + transport.shortName + ') finishing with ' + existingActiveProtocol.messageQueue.count() + ' messages still pending');
			}
			if(existingActiveProtocol.transport === transport) {
				var msg = 'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-previously-active');
			} else {
				existingActiveProtocol.finish();
			}
		}

		/* Terminate any other pending transport(s), and
		 * abort any not-yet-pending transport attempts */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(pendingTransport) {
			if(pendingTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a pending transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-pending');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			} else {
				pendingTransport.disconnect();
			}
		});
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(proposedTransport) {
			if(proposedTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a proposed transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-proposed');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.proposedTransports, transport);
			} else {
				proposedTransport.dispose();
			}
		});

		return true;
	};

	/**
	 * Called when a transport is no longer the active transport. This can occur
	 * in any transport connection state.
	 * @param transport
	 */
	ConnectionManager.prototype.deactivateTransport = function(transport, state, error) {
		var currentProtocol = this.activeProtocol,
			wasActive = currentProtocol && currentProtocol.getTransport() === transport,
			wasPending = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport),
			wasProposed = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport),
			noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' + state + (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') + (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));
		if(error && error.message)
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);

		if(wasActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' + this.activeProtocol.messageQueue.count() + ' pending messages');
			this.queuePendingMessages(currentProtocol.getPendingMessages());
			/* Clear any messages we requeue to allow the protocol to become idle.
			 * In case of an upgrade, this will trigger an immediate activation of
			 * the upgrade transport, so delay a tick so this transport can finish
			 * deactivating */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				currentProtocol.clearPendingMessages();
			});
			this.activeProtocol = this.host = null;
			clearTimeout(this.channelResumeCheckTimer);
		}

		this.emit('transport.inactive', transport);

		/* this transport state change is a state change for the connectionmanager if
		 * - the transport was the active transport and there are no transports
		 *   which are connected and scheduled for activation, just waiting for the
		 *   active transport to finish what its doing; or
		 * - the transport was the active transport and the error was fatal (so
		 *   unhealable by another transport); or
		 * - there is no active transport, and this is the last remaining
		 *   pending transport (so we were in the connecting state)
		 */
		if((wasActive && noTransportsScheduledForActivation) ||
			(wasActive && (state === 'failed') || (state === 'closed')) ||
			(currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {

			/* If we're disconnected with a 5xx we need to try fallback hosts
			 * (RTN14d), but (a) due to how the upgrade sequence works, the
			 * host/transport selection sequence only cares about getting to
			 * `preconnect` (eg establishing a websocket) getting a `disconnected`
			 * protocol message afterwards is too late; and (b) host retry only
			 * applies to connectBase unless the stored preference transport doesn't
			 * work. We solve this by unpersisting the transport preference and
			 * setting an instance variable to force fallback hosts to be used (if
			 * any) here. Bit of a kludge, but no real better alternatives without
			 * rewriting the entire thing */
			if(state === 'disconnected' && error && error.statusCode > 500 && this.httpHosts.length > 1) {
				this.unpersistTransportPreference();
				this.forceFallbackHost = true;
				/* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */
				this.notifyState({state: state, error: error, retryImmediately: true});
				return;
			}

			/* TODO remove below line once realtime sends token errors as DISCONNECTEDs */
			var newConnectionState = (state === 'failed' && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(error)) ? 'disconnected' : state;
			this.notifyState({state: newConnectionState, error: error});
			return;
		}

		if(wasActive && (state === 'disconnected') && (this.state !== this.states.synchronizing)) {
			/* If we were active but there is another transport scheduled for
			* activation, go into to the connecting state until that transport
			* activates and sets us back to connected. (manually starting the
			* transition timers in case that never happens). (If we were in the
			* synchronizing state, then that's fine, the old transport just got its
			* disconnected before the new one got the sync -- ignore it and keep
			* waiting for the sync. If it fails we have a separate sync timer that
			* will expire). */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');
			this.startSuspendTimer();
			this.startTransitionTimer(this.states.connecting);
			this.notifyState({state: 'connecting', error: error});
		}
	};

	/* Helper that returns true if there are no transports which are pending,
	* have been connected, and are just waiting for onceNoPending to fire before
	* being activated */
	ConnectionManager.prototype.noTransportsScheduledForActivation = function() {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isEmpty(this.pendingTransports) ||
			this.pendingTransports.every(function(transport) {
				return !transport.isConnected;
			});
	};

	/**
	 * Called when activating a new transport, to ensure message delivery
	 * on the new transport synchronises with the messages already received
	 */
	ConnectionManager.prototype.sync = function(transport, requestedSyncPosition, callback) {
		var timeout = setTimeout(function () {
			transport.off('sync');
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for sync response', 50000, 500));
		}, this.options.timeouts.realtimeRequestTimeout);

		/* send sync request */
		var syncMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
			action: actions.SYNC,
			connectionKey: this.connectionKey
		});

		if(requestedSyncPosition.timeSerial) {
			syncMessage.timeSerial = requestedSyncPosition.timeSerial;
		} else if(requestedSyncPosition.connectionSerial !== undefined) {
			syncMessage.connectionSerial = requestedSyncPosition.connectionSerial;
		}
		transport.send(syncMessage);

		transport.once('sync', function(connectionId, syncPosition) {
			clearTimeout(timeout);
			callback(null, connectionId, syncPosition);
		});
	};

	ConnectionManager.prototype.setConnection = function(connectionId, connectionDetails, connectionPosition, hasConnectionError) {
		/* if connectionKey changes but connectionId stays the same, then just a
		 * transport change on the same connection. If connectionId changes, we're
		 * on a new connection, with implications for msgSerial and channel state,
		 * and resetting the connectionSerial position */
		var self = this;
		/* If no previous connectionId, don't reset the msgSerial as it may have
		 * been set by recover data (unless the recover failed) */
		var prevConnId = this.connectionid,
			connIdChanged = prevConnId && (prevConnId !== connectionId),
			recoverFailure = !prevConnId && hasConnectionError;
		if(connIdChanged || recoverFailure)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');
			this.msgSerial = 0;
		}
		/* but do need to reattach channels, for channels that were previously in
		 * the attached state even though the connection mode was 'clean' due to a
		 * freshness check - see https://github.com/ably/ably-js/issues/394 */
		if(this.connectionId !== connectionId)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; reattaching any attached channels');
			/* Wait till next tick before reattaching channels, so that connection
			 * state will be updated and so that it will be applied after
			 * Channels#onTransportUpdate, else channels will not have an ATTACHED
			 * sent twice (once from this and once from that). */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				self.realtime.channels.reattach();
			});
		} else if(this.options.checkChannelsOnResume) {
			/* For attached channels, set the attached msg indicator variable to false,
			 * wait 30s, and check we got an attached for each one.
			 * 30s was chosen to be 5s longer than the transport idle timeout expire
			 * time, in an attempt to avoid false positives due to a transport
			 * silently failing immediately after a resume */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Same connectionId; checkChannelsOnResume is enabled');
			clearTimeout(this.channelResumeCheckTimer);
			this.realtime.channels.resetAttachedMsgIndicators();
			this.channelResumeCheckTimer = setTimeout(function() {
				self.realtime.channels.checkAttachedMsgIndicators(connectionId);
			}, 30000);
		}
		this.realtime.connection.id = this.connectionId = connectionId;
		this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
		var forceResetMessageSerial = connIdChanged || !prevConnId;
		this.setConnectionSerial(connectionPosition, forceResetMessageSerial);
	};

	ConnectionManager.prototype.clearConnection = function() {
		this.realtime.connection.id = this.connectionId = undefined;
		this.realtime.connection.key = this.connectionKey = undefined;
		this.clearConnectionSerial();
		this.msgSerial = 0;
		this.unpersistConnection();
	};

	/* force: set the connectionSerial even if it's less than the current
	 * connectionSerial. Used for new connections.
	 * Returns true iff the message was rejected as a duplicate. */
	ConnectionManager.prototype.setConnectionSerial = function(connectionPosition, force) {
		var timeSerial = connectionPosition.timeSerial,
			connectionSerial = connectionPosition.connectionSerial;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.setConnectionSerial()', 'Updating connection serial; serial = ' + connectionSerial + '; timeSerial = ' + timeSerial + '; force = ' + force + '; previous = ' + this.connectionSerial);
		if(timeSerial !== undefined) {
			if(timeSerial <= this.timeSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with timeSerial ' + timeSerial + ', but current timeSerial is ' + this.timeSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.timeSerial = this.timeSerial = timeSerial;
			this.setRecoveryKey();
			return;
		}
		if(connectionSerial !== undefined) {
			if(connectionSerial <= this.connectionSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with connectionSerial ' + connectionSerial + ', but current connectionSerial is ' + this.connectionSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.serial = this.connectionSerial = connectionSerial;
			this.setRecoveryKey();
		}
	};

	ConnectionManager.prototype.clearConnectionSerial = function() {
		this.realtime.connection.serial = this.connectionSerial = undefined;
		this.realtime.connection.timeSerial = this.timeSerial = undefined;
		this.clearRecoveryKey();
	};

	ConnectionManager.prototype.setRecoveryKey = function() {
		this.realtime.connection.recoveryKey = this.connectionKey + ':' + (this.timeSerial || this.connectionSerial) + ':' + this.msgSerial;
	};

	ConnectionManager.prototype.clearRecoveryKey = function() {
		this.realtime.connection.recoveryKey = null;
	};

	ConnectionManager.prototype.checkConnectionStateFreshness = function() {
		if(!this.lastActivity || !this.connectionId) { return; }

		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity;
		if(sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');
			this.clearConnection();
			this.states.connecting.failState = 'suspended';
			this.states.connecting.queueEvents = false;
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.persistConnection = function() {
		if(haveSessionStorage) {
			var recoveryKey = this.realtime.connection.recoveryKey;
			if(recoveryKey) {
				setSessionRecoverData({
					recoveryKey: recoveryKey,
					disconnectedAt: _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
					location: global.location,
					clientId: this.realtime.auth.clientId
				}, this.connectionStateTtl);
			}
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.unpersistConnection = function() {
		clearSessionRecoverData();
	};

	/*********************
	 * state management
	 *********************/

	ConnectionManager.prototype.getError = function() {
		return this.errorReason || this.getStateError();
	};

	ConnectionManager.prototype.getStateError = function() {
		return _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][this.state.state];
	};

	ConnectionManager.prototype.activeState = function() {
		return this.state.queueEvents || this.state.sendEvents;
	};

	ConnectionManager.prototype.enactStateChange = function(stateChange) {
		var logLevel = stateChange.current === 'failed' ? _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR : _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? ('; reason: ' + stateChange.reason) : ''));
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' + stateChange.current + '; reason = ' + (stateChange.reason && stateChange.reason.message));
		var newState = this.state = this.states[stateChange.current];
		if(stateChange.reason) {
			this.errorReason = stateChange.reason;
			this.realtime.connection.errorReason = stateChange.reason;
		}
		if(newState.terminal || newState.state === 'suspended') {
			/* suspended is nonterminal, but once in the suspended state, realtime
			 * will have discarded our connection state, so futher connection
			 * attempts should start from scratch */
			this.clearConnection();
		}
		this.emit('connectionstate', stateChange);
	};

	/****************************************
	 * ConnectionManager connection lifecycle
	 ****************************************/

	ConnectionManager.prototype.startTransitionTimer = function(transitionState) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);

		if(this.transitionTimer) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');
			clearTimeout(this.transitionTimer);
		}

		var self = this;
		this.transitionTimer = setTimeout(function() {
			if(self.transitionTimer) {
				self.transitionTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);
				self.notifyState({state: transitionState.failState});
			}
		}, transitionState.retryDelay);
	};

	ConnectionManager.prototype.cancelTransitionTimer = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');
		if(this.transitionTimer) {
			clearTimeout(this.transitionTimer);
			this.transitionTimer = null;
		}
	};

	ConnectionManager.prototype.startSuspendTimer = function() {
		var self = this;
		if(this.suspendTimer)
			return;
		this.suspendTimer = setTimeout(function() {
			if(self.suspendTimer) {
				self.suspendTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');
				self.states.connecting.failState = 'suspended';
				self.states.connecting.queueEvents = false;
				self.notifyState({state: 'suspended'});
			}
		}, this.connectionStateTtl);
	};

	ConnectionManager.prototype.checkSuspendTimer = function(state) {
		if(state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')
			this.cancelSuspendTimer();
	};

	ConnectionManager.prototype.cancelSuspendTimer = function() {
		this.states.connecting.failState = 'disconnected';
		this.states.connecting.queueEvents = true;
		if(this.suspendTimer) {
			clearTimeout(this.suspendTimer);
			this.suspendTimer = null;
		}
	};

	ConnectionManager.prototype.startRetryTimer = function(interval) {
		var self = this;
		this.retryTimer = setTimeout(function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');
			self.retryTimer = null;
			self.requestState({state: 'connecting'});
		}, interval);
	};

	ConnectionManager.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.retryTimer = null;
		}
	};

	ConnectionManager.prototype.notifyState = function(indicated) {
		var state = indicated.state,
			self = this;

		/* We retry immediately if:
		 * - something disconnects us while we're connected, or
		 * - a viable (but not yet active) transport fails due to a token error (so
		 *   this.errorReason will be set, and startConnect will do a forced
		 *   authorize). If this.errorReason is already set (to a token error),
		 *   then there has been at least one previous attempt to connect that also
		 *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait
		 *   before trying again */
		var retryImmediately = (state === 'disconnected' &&
			(this.state === this.states.connected     ||
			 this.state === this.states.synchronizing ||
			 indicated.retryImmediately               ||
				(this.state === this.states.connecting &&
					indicated.error && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(indicated.error) &&
					!(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)))));

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));
		/* do nothing if we're already in the indicated state */
		if(state == this.state.state)
			return;

		/* kill timers (possibly excepting suspend timer depending on the notified
		* state), as these are superseded by this notification */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		this.checkSuspendTimer(indicated.state);

		/* do nothing if we're unable to move from the current state */
		if(this.state.terminal)
			return;

		/* process new state */
		var newState = this.states[indicated.state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, newState.retryDelay, (indicated.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		if(retryImmediately) {
			var autoReconnect = function() {
				if(self.state === self.states.disconnected) {
					self.lastAutoReconnectAttempt = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
					self.requestState({state: 'connecting'});
				}
			};
			var sinceLast = this.lastAutoReconnectAttempt && (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastAutoReconnectAttempt + 1);
			if(sinceLast && (sinceLast < 1000)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' + sinceLast + 'ms ago, waiting another ' + (1000 - sinceLast) + 'ms before trying again');
				setTimeout(autoReconnect, 1000 - sinceLast);
			} else {
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(autoReconnect);
			}
		} else if(state === 'disconnected' || state === 'suspended') {
			this.startRetryTimer(newState.retryDelay);
		}

		 /* If going into disconnect/suspended (and not retrying immediately), or a
			* terminal state, ensure there are no orphaned transports hanging around. */
		if((state === 'disconnected' && !retryImmediately) ||
			 (state === 'suspended') ||
			 newState.terminal) {
				 /* Wait till the next tick so the connection state change is enacted,
				 * so aborting transports doesn't trigger redundant state changes */
				 _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					 self.disconnectAllTransports();
				 });
		 }

		if(state == 'connected' && !this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');
		}

		/* implement the change and notify */
		this.enactStateChange(change);
		if(this.state.sendEvents) {
			this.sendQueuedMessages();
		} else if(!this.state.queueEvents) {
			this.realtime.channels.propogateConnectionInterruption(state, change.reason);
			this.failQueuedMessages(change.reason); // RTN7c
		}
	};

	ConnectionManager.prototype.requestState = function(request) {
		var state = request.state, self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);
		if(state == this.state.state)
			return; /* silently do nothing */

		/* kill running timers, as this request supersedes them */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		/* for suspend timer check rather than cancel -- eg requesting a connecting
		* state should not reset the suspend timer */
		this.checkSuspendTimer(state);

		if(state == 'connecting' && this.state.state == 'connected') return;
		if(state == 'closing' && this.state.state == 'closed') return;

		var newState = this.states[state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, null, (request.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		this.enactStateChange(change);

		if(state == 'connecting') {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() { self.startConnect(); });
		}
		if(state == 'closing') {
			this.closeImpl();
		}
	};


	ConnectionManager.prototype.startConnect = function() {
		if(this.state !== this.states.connecting) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);
			return;
		}

		var auth = this.realtime.auth,
			self = this;

		/* The point of the connectCounter mechanism is to ensure that the
		 * connection procedure can be cancelled. We want disconnectAllTransports
		 * to be able to stop any in-progress connection, even before it gets to
		 * the stage of having a pending (or even a proposed) transport that it can
		 * dispose() of. So we check that it's still current after any async stage,
		 * up until the stage that is synchronous with instantiating a transport */
		var connectCount = ++this.connectCounter;

		var connect = function() {
			self.checkConnectionStateFreshness();
			self.getTransportParams(function(transportParams) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				self.connectImpl(transportParams, connectCount);
			});
		};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');
		this.startSuspendTimer();
		this.startTransitionTimer(this.states.connecting);

		if(auth.method === 'basic') {
			connect();
		} else {
			var authCb = function(err) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(err) {
					self.actOnErrorFromAuthorize(err);
				} else {
					connect();
				}
			};
			if(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)) {
				/* Force a refetch of a new token */
				auth._forceNewToken(null, null, authCb);
			} else {
				auth._ensureValidAuthCredentials(false, authCb);
			}
		}
	};

	/**
	 * There are three stages in connecting:
	 * - preference: if there is a cached transport preference, we try to connect
	 *   on that. If that fails or times out we abort the attempt, remove the
	 *   preference and fall back to base. If it succeeds, we try upgrading it if
	 *   needed (will only be in the case where the preference is xhrs and the
	 *   browser supports ws).
	 * - base: we try to connect with the best transport that we think will
	 *   never fail for this browser (usually this is xhr_polling; for very old
	 *   browsers will be jsonp, for node will be comet). If it doesn't work, we
	 *   try fallback hosts.
	 * - upgrade: given a connected transport, we see if there are any better
	 *   ones, and if so, try to upgrade to them.
	 *
	 * connectImpl works out what stage you're at (which is purely a function of
	 * the current connection state and whether there are any stored preferences),
	 * and dispatches accordingly. After a transport has been set pending,
	 * tryATransport calls connectImpl to see if there's another stage to be done.
	 * */
	ConnectionManager.prototype.connectImpl = function(transportParams, connectCount) {
		var state = this.state.state;

		if(state !== this.states.connecting.state && state !== this.states.connected.state) {
			/* Only keep trying as long as in the 'connecting' state (or 'connected'
			 * for upgrading). Any operation can put us into 'disconnected' to cancel
			 * connection attempts and wait before retrying, or 'failed' to fail. */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);
		} else if(this.pendingTransports.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');
		} else if(state == this.states.connected.state) {
			this.upgradeIfNeeded(transportParams);
		} else if(this.transports.length > 1 && this.getTransportPreference()) {
			this.connectPreference(transportParams);
		} else {
			this.connectBase(transportParams, connectCount);
		}
	};


	ConnectionManager.prototype.connectPreference = function(transportParams) {
		var preference = this.getTransportPreference(),
			self = this,
			preferenceTimeoutExpired = false;

		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.transports, preference)) {
			this.unpersistTransportPreference();
			this.connectImpl(transportParams);
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);

		var preferenceTimeout = setTimeout(function() {
			preferenceTimeoutExpired = true;
			if(!(self.state.state === self.states.connected.state)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');
				/* Abort all connection attempts. (This also disconnects the active
				 * protocol, but none exists if we're not in the connected state) */
				self.disconnectAllTransports();
				/* Be quite agressive about clearing the stored preference if ever it doesn't work */
				self.unpersistTransportPreference();
			}
			self.connectImpl(transportParams);
		}, this.options.timeouts.preferenceConnectTimeout);

		/* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.
		 * The wstransport it will substitute the httphost for an appropriate wshost */
		transportParams.host = self.httpHosts[0];
		self.tryATransport(transportParams, preference, function(fatal, transport) {
			clearTimeout(preferenceTimeout);
			if(preferenceTimeoutExpired && transport) {
				/* Viable, but too late - connectImpl() will already be trying
				* connectBase, and we weren't in upgrade mode. Just remove the
				* onconnected listener and get rid of it */
				transport.off();
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);
			} else if(!transport && !fatal) {
				/* Preference failed in a transport-specific way. Try more */
				self.unpersistTransportPreference();
				self.connectImpl(transportParams);
			}
			/* If suceeded, or failed fatally, nothing to do */
		});
	};


	/**
	 * Try to establish a transport on the base transport (the best transport
	 * such that if it doesn't work, nothing will work) as determined through
	 * static feature detection, checking for network connectivity and trying
	 * fallback hosts if applicable.
	 * @param transportParams
	 */
	ConnectionManager.prototype.connectBase = function(transportParams, connectCount) {
		var self = this,
			giveUp = function(err) {
				self.notifyState({state: self.states.connecting.failState, error: err});
			},
			candidateHosts = this.httpHosts.slice(),
			hostAttemptCb = function(fatal, transport) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(!transport && !fatal) {
					tryFallbackHosts();
				}
			};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);

		/* first try to establish a connection with the priority host with http transport */
		var host = candidateHosts.shift();
		if(!host) {
			giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (no available host)', 80003, 404));
			return;
		}
		transportParams.host = host;

		/* this is what we'll be doing if the attempt for the main host fails */
		function tryFallbackHosts() {
			/* if there aren't any fallback hosts, fail */
			if(!candidateHosts.length) {
				giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (and no more fallback hosts to try)', 80003, 404));
				return;
			}
			/* before trying any fallback (or any remaining fallback) we decide if
			 * there is a problem with the ably host, or there is a general connectivity
			 * problem */
			platform_http__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"].checkConnectivity(function(err, connectivity) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				/* we know err won't happen but handle it here anyway */
				if(err) {
					giveUp(err);
					return;
				}
				if(!connectivity) {
					/* the internet isn't reachable, so don't try the fallback hosts */
					giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (network unreachable)', 80003, 404));
					return;
				}
				/* the network is there, so there's a problem with the main host, or
				 * its dns. Try the fallback hosts. We could try them simultaneously but
				 * that would potentially cause a huge spike in load on the load balancer */
				transportParams.host = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrPopRandomElement(candidateHosts);
				self.tryATransport(transportParams, self.baseTransport, hostAttemptCb);
			});
		}

		if(this.forceFallbackHost && candidateHosts.length) {
			this.forceFallbackHost = false;
			tryFallbackHosts();
			return;
		}

		this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
	};


	ConnectionManager.prototype.getUpgradePossibilities = function() {
		/* returns the subset of upgradeTransports to the right of the current
		 * transport in upgradeTransports (if it's in there - if not, currentPosition
		 * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */
		var current = this.activeProtocol.getTransport().shortName;
		var currentPosition = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(this.upgradeTransports, current);
		return this.upgradeTransports.slice(currentPosition + 1);
	};


	ConnectionManager.prototype.upgradeIfNeeded = function(transportParams) {
		var upgradePossibilities = this.getUpgradePossibilities(),
			self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(upgradePossibilities));

		if(!upgradePossibilities.length) {
			return;
		}

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(upgradePossibilities, function(upgradeTransport) {
			/* Note: the transport may mutate the params, so give each transport a fresh one */
			var upgradeTransportParams = self.createTransportParams(transportParams.host, 'upgrade');
			self.tryATransport(upgradeTransportParams, upgradeTransport, noop);
		});
	};


	ConnectionManager.prototype.closeImpl = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');
		this.cancelSuspendTimer();
		this.startTransitionTimer(this.states.closing);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);
			if(transport) transport.close();
		});

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});

		if(this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().close();
		}

		/* If there was an active transport, this will probably be
		 * preempted by the notifyState call in deactivateTransport */
		this.notifyState({state: 'closed'});
	};

	ConnectionManager.prototype.onAuthUpdated = function(tokenDetails, callback) {
		var self = this;
		switch(this.state.state) {
			case 'connected':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');
				/* If there are any proposed/pending transports (eg an upgrade that
				 * isn't yet scheduled for activation) that hasn't yet started syncing,
				 * just to get rid of them & restart the upgrade with the new token, to
				 * avoid a race condition. (If it has started syncing, the AUTH will be
				 * queued until the upgrade is complete, so everything's fine) */
				if((this.pendingTransports.length || this.proposedTransports.length) &&
					self.state !== self.states.synchronizing) {
					this.disconnectAllTransports(/* exceptActive: */true);
					var transportParams = this.activeProtocol.getTransport().params;
					_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
						if(self.state.state === 'connected') {
							self.upgradeIfNeeded(transportParams);
						}
					});
				}

				/* Do any transport-specific new-token action */
				this.activeProtocol.getTransport().onAuthUpdated(tokenDetails);

				var authMsg = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
					action: actions.AUTH,
					auth: {
						accessToken: tokenDetails.token
					}
				});
				this.send(authMsg);

				/* The answer will come back as either a connectiondetails event
				 * (realtime sends a CONNECTED to asknowledge the reauth) or a
				 * statechange to failed */
				var successListener = function() {
					self.off(failureListener);
					callback(null, tokenDetails);
				};
				var failureListener = function(stateChange) {
					if(stateChange.current === 'failed') {
						self.off(successListener);
						self.off(failureListener);
						callback(stateChange.reason || self.getStateError());
					}
				};
				this.once('connectiondetails', successListener);
				this.on('connectionstate', failureListener);
				break;

			case 'connecting':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Aborting current connection attempts in order to start again with the new auth details');
				this.disconnectAllTransports();
				/* fallthrough to add statechange listener */

			default:
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Connection state is ' + this.state.state + '; waiting until either connected or failed');
				var listener = function(stateChange) {
					switch(stateChange.current) {
						case 'connected':
							self.off(listener);
							callback(null, tokenDetails);
							break;
						case 'failed':
						case 'closed':
						case 'suspended':
							self.off(listener);
							callback(stateChange.reason || self.getStateError());
							break;
						default:
							/* ignore till we get either connected or failed */
							break;
					}
				};
				self.on('connectionstate', listener);
				if(this.state.state === 'connecting') {
					/* can happen if in the connecting state but no transport was pending
					 * yet, so disconnectAllTransports did not trigger a disconnected state */
					self.startConnect();
				} else {
					self.requestState({state: 'connecting'});
				}
		}
	};

	ConnectionManager.prototype.disconnectAllTransports = function(exceptActive) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));

		/* This will prevent any connection procedure in an async part of one of its early stages from continuing */
		this.connectCounter++;

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);
			if(transport) transport.disconnect();
		});
		this.pendingTransports = [];

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});
		this.proposedTransports = [];

		if(this.activeProtocol && !exceptActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().disconnect();
		}
		/* No need to notify state disconnected; disconnecting the active transport
		 * will have that effect */
	};

	/******************
	 * event queueing
	 ******************/

	ConnectionManager.prototype.send = function(msg, queueEvent, callback) {
		callback = callback || noop;
		var state = this.state;

		if(state.sendEvents) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'sending event');
			this.sendImpl(new PendingMessage(msg, callback));
			return;
		}
		var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;
		if(!shouldQueue) {
			var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', err);
			callback(this.errorReason || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](err, 90000, 400));
			return;
		}
		if(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(msg));
		}
		this.queue(msg, callback);
	};

	ConnectionManager.prototype.sendImpl = function(pendingMessage) {
		var msg = pendingMessage.message;
		/* If have already attempted to send this, resend with the same msgSerial,
		 * so Ably can dedup if the previous send succeeded */
		if(pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
			msg.msgSerial = this.msgSerial++;
			this.setRecoveryKey();
		}
		try {
			this.activeProtocol.send(pendingMessage);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);
		}
	};

	function bundleWith(dest, src, maxSize) {
		var action;
		if(dest.channel !== src.channel) {
			/* RTL6d3 */
			return false;
		}
		if((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {
			/* RTL6d - can only bundle messages or presence */
			return false;
		}
		if(action !== src.action) {
			/* RTL6d4 */
			return false;
		}
		var kind = (action === actions.PRESENCE) ? 'presence' : 'messages',
			proposed = dest[kind].concat(src[kind]),
			size = _types_message__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].getMessagesSize(proposed);
		if(size > maxSize) {
			/* RTL6d1 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].allSame(proposed, 'clientId')) {
			/* RTL6d2 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrEvery(proposed, function(msg) {
			return !msg.id;
		})) {
			/* RTL6d7 */
			return false;
		}
		/* we're good to go! */
		dest[kind] = proposed;
		return true;
	};

	ConnectionManager.prototype.queue = function(msg, callback) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');
		var lastQueued = this.queuedMessages.last();
		var maxSize = this.options.maxMessageSize;
		/* If have already attempted to send a message, don't merge more messages
		 * into it, as if the previous send actually succeeded and realtime ignores
		 * the dup, they'll be lost */
		if(lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
			if(!lastQueued.merged) {
				lastQueued.callback = Object(_util_multicaster__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"])([lastQueued.callback]);
				lastQueued.merged = true;
			}
			lastQueued.callback.push(callback);
		} else {
			this.queuedMessages.push(new PendingMessage(msg, callback));
		}
	};

	ConnectionManager.prototype.sendQueuedMessages = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');
		var pendingMessage;
		while(pendingMessage = this.queuedMessages.shift())
			this.sendImpl(pendingMessage);
	};

	ConnectionManager.prototype.queuePendingMessages = function(pendingMessages) {
		if(pendingMessages && pendingMessages.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');
			this.queuedMessages.prepend(pendingMessages);
		}
	};

	ConnectionManager.prototype.failQueuedMessages = function(err) {
		var numQueued = this.queuedMessages.count();
		if(numQueued > 0) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.failQueuedMessages()', 'failing ' + numQueued + ' queued messages, err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
			this.queuedMessages.completeAllMessages(err);
		}
	};

	ConnectionManager.prototype.onChannelMessage = function(message, transport) {
		var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(),
			onUpgradeTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing,
			notControlMsg = message.action === actions.MESSAGE || message.action === actions.PRESENCE;

		/* As the lib now has a period where the upgrade transport is synced but
		 * before it's become active (while waiting for the old one to become
		 * idle), message can validly arrive on it even though it isn't active */
		if(onActiveTransport || onUpgradeTransport) {
			if(notControlMsg) {
				var suppressed = this.setConnectionSerial(message);
				if(suppressed) {
					return;
				}
				if(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isDuplicate(message, this.mostRecentMsg)) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onChannelMessage()', 'received message with different connectionSerial, but same message id as a previous; discarding; id = ' + message.id);
					return;
				}
				this.mostRecentMsg = message;
			}
			this.realtime.channels.onChannelMessage(message);
		} else {
			// Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding
			// messages,  no new messages (as sync has been sent on new transport so new messages will
			// be resent there, or connection has been closed so don't want new messages)
			if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
				this.realtime.channels.onChannelMessage(message);
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');
			}
		}
	};

	ConnectionManager.prototype.ping = function(transport, callback) {
		/* if transport is specified, try that */
		if(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);

			var onTimeout = function () {
				transport.off('heartbeat', onHeartbeat);
				callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for heartbeat response', 50000, 500));
			};

			var pingStart = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
				id = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].cheapRandStr();

			var onHeartbeat = function (responseId) {
				if(responseId === id) {
					transport.off('heartbeat', onHeartbeat);
					clearTimeout(timer);
					var responseTime = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - pingStart;
					callback(null, responseTime);
				}
			};

			var timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);

			transport.on('heartbeat', onHeartbeat);
			transport.ping(id);
			return;
		}

		/* if we're not connected, don't attempt */
		if(this.state.state !== 'connected') {
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to ping service; not connected', 40000, 400));
			return;
		}

		/* no transport was specified, so use the current (connected) one
		 * but ensure that we retry if the transport is superseded before we complete */
		var completed = false, self = this;

		var onPingComplete = function(err, responseTime) {
			self.off('transport.active', onTransportActive);
			if(!completed) {
				completed = true;
				callback(err, responseTime);
			}
		};

		var onTransportActive = function() {
			if(!completed) {
				/* ensure that no callback happens for the currently outstanding operation */
				completed = true;
				/* repeat but picking up the new transport */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.ping(null, callback);
				});
			}
		};

		this.on('transport.active', onTransportActive);
		this.ping(this.activeProtocol.getTransport(), onPingComplete);
	};

	ConnectionManager.prototype.abort = function(error) {
		this.activeProtocol.getTransport().fail(error);
	};

	ConnectionManager.prototype.registerProposedTransport = function(transport) {
		this.proposedTransports.push(transport);
	};

	ConnectionManager.prototype.getTransportPreference = function() {
		return this.transportPreference || (haveWebStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get(transportPreferenceName));
	};

	ConnectionManager.prototype.persistTransportPreference = function(transport) {
		if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports, transport.shortName)) {
			this.transportPreference = transport.shortName;
			if(haveWebStorage) {
				platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].set(transportPreferenceName, transport.shortName);
			}
		}
	};

	ConnectionManager.prototype.unpersistTransportPreference = function() {
		this.transportPreference = null;
		if(haveWebStorage) {
			platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].remove(transportPreferenceName);
		}
	};

	/* This method is only used during connection attempts, so implements RSA4c1,
	 * RSA4c2, and RSA4d. In particular it is not invoked for
	 * serverside-triggered reauths or manual reauths, so RSA4c3 does not apply */
	ConnectionManager.prototype.actOnErrorFromAuthorize = function(err) {
		if(err.code === 40171) {
			/* No way to reauth */
			this.notifyState({state: 'failed', error: err});
		} else if(err.statusCode === 403) {
			var msg = 'Client configured authentication provider returned 403; failing the connection';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);
			this.notifyState({state: 'failed', error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 403, err)});
		} else {
			var msg = 'Client configured authentication provider request failed';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);
			this.notifyState({state: this.state.failState, error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 401, err)});
		}
	};

	ConnectionManager.prototype.onConnectionDetailsUpdate = function(connectionDetails, transport) {
		if(!connectionDetails) {
			return;
		}
		this.connectionDetails = connectionDetails;
		if(connectionDetails.maxMessageSize) {
			this.options.maxMessageSize = connectionDetails.maxMessageSize;
		}
		var clientId = connectionDetails.clientId;
		if(clientId) {
			var err = this.realtime.auth._uncheckedSetClientId(clientId);
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);
				/* Errors setting the clientId are fatal to the connection */
				transport.fail(err);
				return;
			}
		}
		var connectionStateTtl = connectionDetails.connectionStateTtl;
		if(connectionStateTtl) {
			this.connectionStateTtl = connectionStateTtl;
		}
		this.maxIdleInterval = connectionDetails.maxIdleInterval;
		this.emit('connectiondetails', connectionDetails);
	};

	return ConnectionManager;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionManager);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_224003__(20)))

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_320182__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_320182__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_320182__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_320182__(0);




var MessageQueue = (function() {
	function MessageQueue() {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		this.messages = [];
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(MessageQueue, _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	MessageQueue.prototype.count = function() {
		return this.messages.length;
	};

	MessageQueue.prototype.push = function(message) {
		this.messages.push(message);
	};

	MessageQueue.prototype.shift = function() {
		return this.messages.shift();
	};

	MessageQueue.prototype.last = function() {
		return this.messages[this.messages.length - 1];
	};

	MessageQueue.prototype.copyAll = function() {
		return this.messages.slice();
	};

	MessageQueue.prototype.append = function(messages) {
		this.messages.push.apply(this.messages, messages);
	};

	MessageQueue.prototype.prepend = function(messages) {
		this.messages.unshift.apply(this.messages, messages);
	};

	MessageQueue.prototype.completeMessages = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);
		err = err || null;
		var messages = this.messages;
		var first = messages[0];
		if(first) {
			var startSerial = first.message.msgSerial;
			var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */
			if(endSerial > startSerial) {
				var completeMessages = messages.splice(0, (endSerial - startSerial));
				for(var i = 0; i < completeMessages.length; i++) {
					completeMessages[i].callback(err);
				}
			}
			if(messages.length == 0)
				this.emit('idle');
		}
	};

	MessageQueue.prototype.completeAllMessages = function(err) {
		this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
	};

	MessageQueue.prototype.clear = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');
		this.messages = [];
		this.emit('idle');
	};

	return MessageQueue;
})();

/* harmony default export */ __webpack_exports__["a"] = (MessageQueue);


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_322939__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_322939__(1);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_322939__(7);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_322939__(3);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_322939__(2);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_322939__(6);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_322939__(0);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_322939__(5);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_322939__(4);
/* harmony import */ var _util_domevent__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_322939__(35);










var XHRRequest = (function() {
	var noop = function() {};
	var idCounter = 0;
	var pendingRequests = {};

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	function clearPendingRequests() {
		for(var id in pendingRequests)
			pendingRequests[id].dispose();
	}

	var isIE = typeof global !== 'undefined' && global.XDomainRequest;

	function ieVersion() {
		var match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
		return match && Number(match[1]);
	}

	function needJsonEnvelope() {
		/* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */
		var version;
		return isIE && (version = ieVersion()) && version === 10;
	}

	function getHeader(xhr, header) {
		return xhr.getResponseHeader && xhr.getResponseHeader(header);
	}

	/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact
	 * it is 'chunked'. So instead, decide that it is chunked when
	 * transfer-encoding is present or content-length is absent.  ('or' because
	 * when using http2 streaming, there's no transfer-encoding header, but can
	 * still deduce streaming from lack of content-length) */
	function isEncodingChunked(xhr) {
		return xhr.getResponseHeader
			&& (xhr.getResponseHeader('transfer-encoding')
			|| !xhr.getResponseHeader('content-length'));
	}

	function getHeadersAsObject(xhr) {
		var headerPairs = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim(xhr.getAllResponseHeaders()).split('\r\n'),
			headers = {};
		for (var i = 0; i < headerPairs.length; i++) {
			var parts = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrMap(headerPairs[i].split(':'), _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim);
			headers[parts[0].toLowerCase()] = parts[1];
		}
		return headers;
	}

	function XHRRequest(uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		params = params || {};
		params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(needJsonEnvelope() && !params.envelope)
			params.envelope = 'json';
		this.uri = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		this.headers = headers || {};
		this.body = body;
		this.method = method ? method.toUpperCase() : (_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(body) ? 'GET' : 'POST');
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.timedOut = false;
		this.requestComplete = false;
		pendingRequests[this.id = String(++idCounter)] = this;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(XHRRequest, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	var createRequest = XHRRequest.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* XHR requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new XHRRequest(uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	XHRRequest.prototype.complete = function(err, body, headers, unpacked, statusCode) {
		if(!this.requestComplete) {
			this.requestComplete = true;
			if(!err && body) {
				this.emit('data', body);
			}
			this.emit('complete', err, body, headers, unpacked, statusCode);
			this.dispose();
		}
	};

	XHRRequest.prototype.abort = function() {
		this.dispose();
	};

	XHRRequest.prototype.exec = function() {
		var timeout = (this.requestMode == REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,
			self = this,
			timer = this.timer = setTimeout(function() {
				self.timedOut = true;
				xhr.abort();
			}, timeout),
			body = this.body,
			method = this.method,
			headers = this.headers,
			xhr = this.xhr = new XMLHttpRequest(),
			accept = headers['accept'],
			responseType = 'text';

		if(!accept) {
			headers['accept'] = 'application/json';
		} else if(accept.indexOf('application/x-msgpack') === 0) {
			responseType = 'arraybuffer';
		}

		if(body) {
			var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');
			if(contentType.indexOf('application/json') > -1 && typeof(body) != 'string')
				body = JSON.stringify(body);
		}

		xhr.open(method, this.uri, true);
		xhr.responseType = responseType;

		if ('authorization' in headers) {
			xhr.withCredentials = true;
		}

		for(var h in headers)
			xhr.setRequestHeader(h, headers[h]);

		var errorHandler = function(errorEvent, message, code, statusCode) {
			var errorMessage = message + ' (event type: ' + errorEvent.type + ')' + (self.xhr.statusText ? ', current statusText is ' + self.xhr.statusText : '');
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"](errorMessage, code, statusCode));
		};
		xhr.onerror = function(errorEvent) {
			errorHandler(errorEvent, 'XHR error occurred', null, 400);
		}
		xhr.onabort = function(errorEvent) {
			if(self.timedOut) {
				errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);
			} else {
				errorHandler(errorEvent, 'Request cancelled', null, 400);
			}
		};
		xhr.ontimeout = function(errorEvent) {
			errorHandler(errorEvent, 'Request timed out', null, 408);
		};

		var streaming,
			statusCode,
			responseBody,
			contentType,
			successResponse,
			streamPos = 0,
			unpacked = false;

		function onResponse() {
			clearTimeout(timer);
			successResponse = (statusCode < 400);
			if(statusCode == 204) {
				self.complete(null, null, null, null, statusCode);
				return;
			}
			streaming = (self.requestMode == REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr));
		}

		function onEnd() {
			try {
				var contentType = getHeader(xhr, 'content-type'),
					headers,
					responseBody,
					/* Be liberal in what we accept; buggy auth servers may respond
					 * without the correct contenttype, but assume they're still
					 * responding with json */
					json = contentType ? (contentType.indexOf('application/json') >= 0) : (xhr.responseType == 'text');

				if(json) {
					/* If we requested msgpack but server responded with json, then since
					 * we set the responseType expecting msgpack, the response will be
					 * an ArrayBuffer containing json */
					responseBody = (xhr.responseType === 'arraybuffer') ? platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].utf8Decode(xhr.response) : String(xhr.responseText);
					if(responseBody.length) {
						responseBody = JSON.parse(responseBody);
					}
					unpacked = true;
				} else {
					responseBody = xhr.response;
				}

				if(responseBody.response !== undefined) {
					/* unwrap JSON envelope */
					statusCode = responseBody.statusCode;
					successResponse = (statusCode < 400);
					headers = responseBody.headers;
					responseBody = responseBody.response;
				} else {
					headers = getHeadersAsObject(xhr);
				}
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}

			/* If response is an array, it's an array of protocol messages -- even if
			 * is contains an error action (hence the nonsuccess statuscode), we can
			 * consider the request to have succeeded, just pass it on to
			 * onProtocolMessage to decide what to do */
			if(successResponse || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(responseBody)) {
				self.complete(null, responseBody, headers, unpacked, statusCode);
				return;
			}

			var err = responseBody.error && _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(responseBody.error);
			if(!err) {
				err = new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Error response received from server: ' + statusCode + ' body was: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(responseBody), null, statusCode);
			}
			self.complete(err, responseBody, headers, unpacked, statusCode);
		}

		function onProgress() {
			responseBody = xhr.responseText;
			var bodyEnd = responseBody.length - 1, idx, chunk;
			while((streamPos < bodyEnd) && (idx = responseBody.indexOf('\n', streamPos)) > -1) {
				chunk = responseBody.slice(streamPos, idx);
				streamPos = idx + 1;
				onChunk(chunk);
			}
		}

		function onChunk(chunk) {
			try {
				chunk = JSON.parse(chunk);
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}
			self.emit('data', chunk);
		}

		function onStreamEnd() {
			onProgress();
			self.streamComplete = true;
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.complete();
			});
		}

		xhr.onreadystatechange = function() {
			var readyState = xhr.readyState;
			if(readyState < 3) return;
			if(xhr.status !== 0) {
				if(statusCode === undefined) {
					statusCode = xhr.status;
					/* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
					if(statusCode === 1223) statusCode = 204;
					onResponse();
				}
				if(readyState == 3 && streaming) {
					onProgress();
				} else if(readyState == 4) {
					if(streaming)
						onStreamEnd();
					else
						onEnd();
				}
			}
		};
		xhr.send(body);
	};

	XHRRequest.prototype.dispose = function() {
		var xhr = this.xhr;
		if(xhr) {
			xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
			this.xhr = null;
			var timer = this.timer;
			if(timer) {
				clearTimeout(timer);
				this.timer = null;
			}
			if(!this.requestComplete)
				xhr.abort();
		}
		delete pendingRequests[this.id];
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].xhrSupported) {
		if(typeof _util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"] === 'object') {
			_util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].addUnloadListener(clearPendingRequests);
		}
		if(typeof(platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]) !== 'undefined') {
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].supportsAuthHeaders = true;
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
				var req = createRequest(uri, headers, params, body, REQ_SEND, rest && rest.options.timeouts, method);
				req.once('complete', callback);
				req.exec();
				return req;
			};

			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
				var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].internetUpUrl;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + upUrl);
				platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getUri(null, upUrl, null, null, function(err, responseText) {
					var result = (!err && responseText.replace(/\n/, '') == 'yes');
					_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);
					callback(null, result);
				});
			};
		}
	}

	return XHRRequest;
})();

/* harmony default export */ __webpack_exports__["a"] = (XHRRequest);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_322939__(20)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __nested_webpack_require_336327__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_336327__(12), __nested_webpack_require_336327__(10), __nested_webpack_require_336327__(43), __nested_webpack_require_336327__(17), __nested_webpack_require_336327__(37), __nested_webpack_require_336327__(36), __nested_webpack_require_336327__(29), __nested_webpack_require_336327__(30), __nested_webpack_require_336327__(31), __nested_webpack_require_336327__(44), __nested_webpack_require_336327__(45));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_336840__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_336840__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_340736__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_340736__(12), __nested_webpack_require_340736__(37), __nested_webpack_require_340736__(29));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_344626__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_344626__(12), __nested_webpack_require_344626__(30));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_374173__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_374173__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_374444__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_374444__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_374728__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_374728__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_374728__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_374728__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_374728__(0);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_374728__(26);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_374728__(2);







var Protocol = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;

	function Protocol(transport) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.transport = transport;
		this.messageQueue = new _messagequeue__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]();
		var self = this;
		transport.on('ack', function(serial, count) { self.onAck(serial, count); });
		transport.on('nack', function(serial, count, err) { self.onNack(serial, count, err); });
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Protocol, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Protocol.prototype.onAck = function(serial, count) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);
		this.messageQueue.completeMessages(serial, count);
	};

	Protocol.prototype.onNack = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		if(!err) {
			err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Unable to send message; channel not responding', 50001, 500);
		}
		this.messageQueue.completeMessages(serial, count, err);
	};

	Protocol.prototype.onceIdle = function(listener) {
		var messageQueue = this.messageQueue;
		if(messageQueue.count() === 0) {
			listener();
			return;
		}
		messageQueue.once('idle', listener);
	};

	Protocol.prototype.send = function(pendingMessage) {
		if(pendingMessage.ackRequired) {
			this.messageQueue.push(pendingMessage);
		}
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.send()', 'sending msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(pendingMessage.message));
		}
		pendingMessage.sendAttempted = true;
		this.transport.send(pendingMessage.message);
	};

	Protocol.prototype.getTransport = function() {
		return this.transport;
	};

	Protocol.prototype.getPendingMessages = function() {
		return this.messageQueue.copyAll();
	};

	Protocol.prototype.clearPendingMessages = function() {
		return this.messageQueue.clear();
	};

	Protocol.prototype.finish = function() {
		var transport = this.transport;
		this.onceIdle(function() {
			transport.disconnect();
		});
	};

	function PendingMessage(message, callback) {
		this.message = message;
		this.callback = callback;
		this.merged = false;
		var action = message.action;
		this.sendAttempted = false;
		this.ackRequired = (action == actions.MESSAGE || action == actions.PRESENCE);
	}
	Protocol.PendingMessage = PendingMessage;

	return Protocol;
})();

/* harmony default export */ __webpack_exports__["a"] = (Protocol);


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_378720__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var DomEvent = (function() {
	function DomEvent() {}

	DomEvent.addListener = function(target, event, listener) {
		if(target.addEventListener) {
			target.addEventListener(event, listener, false);
		} else {
			target.attachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.removeListener = function(target, event, listener) {
		if(target.removeEventListener) {
			target.removeEventListener(event, listener, false);
		} else {
			target.detachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.addMessageListener = function(target, listener) {
		DomEvent.addListener(target, 'message', listener);
	};

	DomEvent.removeMessageListener = function(target, listener) {
		DomEvent.removeListener(target, 'message', listener);
	};

	DomEvent.addUnloadListener = function(listener) {
		DomEvent.addListener(global, 'unload', listener);
	};

	return DomEvent;
})();

/* harmony default export */ __webpack_exports__["a"] = (DomEvent);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_378720__(20)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __nested_webpack_require_379930__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_379930__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 37 */
/***/ (function(module, exports, __nested_webpack_require_385380__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_385380__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_389355__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_389355__(12), __nested_webpack_require_389355__(36), __nested_webpack_require_389355__(29));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_389691__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_389691__(1);
/* harmony import */ var _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_389691__(15);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_389691__(3);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_389691__(7);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_389691__(6);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_389691__(2);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_389691__(5);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_389691__(0);









var JSONPTransport = function(connectionManager) {
	var noop = function() {};
	/* Can't just use window.Ably, as that won't exist if using the commonjs version. */
	var _ = global._ablyjs_jsonp = {};

	/* express strips out parantheses from the callback!
	 * Kludge to still alow its responses to work, while not keeping the
	 * function form for normal use and not cluttering window.Ably
	 * https://github.com/expressjs/express/blob/5b4d4b4ab1324743534fbcd4709f4e75bb4b4e9d/lib/response.js#L305
	 */
	_._ = function(id) { return _['_' + id] || noop; };
	var idCounter = 1;
	var head = null;
	var shortName = 'jsonp';

	/* public constructor */
	function JSONPTransport(connectionManager, auth, params) {
		params.stream = false;
		_common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(JSONPTransport, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	JSONPTransport.isAvailable = function() {
		return platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].allowComet;
	};
	if(JSONPTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = JSONPTransport;
	}
	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported) {
		head = document.getElementsByTagName('head')[0];
	}

	/* connectivity check; since this has a hard-coded callback id,
	 * we just make sure that we handle concurrent requests (but the
	 * connectionmanager should ensure this doesn't happen anyway */
	var checksInProgress = null;
	global.JSONPTransport = JSONPTransport

	JSONPTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new JSONPTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'JSONPTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	JSONPTransport.prototype.toString = function() {
		return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	var createRequest = JSONPTransport.prototype.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* JSONP requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = (this && this.timeouts) || timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new Request(undefined, uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	function Request(id, uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].call(this);
		if(id === undefined) id = idCounter++;
		this.id = id;
		this.uri = uri;
		this.params = params || {};
		this.params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(headers) {
			/* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */
			if(headers['X-Ably-Version']) this.params.v = headers['X-Ably-Version'];
			if(headers['X-Ably-Lib']) this.params.lib = headers['X-Ably-Lib'];
		}
		this.body = body;
		this.method = method;
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.requestComplete = false;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(Request, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]);

	Request.prototype.exec = function() {
		var id = this.id,
			body = this.body,
			method = this.method,
			uri = this.uri,
			params = this.params,
			self = this;

		params.callback = '_ablyjs_jsonp._(' + id + ')';

		params.envelope = 'jsonp';
		if(body) {
			params.body = body;
		}
		if(method && method !== 'get') {
			params.method = method;
		}

		var script = this.script = document.createElement('script');
		var src = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		script.src = src;
		if(script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {
			/* The src has been truncated. Can't abort, but can at least emit an
			 * error so the user knows what's gone wrong. (Can't compare strings
			 * directly as src may have a port, script.src won't) */
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');
		}
		script.async = true;
		script.type = 'text/javascript';
		script.charset = 'UTF-8';
		script.onerror = function(err) {
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('JSONP script error (event: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(err) + ')', null, 400));
		};

		_['_' + id] = function(message) {
			if(message.statusCode) {
				/* Handle as enveloped jsonp, as all jsonp transport uses should be */
				var response = message.response;
				if(message.statusCode == 204) {
					self.complete(null, null, null, message.statusCode);
				} else if(!response) {
					self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Invalid server response: no envelope detected', null, 500));
				} else if(message.statusCode < 400 || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(response)) {
					/* If response is an array, it's an array of protocol messages -- even if
					 * it contains an error action (hence the nonsuccess statuscode), we can
					 * consider the request to have succeeded, just pass it on to
					 * onProtocolMessage to decide what to do */
					self.complete(null, response, message.headers, message.statusCode);
				} else {
					var err = response.error || new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Error response received from server', null, message.statusCode);
					self.complete(err);
				}
			} else {
				/* Handle as non-enveloped -- as will be eg from a customer's authUrl server */
				self.complete(null, message);
			}
		};

		var timeout = (this.requestMode == _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;
		this.timer = setTimeout(function() { self.abort(); }, timeout);
		head.insertBefore(script, head.firstChild);
	};

	Request.prototype.complete = function(err, body, headers, statusCode) {
		headers = headers || {};
		if(!this.requestComplete) {
			this.requestComplete = true;
			var contentType;
			if(body) {
				contentType = (typeof(body) == 'string') ? 'text/plain' : 'application/json';
				headers['content-type'] = contentType;
				this.emit('data', body);
			}

			this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);
			this.dispose();
		}
	};

	Request.prototype.abort = function() {
		this.dispose();
	};

	Request.prototype.dispose = function() {
		var timer = this.timer;
		if(timer) {
			clearTimeout(timer);
			this.timer = null;
		}
		var script = this.script;
		if(script.parentNode) script.parentNode.removeChild(script);
		delete _[this.id];
		this.emit('disposed');
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && !platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request) {
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
			var req = createRequest(uri, headers, params, body, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, rest && rest.options.timeouts, method);
			req.once('complete', callback);
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
			return req;
		};

		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
			var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].jsonpInternetUpUrl;

			if(checksInProgress) {
				checksInProgress.push(callback);
				return;
			}
			checksInProgress = [callback];
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);

			var req = new Request('isTheInternetUp', upUrl, null, null, null, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS);
			req.once('complete', function(err, response) {
				var result = !err && response;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);
				for(var i = 0; i < checksInProgress.length; i++) checksInProgress[i](null, result);
				checksInProgress = null;
			});
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
		};
	}

	return JSONPTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (JSONPTransport);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_389691__(20)))

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_401044__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_401044__(3);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_401044__(1);
/* harmony import */ var _transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_401044__(19);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_401044__(5);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_401044__(0);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_401044__(8);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_401044__(2);








var WebSocketTransport = function(connectionManager) {
	var WebSocket = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].WebSocket;
	var shortName = 'web_socket';

	/* public constructor */
	function WebSocketTransport(connectionManager, auth, params) {
		this.shortName = shortName;
		/* If is a browser, can't detect pings, so request protocol heartbeats */
		params.heartbeats = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].useProtocolHeartbeats;
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.wsHost = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHost(params.options, params.host, true);
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(WebSocketTransport, _transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	WebSocketTransport.isAvailable = function() {
		return !!WebSocket;
	};

	if(WebSocketTransport.isAvailable())
		connectionManager.supportedTransports[shortName] = WebSocketTransport;

	WebSocketTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new WebSocketTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('wsopen', function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	WebSocketTransport.prototype.createWebSocket = function(uri, connectParams) {
		var paramCount = 0;
		if(connectParams) {
			for(var key in connectParams)
				uri += (paramCount++ ? '&' : '?') + key + '=' + connectParams[key];
		}
		this.uri = uri;
		return new WebSocket(uri);
	};

	WebSocketTransport.prototype.toString = function() {
		return 'WebSocketTransport; uri=' + this.uri;
	};

	WebSocketTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'starting');
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var wsScheme = options.tls ? 'wss://' : 'ws://';
		var wsUri = wsScheme + this.wsHost + ':' + _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getPort(options) + '/';
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(self.isDisposed) {
				return;
			}
			var paramStr = ''; for(var param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);
			if(err) {
				self.disconnect(err);
				return;
			}
			var connectParams = params.getConnectParams(authParams);
			try {
				var wsConnection = self.wsConnection = self.createWebSocket(wsUri, connectParams);
				wsConnection.binaryType = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].binaryType;
				wsConnection.onopen = function() { self.onWsOpen(); };
				wsConnection.onclose = function(ev) { self.onWsClose(ev); };
				wsConnection.onmessage = function(ev) { self.onWsData(ev.data); };
				wsConnection.onerror = function(ev) { self.onWsError(ev); };
				if(wsConnection.on) {
					/* node; browsers currently don't have a general eventemitter and can't detect
					 * pings. Also, no need to reply with a pong explicitly, ws lib handles that */
					wsConnection.on('ping', function() { self.onActivity(); });
				}
			} catch(e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));
				self.disconnect(e);
			}
		});
	};

	WebSocketTransport.prototype.send = function(message) {
		var wsConnection = this.wsConnection;
		if(!wsConnection) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');
			return;
		}
		try {
			wsConnection.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].serialize(message, this.params.format));
		} catch (e) {
			var msg = 'Exception from ws connection when trying to send: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(e);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', msg);
			/* Don't try to request a disconnect, that'll just involve sending data
			 * down the websocket again. Just finish the transport. */
			this.finish('disconnected', new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 50000, 500));
		}
	};

	WebSocketTransport.prototype.onWsData = function(data) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof(data));
		try {
			this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].deserialize(data, this.format));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);
		}
	};

	WebSocketTransport.prototype.onWsOpen = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');
		this.emit('wsopen');
	};

	WebSocketTransport.prototype.onWsClose = function(ev) {
		var wasClean, code, reason;
		if(typeof(ev) == 'object') {
			/* W3C spec-compatible */
			wasClean = ev.wasClean;
			code = ev.code;
		} else /*if(typeof(ev) == 'number')*/ {
			/* ws in node */
			code = ev;
			wasClean = (code == 1000);
		}
		delete this.wsConnection;
		if(wasClean) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');
			var err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]('Websocket closed', 80003, 400);
			this.finish('disconnected', err);
		} else {
			var msg = 'Unclean disconnection of WebSocket ; code = ' + code,
				err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 80003, 400);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);
			this.finish('disconnected', err);
		}
		this.emit('disposed');
	};

	WebSocketTransport.prototype.onWsError = function(err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);
		/* Wait a tick before aborting: if the websocket was connected, this event
		 * will be immediately followed by an onclose event with a close code. Allow
		 * that to close it (so we see the close code) rather than anticipating it */
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			self.disconnect(err);
		});
	};

	WebSocketTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.dispose()', '');
		this.isDisposed = true;
		var wsConnection = this.wsConnection;
		if(wsConnection) {
			/* Ignore any messages that come through after dispose() is called but before
			 * websocket is actually closed. (mostly would be harmless, but if it's a
			 * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */
			wsConnection.onmessage = function() {};
			delete this.wsConnection;
			/* defer until the next event loop cycle before closing the socket,
			 * giving some implementations the opportunity to send any outstanding close message */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');
				wsConnection.close();
			});
		}
	};

	return WebSocketTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (WebSocketTransport);


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_411363__) {

"use strict";

// EXTERNAL MODULE: ./browser/lib/transport/jsonptransport.js
var jsonptransport = __nested_webpack_require_411363__(39);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_411363__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_411363__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_411363__(3);

// EXTERNAL MODULE: ./common/lib/transport/comettransport.js
var comettransport = __nested_webpack_require_411363__(15);

// EXTERNAL MODULE: ./browser/lib/transport/xhrrequest.js
var xhrrequest = __nested_webpack_require_411363__(27);

// CONCATENATED MODULE: ./browser/lib/transport/xhrpollingtransport.js






var xhrpollingtransport_XHRPollingTransport = function(connectionManager) {
	var shortName = 'xhr_polling';

	function XHRPollingTransport(connectionManager, auth, params) {
		params.stream = false;
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRPollingTransport, comettransport["a" /* default */]);

	XHRPollingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRPollingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRPollingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRPollingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRPollingTransport.prototype.toString = function() {
		return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRPollingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRPollingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRPollingTransport;
	}

	return XHRPollingTransport;
};

/* harmony default export */ var xhrpollingtransport = (xhrpollingtransport_XHRPollingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/xhrstreamingtransport.js






var xhrstreamingtransport_XHRStreamingTransport = function(connectionManager) {
	var shortName = 'xhr_streaming';

	/* public constructor */
	function XHRStreamingTransport(connectionManager, auth, params) {
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRStreamingTransport, comettransport["a" /* default */]);

	XHRStreamingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].streamingSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRStreamingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRStreamingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRStreamingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRStreamingTransport.prototype.toString = function() {
		return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRStreamingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRStreamingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRStreamingTransport;
	}

	return XHRStreamingTransport;
};

/* harmony default export */ var xhrstreamingtransport = (xhrstreamingtransport_XHRStreamingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/index.js




/* harmony default export */ var lib_transport = __webpack_exports__["a"] = ([
  jsonptransport["a" /* default */],
  xhrpollingtransport,
  xhrstreamingtransport
]);


/***/ }),
/* 42 */
/***/ (function(module, exports) {



/***/ }),
/* 43 */
/***/ (function(module, exports, __nested_webpack_require_416250__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_416250__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),
/* 44 */
/***/ (function(module, exports, __nested_webpack_require_420248__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_420248__(12), __nested_webpack_require_420248__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),
/* 45 */
/***/ (function(module, exports, __nested_webpack_require_421957__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_421957__(12), __nested_webpack_require_421957__(17), __nested_webpack_require_421957__(46), __nested_webpack_require_421957__(30), __nested_webpack_require_421957__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_430467__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_430467__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_439809__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_439809__.r(__webpack_exports__);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_439809__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_439809__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_439809__(0);

// EXTERNAL MODULE: ./common/lib/util/defaults.js + 1 modules
var defaults = __nested_webpack_require_439809__(5);

// EXTERNAL MODULE: ./common/lib/client/auth.js + 1 modules
var auth = __nested_webpack_require_439809__(14);

// CONCATENATED MODULE: ./common/lib/types/devicedetails.js


var devicedetails_DeviceDetails = (function() {

	function DeviceDetails() {
		this.id = undefined;
		this.deviceSecret = undefined;
		this.platform = undefined;
		this.formFactor = undefined;
		this.clientId = undefined;
		this.metadata = undefined;
		this.deviceIdentityToken = undefined;
		this.push = {
			recipient: undefined,
			state: undefined,
			errorReason: undefined
		};
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	DeviceDetails.prototype.toJSON = function() {
		return {
			id: this.id,
			deviceSecret: this.deviceSecret,
			platform: this.platform,
			formFactor: this.formFactor,
			clientId: this.clientId,
			metadata: this.metadata,
			deviceIdentityToken: this.deviceIdentityToken,
			push: {
				recipient: this.push.recipient,
				state: this.push.state,
				errorReason: this.push.errorReason
			}
		};
	};

	DeviceDetails.prototype.toString = function() {
		var result = '[DeviceDetails';
		if(this.id)
			result += '; id=' + this.id;
		if(this.platform)
			result += '; platform=' + this.platform;
		if(this.formFactor)
			result += '; formFactor=' + this.formFactor;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.metadata)
			result += '; metadata=' + this.metadata;
		if(this.deviceIdentityToken)
			result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);
		if(this.push.recipient)
			result += '; push.recipient=' + JSON.stringify(this.push.recipient);
		if(this.push.state)
			result += '; push.state=' + this.push.state;
		if(this.push.errorReason)
			result += '; push.errorReason=' + this.push.errorReason;
		if(this.push.metadata)
			result += '; push.metadata=' + this.push.metadata;
		result += ']';
		return result;
	};

	DeviceDetails.toRequestBody = utils["a" /* default */].encodeBody;

	DeviceDetails.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return DeviceDetails.fromValuesArray(body);
		} else {
			return DeviceDetails.fromValues(body);
		}
	};

	DeviceDetails.fromValues = function(values) {
		return utils["a" /* default */].mixin(new DeviceDetails(), values);
	};

	DeviceDetails.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);
		return result;
	};

	return DeviceDetails;
})();

/* harmony default export */ var devicedetails = (devicedetails_DeviceDetails);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_439809__(6);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_439809__(4);

// CONCATENATED MODULE: ./common/lib/client/resource.js







var resource_Resource = (function() {
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Resource() {}

	function withAuthDetails(rest, headers, params, errCallback, opCallback) {
		if (http["a" /* default */].supportsAuthHeaders) {
			rest.auth.getAuthHeaders(function(err, authHeaders) {
				if(err)
					errCallback(err);
				else
					opCallback(utils["a" /* default */].mixin(authHeaders, headers), params);
			});
		} else {
			rest.auth.getAuthParams(function(err, authParams) {
				if(err)
					errCallback(err);
				else
					opCallback(headers, utils["a" /* default */].mixin(authParams, params));
			});
		}
	}

	function unenvelope(callback, format) {
		return function(err, body, outerHeaders, unpacked, outerStatusCode) {
			if(err && !body) {
				callback(err);
				return;
			}

			if(!unpacked) {
				try {
					body = utils["a" /* default */].decodeBody(body, format);
				} catch(e) {
					callback(e);
					return;
				}
			}

			if(body.statusCode === undefined) {
				/* Envelope already unwrapped by the transport */
				callback(err, body, outerHeaders, true, outerStatusCode);
				return;
			}

			var wrappedStatusCode = body.statusCode,
				response = body.response,
				wrappedHeaders = body.headers;

			if(wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
				/* handle wrapped errors */
				var wrappedErr = (response && response.error) || err;
				if(!wrappedErr) {
					wrappedErr = new Error("Error in unenveloping " + body);
					wrappedErr.statusCode = wrappedStatusCode;
				}
				callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
				return;
			}

			callback(err, response, wrappedHeaders, true, wrappedStatusCode);
		};
	}

	function paramString(params) {
		var paramPairs = [];
		if (params) {
			for (var needle in params) {
				paramPairs.push(needle + '=' + params[needle]);
			}
		}
		return paramPairs.join('&');
	}

	function urlFromPathAndParams(path, params) {
		return path + (params ? '?' : '') + paramString(params);
	}

	function logResponseHandler(callback, method, path, params) {
		return function(err, body, headers, unpacked, statusCode) {
			if (err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + utils["a" /* default */].inspectError(err));
			} else {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()',
					'Received; ' + urlFromPathAndParams(path, params) + '; Headers: ' + paramString(headers) + '; StatusCode: ' + statusCode + '; Body: ' + (bufferutils["a" /* default */].isBuffer(body) ? body.toString() : body));
			}
			if (callback) { callback(err, body, headers, unpacked, statusCode); }
		}
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		Resource[method] = function(rest, path, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, null, origheaders, origparams, envelope, callback);
		};
	});

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		Resource[method] = function(rest, path, body, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, body, origheaders, origparams, envelope, callback);
		};
	});

	Resource['do'] = function(method, rest, path, body, origheaders, origparams, envelope, callback) {
		if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
			callback = logResponseHandler(callback, method, path, origparams);
		}

		if(envelope) {
			callback = (callback && unenvelope(callback, envelope));
			(origparams = (origparams || {}))['envelope'] = envelope;
		}

		function doRequest(headers, params) {
			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params));
			}

			var args = [rest, path, headers, body, params, function(err, res, headers, unpacked, statusCode) {
				if(err && auth["a" /* default */].isTokenErr(err)) {
					/* token has expired, so get a new one */
					rest.auth.authorize(null, null, function(err) {
						if(err) {
							callback(err);
							return;
						}
						/* retry ... */
						withAuthDetails(rest, origheaders, origparams, callback, doRequest);
					});
					return;
				}
				callback(err, res, headers, unpacked, statusCode);
			}];
			if (!body) {
				args.splice(3, 1);
			}

			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				var decodedBody = body;
				if ((headers['content-type'] || '').indexOf('msgpack') > 0) {
					try {
						decodedBody = msgpack.decode(body);
					} catch (decodeErr) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending MsgPack Decoding Error: ' + utils["a" /* default */].inspectError(decodeErr));
					}
				}
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);
			}
			http["a" /* default */][method].apply(this, args);
		}

		withAuthDetails(rest, origheaders, origparams, callback, doRequest);
	};

	return Resource;
})();

/* harmony default export */ var client_resource = (resource_Resource);

// CONCATENATED MODULE: ./common/lib/client/paginatedresource.js





var paginatedresource_PaginatedResource = (function() {

	function getRelParams(linkUrl) {
		var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
		return urlMatch && utils["a" /* default */].parseQueryString(urlMatch[2]);
	}

	function parseRelLinks(linkHeader) {
		if(typeof(linkHeader) == 'string')
			linkHeader = linkHeader.split(',');

		var relParams = {};
		for(var i = 0; i < linkHeader.length; i++) {
			var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
			if(linkMatch) {
				var params = getRelParams(linkMatch[1]);
				if(params)
					relParams[linkMatch[2]] = params;
			}
		}
		return relParams;
	}

	function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
		this.rest = rest;
		this.path = path;
		this.headers = headers;
		this.envelope = envelope;
		this.bodyHandler = bodyHandler;
		this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		PaginatedResource.prototype[method] = function(params, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, self.headers, params, self.envelope, function(err, body, headers, unpacked, statusCode) {
				self.handlePage(err, body, headers, unpacked, statusCode, callback);
			});
		};
	})

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		PaginatedResource.prototype[method] = function(params, body, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, body, self.headers, params, self.envelope, function(err, resbody, headers, unpacked, statusCode) {
				if(callback) {
					self.handlePage(err, resbody, headers, unpacked, statusCode, callback);
				}
			});
		};
	});

	function returnErrOnly(err, body, useHPR) {
		/* If using httpPaginatedResponse, errors from Ably are returned as part of
		 * the HPR, only do callback(err) for network errors etc. which don't
		 * return a body and/or have no ably-originated error code (non-numeric
		 * error codes originate from node) */
		return !(useHPR && (body || typeof err.code === 'number'));
	}

	PaginatedResource.prototype.handlePage = function(err, body, headers, unpacked, statusCode, callback) {
		if(err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + utils["a" /* default */].inspectError(err));
			callback(err);
			return;
		}
		var items, linkHeader, relParams;
		try {
			items = this.bodyHandler(body, headers, unpacked);
		} catch(e) {
			/* If we got an error, the failure to parse the body is almost certainly
			 * due to that, so cb with that in preference to the parse error */
			callback(err || e);
			return;
		}

		if(headers && (linkHeader = (headers['Link'] || headers['link']))) {
			relParams = parseRelLinks(linkHeader);
		}

		if(this.useHttpPaginatedResponse) {
			callback(null, new HttpPaginatedResponse(this, items, headers, statusCode, relParams, err));
		} else {
			callback(null, new PaginatedResult(this, items, relParams));
		}
	};

	function PaginatedResult(resource, items, relParams) {
		this.resource = resource;
		this.items = items;

		if(relParams) {
			var self = this;
			if('first' in relParams) {
				this.first = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'first', []);
					}
					self.get(relParams.first, cb);
				};
			}
			if('current' in relParams) {
				this.current = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'current', []);
					}
					self.get(relParams.current, cb);
				};
			}
			this.next = function(cb) {
				if(!cb && self.resource.rest.options.promises) {
					return utils["a" /* default */].promisify(self, 'next', []);
				}
				if('next' in relParams) {
					self.get(relParams.next, cb);
				} else {
					cb(null, null);
				}
			};

			this.hasNext = function() { return ('next' in relParams) };
			this.isLast = function() { return !this.hasNext(); }
		}
	}

	/* We assume that only the initial request can be a POST, and that accessing
	 * the rest of a multipage set of results can always be done with GET */
	PaginatedResult.prototype.get = function(params, callback) {
		var res = this.resource;
		client_resource.get(res.rest, res.path, res.headers, params, res.envelope, function(err, body, headers, unpacked, statusCode) {
			res.handlePage(err, body, headers, unpacked, statusCode, callback);
		});
	};

	function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {
		PaginatedResult.call(this, resource, items, relParams);
		this.statusCode = statusCode;
		this.success = statusCode < 300 && statusCode >= 200;
		this.headers = headers;
		this.errorCode = err && err.code;
		this.errorMessage = err && err.message;
	}
	utils["a" /* default */].inherits(HttpPaginatedResponse, PaginatedResult);

	return PaginatedResource;
})();

/* harmony default export */ var paginatedresource = (paginatedresource_PaginatedResource);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_439809__(2);

// CONCATENATED MODULE: ./common/lib/types/pushchannelsubscription.js


var pushchannelsubscription_PushChannelSubscription = (function() {

	function PushChannelSubscription() {
		this.channel = undefined;
		this.deviceId = undefined;
		this.clientId = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PushChannelSubscription.prototype.toJSON = function() {
		return {
			channel: this.channel,
			deviceId: this.deviceId,
			clientId: this.clientId
		};
	};

	PushChannelSubscription.prototype.toString = function() {
		var result = '[PushChannelSubscription';
		if(this.channel)
			result += '; channel=' + this.channel;
		if(this.deviceId)
			result += '; deviceId=' + this.deviceId;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		result += ']';
		return result;
	};

	PushChannelSubscription.toRequestBody = utils["a" /* default */].encodeBody;

	PushChannelSubscription.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return PushChannelSubscription.fromValuesArray(body);
		} else {
			return PushChannelSubscription.fromValues(body);
		}
	};

	PushChannelSubscription.fromValues = function(values) {
		return utils["a" /* default */].mixin(new PushChannelSubscription(), values);
	};

	PushChannelSubscription.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);
		return result;
	};

	return PushChannelSubscription;
})();

/* harmony default export */ var pushchannelsubscription = (pushchannelsubscription_PushChannelSubscription);

// CONCATENATED MODULE: ./common/lib/client/push.js








var push_Push = (function() {
	var noop = function() {};

	function Push(rest) {
		this.rest = rest;
		this.admin = new Admin(rest);
	}

	function Admin(rest) {
		this.rest = rest;
		this.deviceRegistrations = new DeviceRegistrations(rest);
		this.channelSubscriptions = new ChannelSubscriptions(rest);
	}

	Admin.prototype.publish = function(recipient, payload, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = utils["a" /* default */].mixin({recipient: recipient}, payload),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/publish', requestBody, headers, params, false, function(err) { callback(err); });
	};

	function DeviceRegistrations(rest) {
		this.rest = rest;
	}

	DeviceRegistrations.prototype.save = function(device, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = devicedetails.fromValues(device),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.put(rest, '/push/deviceRegistrations/' + encodeURIComponent(device.id), requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.get = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		client_resource.get(rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, {}, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/deviceRegistrations', headers, envelope, function(body, headers, unpacked) {
			return devicedetails.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	DeviceRegistrations.prototype.remove = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			params = {},
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'remove', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, params, false, function(err) { callback(err); });
	};

	DeviceRegistrations.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations', headers, params, false, function(err) { callback(err); });
	};

	function ChannelSubscriptions(rest) {
		this.rest = rest;
	}

	ChannelSubscriptions.prototype.save = function(subscription, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = pushchannelsubscription.fromValues(subscription),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/channelSubscriptions', requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && pushchannelsubscription.fromResponseBody(body, !unpacked && format));
		});
	};

	ChannelSubscriptions.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/channelSubscriptions', headers, envelope, function(body, headers, unpacked) {
			return pushchannelsubscription.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	ChannelSubscriptions.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/channelSubscriptions', headers, params, false, function(err) { callback(err); });
	};

	/* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
	ChannelSubscriptions.prototype.remove = ChannelSubscriptions.prototype.removeWhere;

	ChannelSubscriptions.prototype.listChannels = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'listChannels', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		(new paginatedresource(rest, '/push/channels', headers, envelope, function(body, headers, unpacked) {
			var f = !unpacked && format;

			if(f) {
				body = utils["a" /* default */].decodeBody(body, format);
			}

			for(var i = 0; i < body.length; i++) {
				body[i] = String(body[i]);
			}
			return body;
		})).get(params, callback);
	};

	return Push;
})();

/* harmony default export */ var push = (push_Push);

// EXTERNAL MODULE: ./common/lib/util/eventemitter.js
var eventemitter = __nested_webpack_require_439809__(7);

// EXTERNAL MODULE: ./common/lib/types/presencemessage.js
var presencemessage = __nested_webpack_require_439809__(11);

// CONCATENATED MODULE: ./common/lib/client/presence.js







var presence_Presence = (function() {
	function noop() {}
	function Presence(channel) {
		this.channel = channel;
		this.basePath = channel.basePath + '/presence';
	}
	utils["a" /* default */].inherits(Presence, eventemitter["a" /* default */]);

	Presence.prototype.get = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'get', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath, headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	Presence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);
		this._history(params, callback);
	};

	Presence.prototype._history = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, '_history', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this.channel;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath + '/history', headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	return Presence;
})();

/* harmony default export */ var client_presence = (presence_Presence);

// EXTERNAL MODULE: ./browser/lib/util/crypto.js
var util_crypto = __nested_webpack_require_439809__(18);

// EXTERNAL MODULE: ./common/lib/types/message.js
var types_message = __nested_webpack_require_439809__(9);

// CONCATENATED MODULE: ./common/lib/client/channel.js











var channel_Channel = (function() {
	function noop() {}
	var MSG_ID_ENTROPY_BYTES = 9;

	/* public constructor */
	function Channel(rest, name, channelOptions) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Channel()', 'started; name = ' + name);
		eventemitter["a" /* default */].call(this);
		this.rest = rest;
		this.name = name;
		this.basePath = '/channels/' + encodeURIComponent(name);
		this.presence = new client_presence(this);
		this.setOptions(channelOptions);
	}
	utils["a" /* default */].inherits(Channel, eventemitter["a" /* default */]);

	Channel.prototype.setOptions = function(options) {
		this.channelOptions = options = options || {};
		if(options.cipher) {
			if(!util_crypto["a" /* default */]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = util_crypto["a" /* default */].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		} else if('cipher' in options) {
			/* Don't deactivate an existing cipher unless options
			 * has a 'cipher' key that's falsey */
			options.cipher = null;
			options.channelCipher = null;
		}
	};

	Channel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		this._history(params, callback);
	};

	Channel.prototype._history = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channelOptions;
		(new paginatedresource(rest, this.basePath + '/messages', headers, envelope, function(body, headers, unpacked) {
			return types_message["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	function allEmptyIds(messages) {
		return utils["a" /* default */].arrEvery(messages, function(message) {
			return !message.id;
		});
	}

	Channel.prototype.publish = function() {
		var argCount = arguments.length,
			first = arguments[0],
			second = arguments[1],
			callback = arguments[argCount - 1],
			messages,
			params,
			self = this;

		if(typeof(callback) !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(typeof first === 'string' || first === null) {
			/* (name, data, ...) */
			messages = [types_message["a" /* default */].fromValues({name: first, data: second})];
			params = arguments[2];
		} else if(utils["a" /* default */].isObject(first)) {
			messages = [types_message["a" /* default */].fromValues(first)];
			params = arguments[1];
		} else if(utils["a" /* default */].isArray(first)) {
			messages = types_message["a" /* default */].fromValuesArray(first);
			params = arguments[1];
		} else {
			throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		}

		if(typeof params !== 'object' || !params) {
			/* No params supplied (so after-message argument is just the callback or undefined) */
			params = {};
		}

		var rest = this.rest,
			options = rest.options,
			format = options.useBinaryProtocol ? 'msgpack' : 'json',
			idempotentRestPublishing = rest.options.idempotentRestPublishing,
			headers = utils["a" /* default */].defaultPostHeaders(format);

		if(options.headers)
			utils["a" /* default */].mixin(headers, options.headers);

		if(idempotentRestPublishing && allEmptyIds(messages)) {
			var msgIdBase = utils["a" /* default */].randomString(MSG_ID_ENTROPY_BYTES);
			utils["a" /* default */].arrForEach(messages, function(message, index) {
				message.id = msgIdBase + ':' + index.toString();
			});
		}

		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if(err) {
				callback(err);
				return;
			}

			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages),
				maxMessageSize = options.maxMessageSize;
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}

			self._publish(types_message["a" /* default */].serialize(messages, format), headers, params, callback);
		});
	};

	Channel.prototype._publish = function(requestBody, headers, params, callback) {
		client_resource.post(this.rest, this.basePath + '/messages', requestBody, headers, params, false, callback);
	};

	return Channel;
})();

/* harmony default export */ var client_channel = (channel_Channel);

// CONCATENATED MODULE: ./common/lib/types/stats.js


var stats_Stats = (function() {

	function MessageCount(values) {
		this.count = (values && values.count) || 0;
		this.data = (values && values.data) || 0;
		this.uncompressedData = (values && values.uncompressedData) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function MessageCategory(values) {
		var self = this;
		MessageCount.call(this, values);
		this.category = undefined;
		if (values && values.category) {
			this.category = { };
			utils["a" /* default */].forInOwnNonNullProps(values.category, function(prop) {
				self.category[prop] = new MessageCount(values.category[prop]);
			});
		}
	}

	function ResourceCount(values) {
		this.peak = (values && values.peak) || 0;
		this.min = (values && values.min) || 0;
		this.mean = (values && values.mean) || 0;
		this.opened = (values && values.opened) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function RequestCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function ConnectionTypes(values) {
		this.plain = new ResourceCount(values && values.plain);
		this.tls = new ResourceCount(values && values.tls);
		this.all = new ResourceCount(values && values.all);
	}

	function MessageTypes(values) {
		this.messages = new MessageCategory(values && values.messages);
		this.presence = new MessageCategory(values && values.presence);
		this.all = new MessageCategory(values && values.all);
	}

	function MessageTraffic(values) {
		this.realtime = new MessageTypes(values && values.realtime);
		this.rest = new MessageTypes(values && values.rest);
		this.webhook = new MessageTypes(values && values.webhook);
		this.sharedQueue = new MessageTypes(values && values.sharedQueue);
		this.externalQueue = new MessageTypes(values && values.externalQueue);
		this.httpEvent = new MessageTypes(values && values.httpEvent);
		this.push = new MessageTypes(values && values.push);
		this.all = new MessageTypes(values && values.all);
	}

	function MessageDirections(values) {
		this.all           = new MessageTypes(values && values.all);
		this.inbound       = new MessageTraffic(values && values.inbound);
		this.outbound      = new MessageTraffic(values && values.outbound);
	}

	function XchgMessages(values) {
		this.all           = new MessageTypes(values && values.all);
		this.producerPaid  = new MessageDirections(values && values.producerPaid);
		this.consumerPaid  = new MessageDirections(values && values.consumerPaid);
	}

	function PushStats(values) {
		this.messages = (values && values.messages) || 0;
		var notifications = values && values.notifications;
		this.notifications = {
			invalid: notifications && notifications.invalid || 0,
			attempted: notifications && notifications.attempted || 0,
			successful: notifications && notifications.successful || 0,
			failed: notifications && notifications.failed || 0
		};
		this.directPublishes = (values && values.directPublishes) || 0;
	}

	function ProcessedCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.skipped = (values && values.skipped) || 0;
		this.failed = (values && values.failed) || 0;
	}

	function ProcessedMessages(values) {
		var self = this;
		this.delta = undefined;
		if (values && values.delta) {
			this.delta = { };
			utils["a" /* default */].forInOwnNonNullProps(values.delta, function(prop) {
				self.delta[prop] = new ProcessedCount(values.delta[prop]);
			});
		}
	}

	function Stats(values) {
		MessageDirections.call(this, values);
		this.persisted     = new MessageTypes(values && values.persisted);
		this.connections   = new ConnectionTypes(values && values.connections);
		this.channels      = new ResourceCount(values && values.channels);
		this.apiRequests   = new RequestCount(values && values.apiRequests);
		this.tokenRequests = new RequestCount(values && values.tokenRequests);
		this.xchgProducer  = new XchgMessages(values && values.xchgProducer);
		this.xchgConsumer  = new XchgMessages(values && values.xchgConsumer);
		this.push          = new PushStats(values && values.pushStats);
		this.processed     = new ProcessedMessages(values && values.processed);
		this.inProgress    = (values && values.inProgress) || undefined;
		this.unit          = (values && values.unit) || undefined;
		this.intervalId    = (values && values.intervalId) || undefined;
	}

	Stats.fromValues = function(values) {
		return new Stats(values);
	};

	return Stats;
})();

/* harmony default export */ var stats = (stats_Stats);

// CONCATENATED MODULE: ./common/lib/client/rest.js












var rest_Rest = (function() {
	var noop = function() {};
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Rest(options) {
		if(!(this instanceof Rest)){
			return new Rest(options);
		}

		/* normalise options */
		if(!options) {
			var msg = 'no options provided';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
			throw new Error(msg);
		}
		options = defaults["a" /* default */].objectifyOptions(options);

		if(options.log) {
			logger["a" /* default */].setLog(options.log.level, options.log.handler);
		}
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + utils["a" /* default */].inspect(options));

		this.options = defaults["a" /* default */].normaliseOptions(options);

		/* process options */
		if(options.key) {
			var keyMatch = options.key.match(/^([^:\s]+):([^:.\s]+)$/);
			if(!keyMatch) {
				var msg = 'invalid key parameter';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
				throw new Error(msg);
			}
			options.keyName = keyMatch[1];
			options.keySecret = keyMatch[2];
		}

		if('clientId' in options) {
			if(!(typeof(options.clientId) === 'string' || options.clientId === null))
				throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
			else if(options.clientId === '*')
				throw new errorinfo["a" /* default */]('Cant use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Rest()', 'started; version = ' + defaults["a" /* default */].libstring);

		this.baseUri = this.authority = function(host) { return defaults["a" /* default */].getHttpScheme(options) + host + ':' + defaults["a" /* default */].getPort(options, false); };
		this._currentFallback = null;

		this.serverTimeOffset = null;
		this.auth = new auth["a" /* default */](this, options);
		this.channels = new Channels(this);
		this.push = new push(this);
	}

	Rest.prototype.stats = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'stats', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders(),
			format = this.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;

		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);

		(new paginatedresource(this, '/stats', headers, envelope, function(body, headers, unpacked) {
			var statsValues = (unpacked ? body : JSON.parse(body));
			for(var i = 0; i < statsValues.length; i++) statsValues[i] = stats.fromValues(statsValues[i]);
			return statsValues;
		})).get(params, callback);
	};

	Rest.prototype.time = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'time', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders();
		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);
		var self = this;
		var timeUri = function(host) { return self.authority(host) + '/time' };
		http["a" /* default */].get(this, timeUri, headers, params, function(err, res, headers, unpacked) {
			if(err) {
				callback(err);
				return;
			}
			if(!unpacked) res = JSON.parse(res);
			var time = res[0];
			if(!time) {
				err = new Error('Internal error (unexpected result type from GET /time)');
				err.statusCode = 500;
				callback(err);
				return;
			}
			/* calculate time offset only once for this device by adding to the prototype */
			self.serverTimeOffset = (time - utils["a" /* default */].now());
			callback(null, time);
		});
	};

	Rest.prototype.request = function(method, path, params, body, customHeaders, callback) {
		var useBinary = this.options.useBinaryProtocol,
			encoder = useBinary ? msgpack.encode: JSON.stringify,
			decoder = useBinary ? msgpack.decode : JSON.parse,
			format = useBinary ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;
		params = params || {};
		method = method.toLowerCase();
		var headers = method == 'get' ? utils["a" /* default */].defaultGetHeaders(format) : utils["a" /* default */].defaultPostHeaders(format);

		if(callback === undefined) {
			if(this.options.promises) {
				return utils["a" /* default */].promisify(this, 'request', [method, path, params, body, customHeaders]);
			}
			callback = noop;
		}

		if(typeof body !== 'string') {
			body = encoder(body);
		}
		if(this.options.headers) {
			utils["a" /* default */].mixin(headers, this.options.headers);
		}
		if(customHeaders) {
			utils["a" /* default */].mixin(headers, customHeaders);
		}
		var paginatedResource = new paginatedresource(this, path, headers, envelope, function(resbody, headers, unpacked) {
			return utils["a" /* default */].ensureArray(unpacked ? resbody : decoder(resbody));
		}, /* useHttpPaginatedResponse: */ true);

		if(!utils["a" /* default */].arrIn(http["a" /* default */].methods, method)) {
			throw new errorinfo["a" /* default */]('Unsupported method ' + method, 40500, 405);
		}

		if(utils["a" /* default */].arrIn(http["a" /* default */].methodsWithBody, method)) {
			paginatedResource[method](params, body, callback);
		} else {
			paginatedResource[method](params, callback);
		}
	};

	Rest.prototype.setLog = function(logOptions) {
		logger["a" /* default */].setLog(logOptions.level, logOptions.handler);
	};

	function Channels(rest) {
		this.rest = rest;
		this.all = {};
	}

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			this.all[name] = channel = new client_channel(this.rest, name, channelOptions);
		} else if(channelOptions) {
			channel.setOptions(channelOptions);
		}

		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		delete this.all[String(name)];
	};

	return Rest;
})();

rest_Rest.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new rest_Rest(options);
};

rest_Rest.Callbacks = rest_Rest;

/* harmony default export */ var client_rest = (rest_Rest);

// EXTERNAL MODULE: ./common/lib/transport/connectionmanager.js
var connectionmanager = __nested_webpack_require_439809__(25);

// EXTERNAL MODULE: ./common/lib/client/connectionstatechange.js
var connectionstatechange = __nested_webpack_require_439809__(21);

// CONCATENATED MODULE: ./common/lib/client/connection.js






var connection_Connection = (function() {
	function noop() {}

	/* public constructor */
	function Connection(ably, options) {
		eventemitter["a" /* default */].call(this);
		this.ably = ably;
		this.connectionManager = new connectionmanager["a" /* default */](ably, options);
		this.state = this.connectionManager.state.state;
		this.key = undefined;
		this.id = undefined;
		this.serial = undefined;
		this.timeSerial = undefined;
		this.recoveryKey = undefined;
		this.errorReason = null;

		var self = this;
		this.connectionManager.on('connectionstate', function(stateChange) {
			var state = self.state = stateChange.current;
			utils["a" /* default */].nextTick(function() {
				self.emit(state, stateChange);
			});
		});
		this.connectionManager.on('update', function(stateChange) {
			utils["a" /* default */].nextTick(function() {
				self.emit('update', stateChange);
			});
		});
	}
	utils["a" /* default */].inherits(Connection, eventemitter["a" /* default */]);

	Connection.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener, new connectionstatechange["a" /* default */](undefined, state));
	}

	Connection.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.connect()', '');
		this.connectionManager.requestState({state: 'connecting'});
	};

	Connection.prototype.ping = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.ping()', '');
		if(!callback) {
			if(this.ably.options.promises) {
				return utils["a" /* default */].promisify(this, 'ping', arguments);
			}
			callback = noop;
		}
		this.connectionManager.ping(null, callback);
	};

	Connection.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);
		this.connectionManager.requestState({state: 'closing'});
	};

	return Connection;
})();

/* harmony default export */ var connection = (connection_Connection);

// EXTERNAL MODULE: ./common/lib/types/protocolmessage.js
var protocolmessage = __nested_webpack_require_439809__(8);

// EXTERNAL MODULE: ./common/lib/transport/connectionerror.js
var connectionerror = __nested_webpack_require_439809__(13);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var util_multicaster = __nested_webpack_require_439809__(22);

// CONCATENATED MODULE: ./common/lib/client/channelstatechange.js
var ChannelStateChange = (function() {

	/* public constructor */
	function ChannelStateChange(previous, current, resumed, reason) {
		this.previous = previous;
		this.current = current;
		if(current === 'attached') this.resumed = resumed;
		if(reason) this.reason = reason;
	}

	return ChannelStateChange;
})();

/* harmony default export */ var channelstatechange = (ChannelStateChange);

// CONCATENATED MODULE: ./common/lib/client/realtimepresence.js











var realtimepresence_RealtimePresence = (function() {
	var noop = function() {};

	function memberKey(item) {
		return item.clientId + ':' + item.connectionId;
	}

	function getClientId(realtimePresence) {
		return realtimePresence.channel.realtime.auth.clientId;
	}

	function isAnonymousOrWildcard(realtimePresence) {
		var realtime = realtimePresence.channel.realtime;
		/* If not currently connected, we can't assume that we're an anonymous
		 * client, as realtime may inform us of our clientId in the CONNECTED
		 * message. So assume we're not anonymous and leave it to realtime to
		 * return an error if we are */
		var clientId = realtime.auth.clientId;
		return (!clientId || (clientId === '*')) && realtime.connection.state === 'connected';
	}

	/* Callback is called only in the event of an error */
	function waitAttached(channel, callback, action) {
		switch(channel.state) {
			case 'attached':
			case 'suspended':
				action();
				break;
			case 'initialized':
			case 'detached':
			case 'detaching':
			case 'attaching':
				channel.attach(function(err) {
					if(err) callback(err);
					else action();
				});
				break;
			default:
				callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError(channel.state)));
		}
	}

	function RealtimePresence(channel, options) {
		client_presence.call(this, channel);
		this.syncComplete = false;
		this.members = new PresenceMap(this);
		this._myMembers = new PresenceMap(this);
		this.subscriptions = new eventemitter["a" /* default */]();
		this.pendingPresence = [];
	}
	utils["a" /* default */].inherits(RealtimePresence, client_presence);

	RealtimePresence.prototype.enter = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to enter a presence channel', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'enter', callback);
	};

	RealtimePresence.prototype.update = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to update presence data', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'update', callback);
	};

	RealtimePresence.prototype.enterClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'enter', callback);
	};

	RealtimePresence.prototype.updateClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'update', callback);
	};

	RealtimePresence.prototype._enterOrUpdateClient = function(clientId, data, action, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, '_enterOrUpdateClient', [clientId, data, action]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.' + action + 'Client()',
		  'channel = ' + channel.name + ', client = ' + (clientId || '(implicit) ' + getClientId(this)));

		var presence = presencemessage["a" /* default */].fromValues({
			action : action,
			data   : data
		});
		if (clientId) {
			presence.clientId = clientId;
		}

		var self = this;
		presencemessage["a" /* default */].encode(presence, channel.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			switch(channel.state) {
				case 'attached':
					channel.sendPresence(presence, callback);
					break;
				case 'initialized':
				case 'detached':
					channel.attach();
				case 'attaching':
					self.pendingPresence.push({
						presence : presence,
						callback : callback
					});
					break;
				default:
					err = new errorinfo["a" /* default */]('Unable to ' + action + ' presence channel while in ' + channel.state + ' state', 90001);
					err.code = 90001;
					callback(err);
			}
		});
	};

	RealtimePresence.prototype.leave = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must have been specified to enter or leave a presence channel', 40012, 400);
		}
		return this.leaveClient(undefined, data, callback);
	};

	RealtimePresence.prototype.leaveClient = function(clientId, data, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'leaveClient', [clientId, data]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);
		var presence = presencemessage["a" /* default */].fromValues({
			action : 'leave',
			data   : data
		});
		if (clientId) { presence.clientId = clientId; }

		switch(channel.state) {
			case 'attached':
				channel.sendPresence(presence, callback);
				break;
			case 'attaching':
				this.pendingPresence.push({
					presence : presence,
					callback : callback
				});
				break;
			case 'initialized':
			case 'failed':
				/* we're not attached; therefore we let any entered status
				 * timeout by itself instead of attaching just in order to leave */
				var err = new errorinfo["a" /* default */]('Unable to leave presence channel (incompatible state)', 90001);
				callback(err);
				break;
			default:
				/* there is no connection; therefore we let
				 * any entered status timeout by itself */
				callback(connectionerror["a" /* default */].failed);
		}
	};

	RealtimePresence.prototype.get = function(/* params, callback */) {
		var args = Array.prototype.slice.call(arguments);
		if(args.length == 1 && typeof(args[0]) == 'function')
			args.unshift(null);

		var params = args[0],
			callback = args[1],
			waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', args);
			}
			callback = noop;
		}

		function returnMembers(members) {
			callback(null, params ? members.list(params) : members.values());
		}

		/* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */
		if(this.channel.state === 'suspended') {
			if(waitForSync) {
				callback(errorinfo["a" /* default */].fromValues({
					statusCode: 400,
					code: 91005,
					message: 'Presence state is out of sync due to channel being in the SUSPENDED state'
				}));
			} else {
				returnMembers(this.members);
			}
			return;
		}

		var self = this;
		waitAttached(this.channel, callback, function() {
			var members = self.members;
			if(waitForSync) {
				members.waitSync(function() {
					returnMembers(members);
				});
			} else {
				returnMembers(members);
			}
		});
	};

	RealtimePresence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.channel.state === 'attached') {
				delete params.untilAttach;
				params.from_serial = this.channel.properties.attachSerial;
			} else {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached, was: " + this.channel.state, 40000, 400));
			}
		}

		client_presence.prototype._history.call(this, params, callback);
	};

	RealtimePresence.prototype.setPresence = function(presenceSet, isSync, syncChannelSerial) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);
		var syncCursor, match, members = this.members, myMembers = this._myMembers,
			broadcastMessages = [], connId = this.channel.connectionManager.connectionId;

		if(isSync) {
			this.members.startSync();
			if(syncChannelSerial && (match = syncChannelSerial.match(/^[\w\-]+:(.*)$/))) {
				syncCursor = match[1];
			}
		}

		for(var i = 0; i < presenceSet.length; i++) {
			var presence = presencemessage["a" /* default */].fromValues(presenceSet[i]);
			switch(presence.action) {
				case 'leave':
					if(members.remove(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId && !presence.isSynthesized()) {
						myMembers.remove(presence);
					}
					break;
				case 'enter':
				case 'present':
				case 'update':
					if(members.put(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId) {
						myMembers.put(presence);
					}
					break;
			}
		}
		/* if this is the last (or only) message in a sequence of sync updates, end the sync */
		if(isSync && !syncCursor) {
			members.endSync();
			/* RTP5c2: re-enter our own members if they haven't shown up in the sync */
			this._ensureMyMembersPresent();
			this.channel.setInProgress(realtimechannel.progressOps.sync, false);
			this.channel.syncChannelSerial = null;
		}

		/* broadcast to listeners */
		for(var i = 0; i < broadcastMessages.length; i++) {
			var presence = broadcastMessages[i];
			this.subscriptions.emit(presence.action, presence);
		}
	};

	RealtimePresence.prototype.onAttached = function(hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);

		if(hasPresence) {
			this.members.startSync();
		} else {
			this._synthesizeLeaves(this.members.values());
			this.members.clear();
			this._ensureMyMembersPresent();
		}

		/* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */
		var pendingPresence = this.pendingPresence,
			pendingPresCount = pendingPresence.length;

		if(pendingPresCount) {
			this.pendingPresence = [];
			var presenceArray = [];
			var multicaster = Object(util_multicaster["a" /* default */])();
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');
			for(var i = 0; i < pendingPresCount; i++) {
				var event = pendingPresence[i];
				presenceArray.push(event.presence);
				multicaster.push(event.callback);
			}
			this.channel.sendPresence(presenceArray, multicaster);
		}
	};

	RealtimePresence.prototype.actOnChannelState = function(state, hasPresence, err) {
		switch(state) {
			case 'attached':
				this.onAttached(hasPresence);
				break;
			case 'detached':
			case 'failed':
				this._clearMyMembers();
				this.members.clear();
				/* falls through */
			case 'suspended':
				this.failPendingPresence(err);
				break;
		}
	};

	RealtimePresence.prototype.failPendingPresence = function(err) {
		if(this.pendingPresence.length) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + utils["a" /* default */].inspectError(err));
			for(var i = 0; i < this.pendingPresence.length; i++)
				try {
					this.pendingPresence[i].callback(err);
				} catch(e) {}
			this.pendingPresence = [];
		}
	};

	RealtimePresence.prototype._clearMyMembers = function() {
		this._myMembers.clear();
	};

	RealtimePresence.prototype._ensureMyMembersPresent = function() {
		var self = this, members = this.members, myMembers = this._myMembers,
			reenterCb = function(err) {
				if(err) {
					var msg = 'Presence auto-re-enter failed: ' + err.toString();
					var wrappedErr = new errorinfo["a" /* default */](msg, 91004, 400);
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);
					var change = new channelstatechange(self.channel.state, self.channel.state, true, wrappedErr);
					self.channel.emit('update', change);
				}
			};

		for(var memberKey in myMembers.map) {
			if(!(memberKey in members.map)) {
				var entry = myMembers.map[memberKey];
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
				this._enterOrUpdateClient(entry.clientId, entry.data, 'enter', reenterCb);
				delete myMembers.map[memberKey];
			}
		}
	};

	RealtimePresence.prototype._synthesizeLeaves = function(items) {
		var subscriptions = this.subscriptions;
		utils["a" /* default */].arrForEach(items, function(item) {
			var presence = presencemessage["a" /* default */].fromValues({
				action: 'leave',
				connectionId: item.connectionId,
				clientId: item.clientId,
				data: item.data,
				encoding: item.encoding,
				timestamp: utils["a" /* default */].now()
			});
			subscriptions.emit('leave', presence);
		});
	};

	/* Deprecated */
	RealtimePresence.prototype.on = function() {
		logger["a" /* default */].deprecated('presence.on', 'presence.subscribe');
		this.subscribe.apply(this, arguments);
	};

	/* Deprecated */
	RealtimePresence.prototype.off = function() {
		logger["a" /* default */].deprecated('presence.off', 'presence.unsubscribe');
		this.unsubscribe.apply(this, arguments);
	};

	RealtimePresence.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];
		var channel = this.channel;
		var self = this;

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(channel.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);
		channel.attach(callback);
	};

	RealtimePresence.prototype.unsubscribe = function(/* [event], listener */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	function PresenceMap(presence) {
		eventemitter["a" /* default */].call(this);
		this.presence = presence;
		this.map = {};
		this.syncInProgress = false;
		this.residualMembers = null;
	}
	utils["a" /* default */].inherits(PresenceMap, eventemitter["a" /* default */]);

	PresenceMap.prototype.get = function(key) {
		return this.map[key];
	};

	PresenceMap.prototype.getClient = function(clientId) {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.clientId == clientId && item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.list = function(params) {
		var map = this.map,
			clientId = params && params.clientId,
			connectionId = params && params.connectionId,
			result = [];

		for(var key in map) {
			var item = map[key];
			if(item.action === 'absent') continue;
			if(clientId && clientId != item.clientId) continue;
			if(connectionId && connectionId != item.connectionId) continue;
			result.push(item);
		}
		return result;
	};

	function newerThan(item, existing) {
		/* RTP2b1: if either is synthesised, compare by timestamp */
		if(item.isSynthesized() || existing.isSynthesized()) {
			return item.timestamp > existing.timestamp;
		}

		/* RTP2b2 */
		var itemOrderings = item.parseId(),
			existingOrderings = existing.parseId();
		if(itemOrderings.msgSerial === existingOrderings.msgSerial) {
			return itemOrderings.index > existingOrderings.index;
		} else {
			return itemOrderings.msgSerial > existingOrderings.msgSerial;
		}
	}

	PresenceMap.prototype.put = function(item) {
		if(item.action === 'enter' || item.action === 'update') {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'present';
		}
		var map = this.map, key = memberKey(item);
		/* we've seen this member, so do not remove it at the end of sync */
		if(this.residualMembers)
			delete this.residualMembers[key];

		/* compare the timestamp of the new item with any existing member (or ABSENT witness) */
		var existingItem = map[key];
		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}
		map[key] = item;
		return true;

	};

	PresenceMap.prototype.values = function() {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.remove = function(item) {
		var map = this.map, key = memberKey(item);
		var existingItem = map[key];

		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}

		/* RTP2f */
		if(this.syncInProgress) {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'absent';
			map[key] = item;
		} else {
			delete map[key];
		}

		return true;
	};

	PresenceMap.prototype.startSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		/* we might be called multiple times while a sync is in progress */
		if(!this.syncInProgress) {
			this.residualMembers = utils["a" /* default */].copy(map);
			this.setInProgress(true);
		}
	};

	PresenceMap.prototype.endSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(syncInProgress) {
			/* we can now strip out the ABSENT members, as we have
			 * received all of the out-of-order sync messages */
			for(var memberKey in map) {
				var entry = map[memberKey];
				if(entry.action === 'absent') {
					delete map[memberKey];
				}
			}
			/* any members that were present at the start of the sync,
			 * and have not been seen in sync, can be removed, and leave events emitted */
			this.presence._synthesizeLeaves(utils["a" /* default */].valuesArray(this.residualMembers));
			for(var memberKey in this.residualMembers) {
				delete map[memberKey];
			}
			this.residualMembers = null;

			/* finish, notifying any waiters */
			this.setInProgress(false);
		}
		this.emit('sync');
	};

	PresenceMap.prototype.waitSync = function(callback) {
		var syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(!syncInProgress) {
			callback();
			return;
		}
		this.once('sync', callback);
	};

	PresenceMap.prototype.clear = function(callback) {
		this.map = {};
		this.setInProgress(false);
		this.residualMembers = null;
	};

	PresenceMap.prototype.setInProgress = function(inProgress) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);
		this.syncInProgress = inProgress;
		this.presence.syncComplete = !inProgress;
	};

	return RealtimePresence;
})();

/* harmony default export */ var realtimepresence = (realtimepresence_RealtimePresence);

// CONCATENATED MODULE: ./common/lib/client/realtimechannel.js












var realtimechannel_RealtimeChannel = (function() {
	var actions = protocolmessage["a" /* default */].Action;
	var noop = function() {};
	var statechangeOp = 'statechange';
	var syncOp = 'sync';

	/* public constructor */
	function RealtimeChannel(realtime, name, options) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);
		client_channel.call(this, realtime, name, options);
		this.realtime = realtime;
		this.presence = new realtimepresence(this, realtime.options);
		this.connectionManager = realtime.connection.connectionManager;
		this.state = 'initialized';
		this.subscriptions = new eventemitter["a" /* default */]();
		this.syncChannelSerial = undefined;
		this.properties = {
			attachSerial: undefined
		};
		this.setOptions(options);
		this.errorReason = null;
		this._requestedFlags = null;
		this._mode = null;
		/* Temporary; only used for the checkChannelsOnResume option */
		this._attachedMsgIndicator = false;
		this._attachResume = false;
		this._decodingContext = {
			channelOptions: this.channelOptions,
			plugins: realtime.options.plugins || { },
			baseEncodedPreviousPayload: undefined
		};
		this._lastPayload = {
			messageId: null,
			protocolMessageChannelSerial: null,
			decodeFailureRecoveryInProgress: null
		};
		/* Only differences between this and the public event emitter is that this emits an
		 * update event for all ATTACHEDs, whether resumed or not */
		this._allChannelChanges = new eventemitter["a" /* default */]();
	}
	utils["a" /* default */].inherits(RealtimeChannel, client_channel);

	RealtimeChannel.invalidStateError = function(state) {
		return {
			statusCode: 400,
			code: 90001,
			message: 'Channel operation failed as channel state is ' + state
		};
	};

	RealtimeChannel.progressOps = {
		statechange: statechangeOp,
		sync: syncOp
	};

	RealtimeChannel.processListenerArgs = function(args) {
		/* [event], listener, [callback] */
		args = Array.prototype.slice.call(args);
		if(typeof args[0] === 'function') {
			args.unshift(null);
		}
		if(args[args.length - 1] == undefined) {
			args.pop();
		}
		return args;
	};

	RealtimeChannel.prototype.setOptions = function(options, callback) {
		if(!callback) {
			if (this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'setOptions', arguments);
			}

			callback = function(err){
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.setOptions()', 'Set options failed: ' + err.toString());
				}
			};
		}
		var err = validateChannelOptions(options);
		if(err) {
			callback(err);
			return;
		}
		client_channel.prototype.setOptions.call(this, options);
		if (this._decodingContext)
			this._decodingContext.channelOptions = this.channelOptions;
		if(this._shouldReattachToSetOptions(options)) {
			/* This does not just do _attach(true, null, callback) because that would put us
			 * into the 'attaching' state until we receive the new attached, which is
			 * conceptually incorrect: we are still attached, we just have a pending request to
			 * change some channel params. Per RTL17 going into the attaching state would mean
			 * rejecting messages until we have confirmation that the options have changed,
			 * which would unnecessarily lose message continuity. */
			this.attachImpl();
			this._allChannelChanges.once(function(stateChange) {
				switch(this.event) {
					case 'update':
					case 'attached':
						callback(null);
						return;
					default:
						callback(stateChange.reason);
						return;
				}
			});
		} else {
			callback();
		}
	};

	function validateChannelOptions(options) {
		if(options && 'params' in options && !utils["a" /* default */].isObject(options.params)) {
			return new errorinfo["a" /* default */]('options.params must be an object', 40000, 400);
		}
		if(options && 'modes' in options){
			if(!utils["a" /* default */].isArray(options.modes)){
				return new errorinfo["a" /* default */]('options.modes must be an array', 40000, 400);
			}
			for(var i = 0; i < options.modes.length; i++){
				var currentMode = options.modes[i];
				if(!currentMode || typeof currentMode !== 'string' || !utils["a" /* default */].arrIn(protocolmessage["a" /* default */].channelModes, String.prototype.toUpperCase.call(currentMode))){
					return new errorinfo["a" /* default */]('Invalid channel mode: ' + currentMode, 40000, 400);
				}
			}
		}
	}

	RealtimeChannel.prototype._shouldReattachToSetOptions = function(options) {
		return (this.state === 'attached' || this.state === 'attaching') && (options.params || options.modes);
	};

	RealtimeChannel.prototype.publish = function() {
		var argCount = arguments.length,
			messages = arguments[0],
			callback = arguments[argCount - 1];

		if(typeof(callback) !== 'function') {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
			++argCount;
		}
		if(!this.connectionManager.activeState()) {
			callback(this.connectionManager.getError());
			return;
		}
		if(argCount == 2) {
			if(utils["a" /* default */].isObject(messages))
				messages = [types_message["a" /* default */].fromValues(messages)];
			else if(utils["a" /* default */].isArray(messages))
				messages = types_message["a" /* default */].fromValuesArray(messages);
			else
				throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		} else {
			messages = [types_message["a" /* default */].fromValues({name: arguments[0], data: arguments[1]})];
		}
		var self = this,
			maxMessageSize = this.realtime.options.maxMessageSize;
		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages);
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}
			self._publish(messages, callback);
		});
	};

	RealtimeChannel.prototype._publish = function(messages, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);
		var state = this.state;
		switch(state) {
			case 'failed':
			case 'suspended':
				callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError(state)));
				break;
			default:
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);
				var msg = new protocolmessage["a" /* default */]();
				msg.action = actions.MESSAGE;
				msg.channel = this.name;
				msg.messages = messages;
				this.sendMessage(msg, callback);
				break;
		}
	};

	RealtimeChannel.prototype.onEvent = function(messages) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');
		var subscriptions = this.subscriptions;
		for(var i = 0; i < messages.length; i++) {
			var message = messages[i];
			subscriptions.emit(message.name, message);
		}
	};

	RealtimeChannel.prototype.attach = function(flags, callback) {
		if(typeof(flags) === 'function') {
			callback = flags;
			flags = null;
		}
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'attach', arguments);
			}
			callback = function(err) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}
		if(flags) {
			logger["a" /* default */].deprecated('channel.attach() with flags', 'channel.setOptions() with channelOptions.params');
			/* If flags requested, always do a re-attach. TODO only do this if
			 * current mode differs from requested mode */
			this._requestedFlags = flags;
		} else if (this.state === 'attached') {
			callback();
			return;
		}

		this._attach(false, null, callback);
	};

	RealtimeChannel.prototype._attach = function(forceReattach, attachReason, callback) {
		if(!callback) {
			callback = function(err) {
				if (err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}

		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}

		if (this.state !== 'attaching' || forceReattach) {
			this.requestState('attaching', attachReason);
		}

		this.once(function(stateChange) {
			switch(this.event) {
				case 'attached':
					callback();
					break;
				case 'detached':
				case 'suspended':
				case 'failed':
					callback(stateChange.reason || connectionManager.getError());
					break;
				case 'detaching':
					callback(new errorinfo["a" /* default */]('Attach request superseded by a subsequent detach request', 90000, 409));
					break;
			}
		});
	};

	RealtimeChannel.prototype.attachImpl = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');
		this.setInProgress(statechangeOp, true);
		var attachMsg = protocolmessage["a" /* default */].fromValues({action: actions.ATTACH, channel: this.name, params: this.channelOptions.params});
		if(this._requestedFlags) {
			attachMsg.encodeModesToFlags(this._requestedFlags);
		} else if(this.channelOptions.modes) {
			attachMsg.encodeModesToFlags(utils["a" /* default */].allToUpperCase(this.channelOptions.modes));
		}
		if(this._attachResume) {
			attachMsg.setFlag('ATTACH_RESUME');
		}
		if(this._lastPayload.decodeFailureRecoveryInProgress) {
			attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
		}
		this.sendMessage(attachMsg, noop);
	};

	RealtimeChannel.prototype.detach = function(callback) {
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'detach', arguments);
			}
			callback = noop;
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}
		switch(this.state) {
			case 'detached':
			case 'failed':
				callback();
				break;
			default:
				this.requestState('detaching');
			case 'detaching':
				this.once(function(stateChange) {
					switch(this.event) {
						case 'detached':
							callback();
							break;
						case 'attached':
						case 'suspended':
						case 'failed':
							callback(stateChange.reason || connectionManager.getError());
							break;
						case 'attaching':
							callback(new errorinfo["a" /* default */]('Detach request superseded by a subsequent attach request', 90000, 409));
							break;
					}
				});
		}
	};

	RealtimeChannel.prototype.detachImpl = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');
		this.setInProgress(statechangeOp, true);
		var msg = protocolmessage["a" /* default */].fromValues({action: actions.DETACH, channel: this.name});
		this.sendMessage(msg, (callback || noop));
	};

	RealtimeChannel.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];

		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(this.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);

		return this.attach(callback);
	};

	RealtimeChannel.prototype.unsubscribe = function(/* [event], listener */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	RealtimeChannel.prototype.sync = function() {
		/* check preconditions */
		switch(this.state) {
			case 'initialized':
			case 'detaching':
			case 'detached':
				throw new errorinfo["a" /* default */]("Unable to sync to channel; not attached", 40000);
			default:
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			throw connectionManager.getError();
		}

		/* send sync request */
		var syncMessage = protocolmessage["a" /* default */].fromValues({action: actions.SYNC, channel: this.name});
		if(this.syncChannelSerial) {
			syncMessage.channelSerial = this.syncChannelSerial;
		}
		connectionManager.send(syncMessage);
	};

	RealtimeChannel.prototype.sendMessage = function(msg, callback) {
		this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
	};

	RealtimeChannel.prototype.sendPresence = function(presence, callback) {
		var msg = protocolmessage["a" /* default */].fromValues({
			action: actions.PRESENCE,
			channel: this.name,
			presence: (utils["a" /* default */].isArray(presence) ?
				presencemessage["a" /* default */].fromValuesArray(presence) :
				[presencemessage["a" /* default */].fromValues(presence)])
		});
		this.sendMessage(msg, callback);
	};

	RealtimeChannel.prototype.onMessage = function(message) {
		var syncChannelSerial, isSync = false;
		switch(message.action) {
		case actions.ATTACHED:
			this._attachedMsgIndicator = true;
			this.properties.attachSerial = message.channelSerial;
			this._mode = message.getMode();
			this.params = message.params || {};
			var modesFromFlags = message.decodeModesFromFlags();
			this.modes = (modesFromFlags && utils["a" /* default */].allToLowerCase(modesFromFlags)) || undefined;
			var resumed = message.hasFlag('RESUMED');
			var hasPresence = message.hasFlag('HAS_PRESENCE');
			if(this.state === 'attached') {
				/* attached operations to change options set the inprogress mutex, but leave
				 * channel in the attached state */
				this.setInProgress(statechangeOp, false);
				if(!resumed) {
					/* On a loss of continuity, the presence set needs to be re-synced */
					this.presence.onAttached(hasPresence);
				}
				var change = new channelstatechange(this.state, this.state, resumed, message.error);
				this._allChannelChanges.emit('update', change);
				if(!resumed || this.channelOptions.updateOnAttached) {
					this.emit('update', change);
				}
			} else {
				this.notifyState('attached', message.error, resumed, hasPresence);
			}
			break;

		case actions.DETACHED:
			var err = message.error ? errorinfo["a" /* default */].fromValues(message.error) : new errorinfo["a" /* default */]('Channel detached', 90001, 404);
			if(this.state === 'detaching') {
				this.notifyState('detached', err);
			} else if(this.state === 'attaching') {
				/* Only retry immediately if we were previously attached. If we were
				 * attaching, go into suspended, fail messages, and wait a few seconds
				 * before retrying */
				this.notifyState('suspended', err);
			} else {
				this.requestState('attaching', err);
			}
			break;

		case actions.SYNC:
			/* syncs can have channelSerials, but might not if the sync is one page long */
			isSync = true;
			syncChannelSerial = this.syncChannelSerial = message.channelSerial;
			/* syncs can happen on channels with no presence data as part of connection
			 * resuming, in which case protocol message has no presence property */
			if(!message.presence) break;
		case actions.PRESENCE:
			var presence = message.presence,
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			var options = this.channelOptions;
			for(var i = 0; i < presence.length; i++) {
				try {
					var presenceMsg = presence[i];
					presencemessage["a" /* default */].decode(presenceMsg, options);
				} catch (e) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
				}
				if(!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;
				if(!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;
				if(!presenceMsg.id) presenceMsg.id = id + ':' + i;
			}
			this.presence.setPresence(presence, isSync, syncChannelSerial);
			break;

		case actions.MESSAGE:

			//RTL17
			if(this.state !== 'attached') {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Message "' + message.id + '" skipped as this channel "' + this.name + '" state is not "attached" (state is "' + this.state + '").');
				return;
			}

			var messages = message.messages,
				firstMessage = messages[0],
				lastMessage = messages[messages.length - 1],
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			if(firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {
				var msg = 'Delta message decode failure - previous message not available for message "' + message.id + '" on this channel "' + this.name + '".';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', msg);
				this._startDecodeFailureRecovery(new errorinfo["a" /* default */](msg, 40018, 400));
				break;
			}

			for(var i = 0; i < messages.length; i++) {
				var msg = messages[i];
				try {
					types_message["a" /* default */].decode(msg, this._decodingContext);
				} catch (e) {
					/* decrypt failed .. the most likely cause is that we have the wrong key */
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
					switch(e.code) {
						case 40018:
							/* decode failure */
							this._startDecodeFailureRecovery(e);
							return;
						case 40019:
							/* No vcdiff plugin passed in - no point recovering, give up */
						case 40021:
							/* Browser does not support deltas, similarly no point recovering */
							this.notifyState('failed', e);
							return;
					}
				}
				if(!msg.connectionId) msg.connectionId = connectionId;
				if(!msg.timestamp) msg.timestamp = timestamp;
				if(!msg.id) msg.id = id + ':' + i;
			}
			this._lastPayload.messageId = lastMessage.id;
			this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
			this.onEvent(messages);
			break;

		case actions.ERROR:
			/* there was a channel-specific error */
			var err = message.error;
			if(err && err.code == 80016) {
				/* attach/detach operation attempted on superseded transport handle */
				this.checkPendingState();
			} else {
				this.notifyState('failed', errorinfo["a" /* default */].fromValues(err));
			}
			break;

		default:
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');
			this.connectionManager.abort(connectionerror["a" /* default */].unknownChannelErr);
		}
	};

	RealtimeChannel.prototype._startDecodeFailureRecovery = function(reason) {
		var self = this;
		if(!this._lastPayload.decodeFailureRecoveryInProgress) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Starting decode failure recovery process.');
			this._lastPayload.decodeFailureRecoveryInProgress = true;
			this._attach(true, reason, function() {
				self._lastPayload.decodeFailureRecoveryInProgress = false;
			});
		}
	};

	RealtimeChannel.prototype.onAttached = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);
	};

	RealtimeChannel.prototype.notifyState = function(state, reason, resumed, hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);
		this.clearStateTimer();

		if(state === this.state) {
			return;
		}
		this.presence.actOnChannelState(state, hasPresence, reason);
		if(state === 'suspended' && this.connectionManager.state.sendEvents) {
			this.startRetryTimer();
		} else {
			this.cancelRetryTimer();
		}
		if(reason) {
			this.errorReason = reason;
		}
		var change = new channelstatechange(this.state, state, resumed, reason);
		var logLevel = state === 'failed' ? logger["a" /* default */].LOG_ERROR : logger["a" /* default */].LOG_MAJOR;
		logger["a" /* default */].logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? ('; reason: ' + reason) : ''));

		/* Note: we don't set inProgress for pending states until the request is actually in progress */
		if(state === 'attached') {
			this.onAttached();
			this.setInProgress(syncOp, hasPresence);
			this.setInProgress(statechangeOp, false);
		} else if(state === 'detached' || state === 'failed' || state === 'suspended') {
			this.setInProgress(statechangeOp, false);
			this.setInProgress(syncOp, false);
		}

		if(state === 'attached') {
			this._attachResume = true;
		} else if(state === 'detaching' || state === 'failed') {
			this._attachResume = false;
		}

		this.state = state;
		this._allChannelChanges.emit(state, change);
		this.emit(state, change);
	};

	RealtimeChannel.prototype.requestState = function(state, reason) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);
		this.notifyState(state, reason);
		/* send the event and await response */
		this.checkPendingState();
	};

	RealtimeChannel.prototype.checkPendingState = function() {
		/* if can't send events, do nothing */
		var cmState = this.connectionManager.state;
		/* Allow attach messages to queue up when synchronizing, since this will be
		 * the state we'll be in when upgrade transport.active triggers a checkpendingstate */
		if(!(cmState.sendEvents || cmState.forceQueueEvents)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);
		/* Only start the state timer running when actually sending the event */
		switch(this.state) {
			case 'attaching':
				this.startStateTimerIfNotRunning();
				this.attachImpl();
				break;
			case 'detaching':
				this.startStateTimerIfNotRunning();
				this.detachImpl();
				break;
			case 'attached':
				/* resume any sync operation that was in progress */
				this.sync();
			default:
				break;
		}
	};

	RealtimeChannel.prototype.timeoutPendingState = function() {
		switch(this.state) {
			case 'attaching':
				var err = new errorinfo["a" /* default */]('Channel attach timed out', 90007, 408);
				this.notifyState('suspended', err);
				break;
			case 'detaching':
				var err = new errorinfo["a" /* default */]('Channel detach timed out', 90007, 408);
				this.notifyState('attached', err);
				break;
			default:
				this.checkPendingState();
				break;
		}
	};

	RealtimeChannel.prototype.startStateTimerIfNotRunning = function() {
		var self = this;
		if(!this.stateTimer) {
			this.stateTimer = setTimeout(function() {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');
				self.stateTimer = null;
				self.timeoutPendingState();
			}, this.realtime.options.timeouts.realtimeRequestTimeout);
		}
	};

	RealtimeChannel.prototype.clearStateTimer = function() {
		var stateTimer = this.stateTimer;
		if(stateTimer) {
			clearTimeout(stateTimer);
			this.stateTimer = null;
		}
	};

	RealtimeChannel.prototype.startRetryTimer = function() {
		var self = this;
		if(this.retryTimer) return;

		this.retryTimer = setTimeout(function() {
			/* If connection is not connected, just leave in suspended, a reattach
			 * will be triggered once it connects again */
			if(self.state === 'suspended' && self.connectionManager.state.sendEvents) {
				self.retryTimer = null;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');
				self.requestState('attaching');
			}
		}, this.realtime.options.timeouts.channelRetryTimeout);
	};

	RealtimeChannel.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.suspendTimer = null;
		}
	};

	RealtimeChannel.prototype.setInProgress = function(operation, value) {
		this.rest.channels.setInProgress(this, operation, value);
	};

	RealtimeChannel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.state !== 'attached') {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached", 40000, 400));
				return;
			}
			if(!this.properties.attachSerial) {
				callback(new errorinfo["a" /* default */]("untilAttach was specified and channel is attached, but attachSerial is not defined", 40000, 400));
				return;
			}
			delete params.untilAttach;
			params.from_serial = this.properties.attachSerial;
		}

		client_channel.prototype._history.call(this, params, callback);
	};

	RealtimeChannel.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener);
	}

	/* @returns null (if can safely be released) | ErrorInfo (if cannot) */
	RealtimeChannel.prototype.getReleaseErr = function() {
		var s = this.state;
		if(s === 'initialized' || s === 'detached' || s === 'failed') {
			return null;
		}
		return new errorinfo["a" /* default */]('Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' + s, 90001, 400);
	}

	return RealtimeChannel;
})();

/* harmony default export */ var realtimechannel = (realtimechannel_RealtimeChannel);

// EXTERNAL MODULE: ./common/lib/util/errorreporter.js
var errorreporter = __nested_webpack_require_439809__(23);

// CONCATENATED MODULE: ./common/lib/client/realtime.js










var realtime_Realtime = (function() {

	function Realtime(options) {
		if(!(this instanceof Realtime)){
			return new Realtime(options);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime()', '');
		client_rest.call(this, options);
		this.connection = new connection(this, this.options);
		this.channels = new Channels(this);
		if(options.autoConnect !== false)
			this.connect();
	}
	utils["a" /* default */].inherits(Realtime, client_rest);

	Realtime.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.connect()', '');
		this.connection.connect();
	};

	Realtime.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.close()', '');
		this.connection.close();
	};

	function Channels(realtime) {
		eventemitter["a" /* default */].call(this);
		this.realtime = realtime;
		this.all = {};
		this.inProgress = {};
		var self = this;
		realtime.connection.connectionManager.on('transport.active', function() {
			self.onTransportActive();
		});
	}
	utils["a" /* default */].inherits(Channels, eventemitter["a" /* default */]);

	Channels.prototype.onChannelMessage = function(msg) {
		var channelName = msg.channel;
		if(channelName === undefined) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);
			return;
		}
		var channel = this.all[channelName];
		if(!channel) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);
			return;
		}
		channel.onMessage(msg);
	};

	/* called when a transport becomes connected; reattempt attach/detach
	 * for channels that are attaching or detaching.
	 * Note that this does not use inProgress as inProgress is only channels which have already made
	* at least one attempt to attach/detach */
	Channels.prototype.onTransportActive = function() {
		for(var channelName in this.all) {
			var channel = this.all[channelName];
			if(channel.state === 'attaching' || channel.state === 'detaching') {
				channel.checkPendingState();
			} else if(channel.state === 'suspended') {
				channel.attach();
			}
		}
	};

	Channels.prototype.reattach = function(reason) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			/* NB this should not trigger for merely attaching channels, as they will
			 * be reattached anyway through the onTransportActive checkPendingState */
			if(channel.state === 'attached') {
				channel.requestState('attaching', reason);
			}
		}
	};

	Channels.prototype.resetAttachedMsgIndicators = function() {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached') {
			channel._attachedMsgIndicator = false;
			}
		}
	};

	Channels.prototype.checkAttachedMsgIndicators = function(connectionId) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached' && channel._attachedMsgIndicator === false) {
				var msg = '30s after a resume, found channel which has not received an attached; channelId = ' + channelId + '; connectionId = ' + connectionId;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.checkAttachedMsgIndicators()', msg);
				errorreporter["a" /* default */].report('error', msg, 'channel-no-attached-after-resume');
				channel.requestState('attaching');
			};
		}
	};

	/* Connection interruptions (ie when the connection will no longer queue
	 * events) imply connection state changes for any channel which is either
	 * attached, pending, or will attempt to become attached in the future */
	Channels.prototype.propogateConnectionInterruption = function(connectionState, reason) {
		var connectionStateToChannelState = {
			'closing'  : 'detached',
			'closed'   : 'detached',
			'failed'   : 'failed',
			'suspended': 'suspended'
		};
		var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];
		var toChannelState = connectionStateToChannelState[connectionState];

		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(utils["a" /* default */].arrIn(fromChannelStates, channel.state)) {
				 channel.notifyState(toChannelState, reason);
			}
		}
	};

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			channel = this.all[name] = new realtimechannel(this.realtime, name, channelOptions);
		} else if(channelOptions) {
			if (channel._shouldReattachToSetOptions(channelOptions)) {
				throw new errorinfo["a" /* default */]("Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.", 40000, 400);
			}
			channel.setOptions(channelOptions);
		}
		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			return;
		}
		var releaseErr = channel.getReleaseErr();
		if(releaseErr) {
			throw releaseErr;
		}
		delete this.all[name];
	};

	/* Records operations currently pending on a transport; used by connectionManager to decide when
	 * it's safe to upgrade. Note that a channel might be in the attaching state without any pending
	 * operations (eg if attached while the connection state is connecting) - such a channel must not
	 * hold up an upgrade, so is not considered inProgress.
	 * Operation is currently one of either 'statechange' or 'sync' */
	Channels.prototype.setInProgress = function(channel, operation, inProgress) {
		this.inProgress[channel.name] = this.inProgress[channel.name] || {};
		this.inProgress[channel.name][operation] = inProgress;
		if(!inProgress && this.hasNopending()) {
			this.emit('nopending');
		}
	};

	Channels.prototype.onceNopending = function(listener) {
		if(this.hasNopending()) {
			listener();
			return;
		}
		this.once('nopending', listener);
	};

	Channels.prototype.hasNopending = function() {
		return utils["a" /* default */].arrEvery(utils["a" /* default */].valuesArray(this.inProgress, true), function(operations) {
			return !utils["a" /* default */].containsValue(operations, true);
		});
	};

	return Realtime;
})();

realtime_Realtime.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new realtime_Realtime(options);
};

realtime_Realtime.Callbacks = realtime_Realtime;

/* harmony default export */ var client_realtime = (realtime_Realtime);

// EXTERNAL MODULE: ./browser/lib/util/msgpack.js
var util_msgpack = __nested_webpack_require_439809__(24);

// CONCATENATED MODULE: ./common/lib/index.js














client_rest.Utils = utils["a" /* default */];
client_rest.BufferUtils = bufferutils["a" /* default */];
client_rest.Crypto = util_crypto["a" /* default */];
client_rest.Defaults = defaults["a" /* default */];
client_rest.Http = http["a" /* default */];
client_rest.Resource = client_resource;
client_rest.Message = types_message["a" /* default */];
client_rest.PresenceMessage = presencemessage["a" /* default */];

client_realtime.Utils = utils["a" /* default */];
client_realtime.BufferUtils = bufferutils["a" /* default */];
client_realtime.Crypto = util_crypto["a" /* default */];
client_realtime.Defaults = defaults["a" /* default */];
client_realtime.Http = http["a" /* default */];
client_realtime.Message = types_message["a" /* default */];
client_realtime.PresenceMessage = presencemessage["a" /* default */];
client_realtime.ProtocolMessage = protocolmessage["a" /* default */];
client_realtime.ConnectionManager = connectionmanager["a" /* default */];

/* harmony default export */ var lib = __webpack_exports__["default"] = ({
  Rest: client_rest,
  Realtime: client_realtime,
  msgpack: util_msgpack["a" /* default */]
});


/***/ })
/******/ ])["default"];
});

/***/ }),

/***/ "./node_modules/ably/promises.js":
/*!***************************************!*\
  !*** ./node_modules/ably/promises.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

function promisifyOptions(options) {
  if(typeof options == 'string') {
    options = (options.indexOf(':') == -1) ? {token: options} : {key: options};
  }
  options.promises = true;
  return options;
}

var Ably = __webpack_require__(/*! ./nodejs/index */ "./node_modules/ably/browser/static/ably-commonjs.js");

var RestPromise = function(options) {
  return new Ably.Rest(promisifyOptions(options));
}
Object.assign(RestPromise, Ably.Rest);

var RealtimePromise = function(options) {
  return new Ably.Realtime(promisifyOptions(options));
}
Object.assign(RealtimePromise, Ably.Realtime);

module.exports = {
  Rest: RestPromise,
  Realtime: RealtimePromise
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./components/AblyChatComponent.module.css":
/*!*************************************************!*\
  !*** ./components/AblyChatComponent.module.css ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./AblyChatComponent.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/AblyChatComponent.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = function(element) {
                // These elements should always exist. If they do not,
                // this code should fail.
                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');
                var parentNode = anchorElement.parentNode// Normally <head>
                ;
                // Each style tag should be placed right before our
                // anchor. By inserting before and not after, we do not
                // need to track the last inserted element.
                parentNode.insertBefore(element, anchorElement);
            };
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
    if (!a && b || a && !b) {
        return false;
    }
    let p;
    for(p in a){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (a[p] !== b[p]) {
            return false;
        }
    }
    for(p in b){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (!a[p]) {
            return false;
        }
    }
    return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !!../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./AblyChatComponent.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/AblyChatComponent.module.css",
      function () {
        content = __webpack_require__(/*! !!../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./AblyChatComponent.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/AblyChatComponent.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.id, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

const isOldIE = function isOldIE1() {
    let memo;
    return function memorize() {
        if (typeof memo === 'undefined') {
            // Test for IE <= 9 as proposed by Browserhacks
            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
            // Tests for existence of standard globals is to allow style-loader
            // to operate correctly into non-standard environments
            // @see https://github.com/webpack-contrib/style-loader/issues/177
            memo = Boolean(window && document && document.all && !window.atob);
        }
        return memo;
    };
}();
const getTarget = function getTarget1() {
    const memo = {
    };
    return function memorize(target) {
        if (typeof memo[target] === 'undefined') {
            let styleTarget = document.querySelector(target);
            // Special case to return head of iframe instead of iframe itself
            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
                try {
                    // This will throw an exception if access to iframe is blocked
                    // due to cross-origin restrictions
                    styleTarget = styleTarget.contentDocument.head;
                } catch (e) {
                    // istanbul ignore next
                    styleTarget = null;
                }
            }
            memo[target] = styleTarget;
        }
        return memo[target];
    };
}();
const stylesInDom = [];
function getIndexByIdentifier(identifier) {
    let result = -1;
    for(let i = 0; i < stylesInDom.length; i++){
        if (stylesInDom[i].identifier === identifier) {
            result = i;
            break;
        }
    }
    return result;
}
function modulesToDom(list, options) {
    const idCountMap = {
    };
    const identifiers = [];
    for(let i = 0; i < list.length; i++){
        const item = list[i];
        const id = options.base ? item[0] + options.base : item[0];
        const count = idCountMap[id] || 0;
        const identifier = id + ' ' + count.toString();
        idCountMap[id] = count + 1;
        const index = getIndexByIdentifier(identifier);
        const obj = {
            css: item[1],
            media: item[2],
            sourceMap: item[3]
        };
        if (index !== -1) {
            stylesInDom[index].references++;
            stylesInDom[index].updater(obj);
        } else {
            stylesInDom.push({
                identifier: identifier,
                updater: addStyle(obj, options),
                references: 1
            });
        }
        identifiers.push(identifier);
    }
    return identifiers;
}
function insertStyleElement(options) {
    const style = document.createElement('style');
    const attributes = options.attributes || {
    };
    if (typeof attributes.nonce === 'undefined') {
        const nonce = // eslint-disable-next-line no-undef
         true ? __webpack_require__.nc : 0;
        if (nonce) {
            attributes.nonce = nonce;
        }
    }
    Object.keys(attributes).forEach(function(key) {
        style.setAttribute(key, attributes[key]);
    });
    if (typeof options.insert === 'function') {
        options.insert(style);
    } else {
        const target = getTarget(options.insert || 'head');
        if (!target) {
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
        }
        target.appendChild(style);
    }
    return style;
}
function removeStyleElement(style) {
    // istanbul ignore if
    if (style.parentNode === null) {
        return false;
    }
    style.parentNode.removeChild(style);
}
/* istanbul ignore next  */ const replaceText = function replaceText1() {
    const textStore = [];
    return function replace(index, replacement) {
        textStore[index] = replacement;
        return textStore.filter(Boolean).join('\n');
    };
}();
function applyToSingletonTag(style, index, remove, obj) {
    const css = remove ? '' : obj.media ? '@media ' + obj.media + ' {' + obj.css + '}' : obj.css;
    // For old IE
    /* istanbul ignore if  */ if (style.styleSheet) {
        style.styleSheet.cssText = replaceText(index, css);
    } else {
        const cssNode = document.createTextNode(css);
        const childNodes = style.childNodes;
        if (childNodes[index]) {
            style.removeChild(childNodes[index]);
        }
        if (childNodes.length) {
            style.insertBefore(cssNode, childNodes[index]);
        } else {
            style.appendChild(cssNode);
        }
    }
}
function applyToTag(style, options, obj) {
    let css = obj.css;
    const media = obj.media;
    const sourceMap = obj.sourceMap;
    if (media) {
        style.setAttribute('media', media);
    } else {
        style.removeAttribute('media');
    }
    if (sourceMap && typeof btoa !== 'undefined') {
        css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */';
    }
    // For old IE
    /* istanbul ignore if  */ if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        while(style.firstChild){
            style.removeChild(style.firstChild);
        }
        style.appendChild(document.createTextNode(css));
    }
}
let singleton = null;
let singletonCounter = 0;
function addStyle(obj, options) {
    let style;
    let update;
    let remove;
    if (options.singleton) {
        const styleIndex = singletonCounter++;
        style = singleton || (singleton = insertStyleElement(options));
        update = applyToSingletonTag.bind(null, style, styleIndex, false);
        remove = applyToSingletonTag.bind(null, style, styleIndex, true);
    } else {
        style = insertStyleElement(options);
        update = applyToTag.bind(null, style, options);
        remove = function() {
            removeStyleElement(style);
        };
    }
    update(obj);
    return function updateStyle(newObj) {
        if (newObj) {
            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                return;
            }
            update(obj = newObj);
        } else {
            remove();
        }
    };
}
module.exports = function(list, options) {
    options = options || {
    };
    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
    // tags it will allow on a page
    if (!options.singleton && typeof options.singleton !== 'boolean') {
        options.singleton = isOldIE();
    }
    list = list || [];
    let lastIdentifiers = modulesToDom(list, options);
    return function update(newList) {
        newList = newList || [];
        if (Object.prototype.toString.call(newList) !== '[object Array]') {
            return;
        }
        for(let i = 0; i < lastIdentifiers.length; i++){
            const identifier = lastIdentifiers[i];
            const index = getIndexByIdentifier(identifier);
            stylesInDom[index].references--;
        }
        const newLastIdentifiers = modulesToDom(newList, options);
        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){
            const identifier = lastIdentifiers[i1];
            const index = getIndexByIdentifier(identifier);
            if (stylesInDom[index].references === 0) {
                stylesInDom[index].updater();
                stylesInDom.splice(index, 1);
            }
        }
        lastIdentifiers = newLastIdentifiers;
    };
};

//# sourceMappingURL=injectStylesIntoStyleTag.js.map

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/api.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/compiled/css-loader/api.js ***!
  \***********************************************************/
/***/ (function(module) {

var __dirname = "/";
module.exports=function(){"use strict";var n={762:function(n){n.exports=function(n){var t=[];t.toString=function toString(){return this.map(function(t){var r=cssWithMappingToString(t,n);if(t[2]){return"@media ".concat(t[2]," {").concat(r,"}")}return r}).join("")};t.i=function(n,r,o){if(typeof n==="string"){n=[[null,n,""]]}var e={};if(o){for(var a=0;a<this.length;a++){var c=this[a][0];if(c!=null){e[c]=true}}}for(var i=0;i<n.length;i++){var u=[].concat(n[i]);if(o&&e[u[0]]){continue}if(r){if(!u[2]){u[2]=r}else{u[2]="".concat(r," and ").concat(u[2])}}t.push(u)}};return t};function cssWithMappingToString(n,t){var r=n[1]||"";var o=n[3];if(!o){return r}if(t&&typeof btoa==="function"){var e=toComment(o);var a=o.sources.map(function(n){return"/*# sourceURL=".concat(o.sourceRoot||"").concat(n," */")});return[r].concat(a).concat([e]).join("\n")}return[r].join("\n")}function toComment(n){var t=btoa(unescape(encodeURIComponent(JSON.stringify(n))));var r="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(t);return"/*# ".concat(r," */")}}};var t={};function __nccwpck_require__(r){if(t[r]){return t[r].exports}var o=t[r]={exports:{}};var e=true;try{n[r](o,o.exports,__nccwpck_require__);e=false}finally{if(e)delete t[r]}return o.exports}__nccwpck_require__.ab=__dirname+"/";return __nccwpck_require__(762)}();

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/AblyChatComponent.module.css":
/*!***************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/AblyChatComponent.module.css ***!
  \***************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".AblyChatComponent_chatHolder__1MoPa {\r\n    display: grid;\r\n    grid-template-rows: 1fr 100px;\r\n    -webkit-box-sizing: border-box;\r\n       -moz-box-sizing: border-box;\r\n            box-sizing: border-box;\r\n}\r\n.AblyChatComponent_chatText__1MF-Z {\r\n    display: -moz-box;\r\n    display: flex;\r\n    -moz-box-orient: vertical;\r\n    -moz-box-direction: normal;\r\n         flex-direction: column;\r\n    -moz-box-align: start;\r\n         align-items: flex-start;\r\n    grid-gap: 1em;\r\n    grid-gap: 1em;\r\n    gap: 1em;\r\n    padding: 1em;\r\n    height: -webkit-calc(100vh - 40px - 100px - 100px - 100px);\r\n    height: -moz-calc(100vh - 40px - 100px - 100px - 100px);\r\n    height: calc(100vh - 40px - 100px - 100px - 100px);\r\n    overflow-y: auto;\r\n}\r\n.AblyChatComponent_form__3pfGM {\r\n    display: grid;\r\n    grid-template-columns: 1fr 100px;\r\n    border-top: 1px solid #eee;\r\n}\r\n.AblyChatComponent_textarea__2ubbU {\r\n    padding: 1em;\r\n    border: 0;\r\n    font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;\r\n    font-size: 1.2em;\r\n}\r\n.AblyChatComponent_button__1EraP:disabled{\r\n    color: #fff;\r\n    opacity: .5;\r\n}\r\n.AblyChatComponent_button__1EraP{\r\n    border: 0;\r\n    background: -webkit-gradient(linear,left top, right top,from(#363795),to(#005c97));\r\n    background: -webkit-linear-gradient(left,#363795,#005c97);\r\n    background: -moz-linear-gradient(left,#363795,#005c97);\r\n    background: linear-gradient(90deg,#363795,#005c97);\r\n    font-weight: 700;\r\n    font-size: 1.4em;\r\n}\r\n.AblyChatComponent_message__36v1F{\r\n    background-color: #eef5f8;\r\n    padding: 1em;\r\n    border-radius: 10px;\r\n    -moz-box-flex: 0;\r\n         flex-grow: 0;\r\n}\r\n.AblyChatComponent_message__36v1F.AblyChatComponent_data__2CdQ3{\r\n    background-color: #eef5f8;\r\n    padding: 1em;\r\n    border-radius: 10px;\r\n        border-bottom-right-radius: 10px;\r\n    -moz-box-flex: 0;\r\n         flex-grow: 0;\r\n}", "",{"version":3,"sources":["webpack://components/AblyChatComponent.module.css"],"names":[],"mappings":"AAAA;IACI,aAAa;IACb,6BAA6B;IAC7B,8BAAsB;OAAtB,2BAAsB;YAAtB,sBAAsB;AAC1B;AACA;IACI,iBAAa;IAAb,aAAa;IACb,yBAAsB;IAAtB,0BAAsB;SAAtB,sBAAsB;IACtB,qBAAuB;SAAvB,uBAAuB;IACvB,aAAa;IACb,aAAQ;IAAR,QAAQ;IACR,YAAY;IACZ,0DAAkD;IAAlD,uDAAkD;IAAlD,kDAAkD;IAClD,gBAAgB;AACpB;AACA;IACI,aAAa;IACb,gCAAgC;IAChC,0BAA0B;AAC9B;AACA;IACI,YAAY;IACZ,SAAS;IACT,oIAAoI;IACpI,gBAAgB;AACpB;AACA;IACI,WAAW;IACX,WAAW;AACf;AACA;IACI,SAAS;IACT,kFAAkD;IAAlD,yDAAkD;IAAlD,sDAAkD;IAAlD,kDAAkD;IAClD,gBAAgB;IAChB,gBAAgB;AACpB;AACA;IACI,yBAAyB;IACzB,YAAY;IACZ,mBAAmB;IACnB,gBAAY;SAAZ,YAAY;AAChB;AACA;IACI,yBAAyB;IACzB,YAAY;IACZ,mBAAmB;QACf,gCAAgC;IACpC,gBAAY;SAAZ,YAAY;AAChB","sourcesContent":[".chatHolder {\r\n    display: grid;\r\n    grid-template-rows: 1fr 100px;\r\n    box-sizing: border-box;\r\n}\r\n.chatText {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: flex-start;\r\n    grid-gap: 1em;\r\n    gap: 1em;\r\n    padding: 1em;\r\n    height: calc(100vh - 40px - 100px - 100px - 100px);\r\n    overflow-y: auto;\r\n}\r\n.form {\r\n    display: grid;\r\n    grid-template-columns: 1fr 100px;\r\n    border-top: 1px solid #eee;\r\n}\r\n.textarea {\r\n    padding: 1em;\r\n    border: 0;\r\n    font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;\r\n    font-size: 1.2em;\r\n}\r\n.button:disabled{\r\n    color: #fff;\r\n    opacity: .5;\r\n}\r\n.button{\r\n    border: 0;\r\n    background: linear-gradient(90deg,#363795,#005c97);\r\n    font-weight: 700;\r\n    font-size: 1.4em;\r\n}\r\n.message{\r\n    background-color: #eef5f8;\r\n    padding: 1em;\r\n    border-radius: 10px;\r\n    flex-grow: 0;\r\n}\r\n.message.data{\r\n    background-color: #eef5f8;\r\n    padding: 1em;\r\n    border-radius: 10px;\r\n        border-bottom-right-radius: 10px;\r\n    flex-grow: 0;\r\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"chatHolder": "AblyChatComponent_chatHolder__1MoPa",
	"chatText": "AblyChatComponent_chatText__1MF-Z",
	"form": "AblyChatComponent_form__3pfGM",
	"textarea": "AblyChatComponent_textarea__2ubbU",
	"button": "AblyChatComponent_button__1EraP",
	"message": "AblyChatComponent_message__36v1F",
	"data": "AblyChatComponent_data__2CdQ3"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayLikeToArray; }
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithHoles; }
/* harmony export */ });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithoutHoles; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__.default)(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArray; }
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArrayLimit; }
/* harmony export */ });
function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableRest; }
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableSpread; }
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _slicedToArray; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayWithHoles */ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _babel_runtime_helpers_esm_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_nonIterableRest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/nonIterableRest */ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(arr, i) {
  return (0,_babel_runtime_helpers_esm_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_babel_runtime_helpers_esm_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__.default)(arr, i) || (0,_babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__.default)(arr, i) || (0,_babel_runtime_helpers_esm_nonIterableRest__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _toConsumableArray; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/iterableToArray */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/nonIterableSpread */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return (0,_babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__.default)(arr) || (0,_babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__.default)(arr) || (0,_babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _unsupportedIterableToArray; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
}

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGljL2NodW5rcy9jb21wb25lbnRzX0FibHlDaGF0Q29tcG9uZW50X2pzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBLElBQU1LLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBb0IsR0FBTTtBQUFBOztBQUU1QixNQUFJQyxRQUFRLEdBQUcsSUFBZjtBQUNBLE1BQUlDLFVBQVUsR0FBRyxJQUFqQjs7QUFINEIsa0JBSVVMLCtDQUFRLENBQUMsRUFBRCxDQUpsQjtBQUFBLE1BSXJCTSxXQUpxQjtBQUFBLE1BSVJDLGNBSlEsaUJBSXdCOzs7QUFKeEIsbUJBS1lQLCtDQUFRLENBQUMsRUFBRCxDQUxwQjtBQUFBLE1BS3JCUSxnQkFMcUI7QUFBQSxNQUtIQyxXQUxHLGtCQUswQjs7O0FBQ3RELE1BQU1DLGtCQUFrQixHQUFHSixXQUFXLENBQUNLLElBQVosR0FBbUJDLE1BQW5CLEtBQThCLENBQXpELENBTjRCLENBTWdDOztBQU5oQyxvQkFRSlgsNERBQVUsQ0FBQyxXQUFELEVBQWMsVUFBQ1ksT0FBRCxFQUFhO0FBQ3pEO0FBQ0E7QUFFQSxRQUFNQyxPQUFPLEdBQUdOLGdCQUFnQixDQUFDTyxLQUFqQixDQUF1QixDQUFDLEdBQXhCLENBQWhCO0FBQ0FOLElBQUFBLFdBQVcsNkpBQUtLLE9BQUwsSUFBY0QsT0FBZCxHQUFYLENBTHlELENBT3pEO0FBQ0E7QUFDQTtBQUNILEdBVmlDLENBUk47QUFBQTtBQUFBLE1BUXJCRyxPQVJxQjtBQUFBLE1BUVpDLElBUlk7O0FBb0I1QixNQUFNQyxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQUNaLFdBQUQsRUFBaUI7QUFBRTtBQUN2Q1UsSUFBQUEsT0FBTyxDQUFDRyxPQUFSLENBQWdCO0FBQUVDLE1BQUFBLElBQUksRUFBRSxjQUFSO0FBQXdCQyxNQUFBQSxJQUFJLEVBQUVmO0FBQTlCLEtBQWhCO0FBQ0FDLElBQUFBLGNBQWMsQ0FBQyxFQUFELENB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLCtDQUErQztBQUNoRjtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQSxrQkFBa0IsaUNBQW1CO0FBQ3JDLHVDQUF1QyxpQ0FBbUI7O0FBRTFEO0FBQ0EsaUJBQWlCLGlDQUFtQjs7QUFFcEM7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0lBQWdJLGFBQWE7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxzREFB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEpBQTBKLFNBQVM7QUFDbks7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BELEtBQUs7QUFDTCxLQUFLO0FBQ0wsZ0RBQWdELFlBQVk7QUFDNUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVHQUF1RztBQUN2Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2TEFBNkw7QUFDN0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QjtBQUNoRyx1RUFBdUUsaUNBQW1COzs7Ozs7Ozs7OztBQVcxRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyTkFBMk47QUFDM047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSw0QkFBNEIsWUFBWSxpQ0FBbUI7O0FBRTNELE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELENBQUM7QUFDRCxLQUFLLElBQUk7QUFDVDtBQUNBLHFDQUFxQyxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUI7QUFDbFQ7QUFD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ckcsZ0ZBQWdGLGlDQUFtQjs7Ozs7Ozs7OztBQVVuRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSw4QkFBOEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLDhIQUE4SDtBQUM5SDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIOztBQUV2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVJQUF1STtBQUN2STtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxTUFBcU07QUFDck07O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0Esb0JBQW9CLGlDQUFtQjs7QUFFdkM7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2ZlO0FBQ2Y7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNSZTtBQUNmO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGMkU7QUFDNUQ7QUFDZixpQ0FBaUMsb0ZBQWdCO0FBQ2pEOzs7Ozs7Ozs7Ozs7Ozs7QUNIZTtBQUNmO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0ZlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QywrQkFBK0I7QUFDN0U7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3pCZTtBQUNmO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0ZlO0FBQ2Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0Z1RTtBQUNZO0FBQ1k7QUFDdEI7QUFDMUQ7QUFDZixTQUFTLGtGQUFjLFNBQVMsd0ZBQW9CLFlBQVksOEZBQTBCLFlBQVksbUZBQWU7QUFDckg7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNONkU7QUFDSjtBQUNzQjtBQUNsQjtBQUM5RDtBQUNmLFNBQVMscUZBQWlCLFNBQVMsbUZBQWUsU0FBUyw4RkFBMEIsU0FBUyxxRkFBaUI7QUFDL0c7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOMkU7QUFDNUQ7QUFDZjtBQUNBLG9DQUFvQyxvRkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLG9GQUFnQjtBQUN0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0FibHlDaGF0Q29tcG9uZW50LmpzeCIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BYmx5UmVhY3RFZmZlY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L2Jyb3dzZXIvc3RhdGljL2FibHktY29tbW9uanMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L3Byb21pc2VzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9BYmx5Q2hhdENvbXBvbmVudC5tb2R1bGUuY3NzPzMwODAiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzIiwid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL0FibHlDaGF0Q29tcG9uZW50Lm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgdXNlQ2hhbm5lbCB9IGZyb20gXCIuL0FibHlSZWFjdEVmZmVjdFwiO1xyXG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQWJseUNoYXRDb21wb25lbnQubW9kdWxlLmNzcyc7XHJcblxyXG5jb25zdCBBYmx5Q2hhdENvbXBvbmVudCA9ICgpID0+IHtcclxuXHJcbiAgICBsZXQgaW5wdXRCb3ggPSBudWxsO1xyXG4gICAgbGV0IG1lc3NhZ2VFbmQgPSBudWxsO1xyXG4gICAgY29uc3QgW21lc3NhZ2VUZXh0LCBzZXRNZXNzYWdlVGV4dF0gPSB1c2VTdGF0ZShcIlwiKTsgLy8gYm91bmQgdG8gdGhlIHRleHQgYXJlYSB3aGVyZSBtZXNzYWdlcyBjYW4gYmUgdHlwZWRcclxuICAgIGNvbnN0IFtyZWNlaXZlZE1lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZShbXSk7IC8vTWVzc2FnZSBoaXN0b3J5IG9uIHNjcmVlblxyXG4gICAgY29uc3QgbWVzc2FnZVRleHRJc0VtcHR5ID0gbWVzc2FnZVRleHQudHJpbSgpLmxlbmd0aCA9PT0gMDsgLy9EaXNhYmxlIHRoZSBzZW5kIGJ1dHRvbiB3aGVuIHRleHQgaXMgZW1wdHlcclxuXHJcbiAgICBjb25zdCBbY2hhbm5lbCwgYWJseV0gPSB1c2VDaGFubmVsKFwiY2hhdC1kZW1vXCIsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgLy8gSGVyZSB3ZSdyZSBjb21wdXRpbmcgdGhlIHN0YXRlIHRoYXQnbGwgYmUgZHJhd24gaW50byB0aGUgbWVzc2FnZSBoaXN0b3J5XHJcbiAgICAgICAgLy8gV2UgZG8gdGhhdCBieSBzbGljaW5nIHRoZSBsYXN0IDE5OSBtZXNzYWdlcyBmcm9tIHRoZSByZWNlaXZlZE1lc3NhZ2VzIGJ1ZmZlclxyXG5cclxuICAgICAgICBjb25zdCBoaXN0b3J5ID0gcmVjZWl2ZWRNZXNzYWdlcy5zbGljZSgtMTk5KTtcclxuICAgICAgICBzZXRNZXNzYWdlcyhbLi4uaGlzdG9yeSwgbWVzc2FnZV0pO1xyXG5cclxuICAgICAgICAvLyBUaGVuIGZpbmFsbHksIHdlIHRha2UgdGhlIG1lc3NhZ2UgaGlzdG9yeSwgYW5kIGNvbWJpbmUgaXQgd2l0aCB0aGUgbmV3IG1lc3NhZ2VcclxuICAgICAgICAvLyBUaGlzIG1lYW5zIHdlJ2xsIGFsd2F5cyBoYXZlIHVwIHRvIDE5OSBtZXNzYWdlICsgMSBuZXcgbWVzc2FnZSwgc3RvcmVkIHVzaW5nIHRoZVxyXG4gICAgICAgIC8vIHNldE1lc3NhZ2VzIHJlYWN0IHVzZVN0YXRlIGhvb2tcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHNlbmRDaGF0TWVzc2FnZSA9IChtZXNzYWdlVGV4dCkgPT4geyAvL3Jlc3Bvc2libGUgZm9yIHB1Ymxpc2hpbmcgbmV3IG1lc3NhZ2VzXHJcbiAgICAgICAgY2hhbm5lbC5wdWJsaXNoKHsgbmFtZTogXCJjaGF0LW1lc3NhZ2VcIiwgZGF0YTogbWVzc2FnZVRleHQgfSk7XHJcbiAgICAgICAgc2V0TWVzc2FnZVRleHQoXCJcIik7XHJcbiAgICAgICAgaW5wdXRCb3guZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVGb3JtU3VibWlzc2lvbiA9IChldmVudCkgPT4geyAvL1doZW4gdHJpZ2dlcmVkIHdoZW4gdGhlIHN1Ym1pdCBodXR0b24gaXMgY2xpY2tlZCBjYWxscyBzZW5kIG1lc3NhZ2UgdG8gcHJldmVudCB0aGUgcGFnZSBmb3IgcmVsb2FkaW5nXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBzZW5kQ2hhdE1lc3NhZ2UobWVzc2FnZVRleHQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaGFuZGxlS2V5UHJlc3MgPSAoZXZlbnQpID0+IHsgLy9tYWtlcyBzdXJlIHRoYXQgaWYgdGhlIHVzZXIgcHJlc3NlcyBlbnRlciB0aGUgc2VuZGNoYXRtZXNzYWdlIGlzIHRyaWdnZXJlZFxyXG4gICAgICAgIGlmIChldmVudC5jaGFyQ29kZSAhPT0gMTMgfHwgbWVzc2FnZVRleHRJc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2VuZENoYXRNZXNzYWdlKG1lc3NhZ2VUZXh0KTtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWVzc2FnZXMgPSByZWNlaXZlZE1lc3NhZ2VzLm1hcCgobWVzc2FnZSwgaW5kZXgpID0+IHsgLy9XaWxsIGRpc3BsYXkgbWVzc2FnZXMgdGhhdCBhcmUgc2VudFxyXG4gICAgICAgIGNvbnN0IGF1dGhvciA9IG1lc3NhZ2UuY29ubmVjdGlvbklkID09PSBhYmx5LmNvbm5lY3Rpb24uaWQgPyBcIm1lXCIgOiBcIm90aGVyXCI7XHJcbiAgICAgICAgcmV0dXJuIDxzcGFuIGtleT17aW5kZXh9IGNsYXNzTmFtZT17c3R5bGVzLm1lc3NhZ2V9IGRhdGEtYXV0aG9yPXthdXRob3J9PnttZXNzYWdlLmRhdGF9PC9zcGFuPjtcclxuICAgIH0pO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgbWVzc2FnZUVuZC5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW91cjogXCJzbW9vdGhcIiB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNoYXRIb2xkZXJ9PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNoYXRUZXh0fT5cclxuICAgICAgICAgICAgICAgIHttZXNzYWdlc31cclxuICAgICAgICAgICAgICAgIDxkaXYgcmVmPXsoZWxlbWVudCkgPT4geyBtZXNzYWdlRW5kID0gZWxlbWVudDsgfX0+PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlRm9ybVN1Ym1pc3Npb259IGNsYXNzTmFtZT17c3R5bGVzLmZvcm19PlxyXG4gICAgICAgICAgICAgICAgPHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgcmVmPXsoZWxlbWVudCkgPT4geyBpbnB1dEJveCA9IGVsZW1lbnQ7IH19XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e21lc3NhZ2VUZXh0fVxyXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVHlwZSBhIG1lc3NhZ2UuLi5cIlxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldE1lc3NhZ2VUZXh0KGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICBvbktleVByZXNzPXtoYW5kbGVLZXlQcmVzc31cclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy50ZXh0YXJlYX1cclxuICAgICAgICAgICAgICAgID48L3RleHRhcmVhPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3NOYW1lPXtzdHlsZXMuYnV0dG9ufSBkaXNhYmxlZD17bWVzc2FnZVRleHRJc0VtcHR5fT5TZW5kPC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQWJseUNoYXRDb21wb25lbnQ7IiwiaW1wb3J0IEFibHkgZnJvbSBcImFibHkvcHJvbWlzZXNcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXHJcblxyXG5jb25zdCBhYmx5ID0gbmV3IEFibHkuUmVhbHRpbWUuUHJvbWlzZSh7IGF1dGhVcmw6ICcvYXBpL2NyZWF0ZVRva2VuUmVxdWVzdCcgfSk7XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYW5uZWwoY2hhbm5lbE5hbWUsIGNhbGxiYWNrT25NZXNzYWdlKSB7XHJcbiAgICBjb25zdCBjaGFubmVsID0gYWJseS5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xyXG5cclxuICAgIGNvbnN0IG9uTW91bnQgPSAoKSA9PiB7XHJcbiAgICAgICAgY2hhbm5lbC5zdWJzY3JpYmUobXNnID0+IHsgY2FsbGJhY2tPbk1lc3NhZ2UobXNnKTsgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25Vbm1vdW50ID0gKCkgPT4ge1xyXG4gICAgICAgIGNoYW5uZWwudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1c2VFZmZlY3RIb29rID0gKCkgPT4ge1xyXG4gICAgICAgIG9uTW91bnQoKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4geyBvblVubW91bnQoKTsgfTtcclxuICAgIH07XHJcblxyXG4gICAgdXNlRWZmZWN0KHVzZUVmZmVjdEhvb2spO1xyXG5cclxuICAgIHJldHVybiBbY2hhbm5lbCwgYWJseV07XHJcbn1cclxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAyMCwgQWJseVxuICogXG4gKiBBYmx5IEphdmFTY3JpcHQgTGlicmFyeSB2MS4yLjRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanNcbiAqIFxuICogQWJseSBSZWFsdGltZSBNZXNzYWdpbmdcbiAqIGh0dHBzOi8vd3d3LmFibHkuaW9cbiAqIFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbmNlIHYyLjBcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQWJseVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJBYmx5XCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDQ3KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cbnZhciBMb2dnZXIgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBjb25zb2xlTG9nZ2VyLCBlcnJvckxvZ2dlcjtcblxuXHQvKiBDYW4ndCBqdXN0IGNoZWNrIGZvciBjb25zb2xlICYmIGNvbnNvbGUubG9nOyBmYWlscyBpbiBJRSA8PTkgKi9cblx0aWYoKHR5cGVvZiBXaW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcpIC8qIG5vZGUgKi8gfHxcblx0XHQgKGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlLmxvZyAmJiAodHlwZW9mIGdsb2JhbC5jb25zb2xlLmxvZy5hcHBseSA9PT0gJ2Z1bmN0aW9uJykpIC8qIHNlbnNpYmxlIGJyb3dzZXJzICovKSB7XG5cdFx0Y29uc29sZUxvZ2dlciA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpOyB9O1xuXHRcdGVycm9yTG9nZ2VyID0gY29uc29sZS53YXJuID8gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpOyB9IDogY29uc29sZUxvZ2dlcjtcblx0fSBlbHNlIGlmKGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlLmxvZykge1xuXHRcdC8qIElFIDw9IDkgd2l0aCB0aGUgY29uc29sZSBvcGVuIC0tIGNvbnNvbGUubG9nIGRvZXMgbm90XG5cdFx0ICogaW5oZXJpdCBmcm9tIEZ1bmN0aW9uLCBzbyBoYXMgbm8gYXBwbHkgbWV0aG9kICovXG5cdFx0Y29uc29sZUxvZ2dlciA9IGVycm9yTG9nZ2VyID0gZnVuY3Rpb24oKSB7IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpOyB9O1xuXHR9IGVsc2Uge1xuXHRcdC8qIElFIDw9IDkgd2hlbiBkZXYgdG9vbHMgYXJlIGNsb3NlZCAtIHdpbmRvdy5jb25zb2xlIG5vdCBldmVuIGRlZmluZWQgKi9cblx0XHRjb25zb2xlTG9nZ2VyID0gZXJyb3JMb2dnZXIgPSBmdW5jdGlvbigpIHt9O1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFkKHN0ciwgdGhyZWUpIHtcblx0XHRyZXR1cm4gKCcwMDAnICsgc3RyKS5zbGljZSgtMi0odGhyZWUgfHwgMCkpO1xuXHR9XG5cblx0dmFyIExPR19OT05FICA9IDAsXG5cdExPR19FUlJPUiA9IDEsXG5cdExPR19NQUpPUiA9IDIsXG5cdExPR19NSU5PUiA9IDMsXG5cdExPR19NSUNSTyA9IDQ7XG5cblx0dmFyIExPR19ERUZBVUxUID0gTE9HX0VSUk9SLFxuXHRMT0dfREVCVUcgICA9IExPR19NSUNSTztcblxuXHR2YXIgbG9nTGV2ZWwgPSBMT0dfREVGQVVMVDtcblxuXHRmdW5jdGlvbiBnZXRIYW5kbGVyKGxvZ2dlcikge1xuXHRcdHJldHVybiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ1RpbWVzdGFtcHMgP1xuXHRcdFx0ZnVuY3Rpb24obXNnKSB7XG5cdFx0XHRcdHZhciB0aW1lID0gbmV3IERhdGUoKTtcblx0XHRcdFx0bG9nZ2VyKHBhZCh0aW1lLmdldEhvdXJzKCkpICsgJzonICsgcGFkKHRpbWUuZ2V0TWludXRlcygpKSArICc6JyArIHBhZCh0aW1lLmdldFNlY29uZHMoKSkgKyAnLicgKyBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgdHJ1ZSkgKyAnICcgKyBtc2cpO1xuXHRcdFx0fSA6IGxvZ2dlcjtcblx0fVxuXG5cdHZhciBsb2dIYW5kbGVyID0gZ2V0SGFuZGxlcihjb25zb2xlTG9nZ2VyKSxcblx0XHRsb2dFcnJvckhhbmRsZXIgPSBnZXRIYW5kbGVyKGVycm9yTG9nZ2VyKTtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gTG9nZ2VyKGFyZ3MpIHt9XG5cblx0LyogcHVibGljIGNvbnN0YW50cyAqL1xuXHRMb2dnZXIuTE9HX05PTkUgICAgPSBMT0dfTk9ORSxcblx0TG9nZ2VyLkxPR19FUlJPUiAgID0gTE9HX0VSUk9SLFxuXHRMb2dnZXIuTE9HX01BSk9SICAgPSBMT0dfTUFKT1IsXG5cdExvZ2dlci5MT0dfTUlOT1IgICA9IExPR19NSU5PUixcblx0TG9nZ2VyLkxPR19NSUNSTyAgID0gTE9HX01JQ1JPO1xuXG5cdExvZ2dlci5MT0dfREVGQVVMVCA9IExPR19ERUZBVUxULFxuXHRMb2dnZXIuTE9HX0RFQlVHICAgPSBMT0dfREVCVUc7XG5cblx0LyogcHVibGljIHN0YXRpYyBmdW5jdGlvbnMgKi9cblx0TG9nZ2VyLmxvZ0FjdGlvbiA9IGZ1bmN0aW9uKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcblx0XHRpZiAoTG9nZ2VyLnNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRcdChsZXZlbCA9PT0gTE9HX0VSUk9SID8gbG9nRXJyb3JIYW5kbGVyIDogbG9nSGFuZGxlcikoJ0FibHk6ICcgKyBhY3Rpb24gKyAnOiAnICsgbWVzc2FnZSk7XG5cdFx0fVxuXHR9O1xuXG5cdExvZ2dlci5kZXByZWNhdGVkID0gZnVuY3Rpb24ob3JpZ2luYWwsIHJlcGxhY2VtZW50KSB7XG5cdFx0TG9nZ2VyLmRlcHJlY2F0ZWRXaXRoTXNnKG9yaWdpbmFsLCBcIlBsZWFzZSB1c2UgJ1wiICsgcmVwbGFjZW1lbnQgKyBcIicgaW5zdGVhZC5cIik7XG5cdH1cblxuXHRMb2dnZXIuZGVwcmVjYXRlZFdpdGhNc2cgPSBmdW5jdGlvbihmdW5jTmFtZSwgbXNnKSB7XG5cdFx0aWYgKExvZ2dlci5zaG91bGRMb2coTE9HX0VSUk9SKSkge1xuXHRcdFx0bG9nRXJyb3JIYW5kbGVyKFwiQWJseTogRGVwcmVjYXRpb24gd2FybmluZyAtICdcIiArIGZ1bmNOYW1lICsgXCInIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGEgZnV0dXJlIHZlcnNpb24uIFwiICsgbXNnKTtcblx0XHR9XG5cdH1cblxuXHQvKiBXaGVyZSBhIGxvZ2dpbmcgb3BlcmF0aW9uIGlzIGV4cGVuc2l2ZSwgc3VjaCBhcyBzZXJpYWxpc2F0aW9uIG9mIGRhdGEsIHVzZSBzaG91bGRMb2cgd2lsbCBwcmV2ZW50XG5cdCAgIHRoZSBvYmplY3QgYmVpbmcgc2VyaWFsaXNlZCBpZiB0aGUgbG9nIGxldmVsIHdpbGwgbm90IG91dHB1dCB0aGUgbWVzc2FnZSAqL1xuXHRMb2dnZXIuc2hvdWxkTG9nID0gZnVuY3Rpb24obGV2ZWwpIHtcblx0XHRyZXR1cm4gbGV2ZWwgPD0gbG9nTGV2ZWw7XG5cdH07XG5cblx0TG9nZ2VyLnNldExvZyA9IGZ1bmN0aW9uKGxldmVsLCBoYW5kbGVyKSB7XG5cdFx0aWYobGV2ZWwgIT09IHVuZGVmaW5lZCkgbG9nTGV2ZWwgPSBsZXZlbDtcblx0XHRpZihoYW5kbGVyICE9PSB1bmRlZmluZWQpIGxvZ0hhbmRsZXIgPSBsb2dFcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xuXHR9O1xuXG5cdHJldHVybiBMb2dnZXI7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKExvZ2dlcik7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSkpXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblxuXG5cbnZhciBVdGlscyA9IChmdW5jdGlvbigpIHtcblx0dmFyIG1zZ3BhY2sgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1zZ3BhY2s7XG5cblx0ZnVuY3Rpb24gVXRpbHMoKSB7fVxuXG5cdGZ1bmN0aW9uIHJhbmRvbVBvc24oYXJyT3JTdHIpIHtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyT3JTdHIubGVuZ3RoKTtcblx0fVxuXG5cdC8qXG5cdCAqIEFkZCBhIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGEgdGFyZ2V0IG9iamVjdFxuXHQgKiB0YXJnZXQ6IHRoZSB0YXJnZXQgb2JqZWN0XG5cdCAqIHByb3BzOiAgYW4gb2JqZWN0IHdob3NlIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmVcblx0ICogICAgICAgICBhZGRlZCwgYnkgcmVmZXJlbmNlIG9ubHlcblx0ICovXG5cdFV0aWxzLm1peGluID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0Zm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmKCFzb3VyY2UpIHsgYnJlYWs7IH1cblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IHNvdXJjZS5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvcih2YXIga2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHRpZighaGFzT3duUHJvcGVydHkgfHwgaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0Lypcblx0ICogQWRkIGEgc2V0IG9mIHByb3BlcnRpZXMgdG8gYSB0YXJnZXQgb2JqZWN0XG5cdCAqIHRhcmdldDogdGhlIHRhcmdldCBvYmplY3Rcblx0ICogcHJvcHM6ICBhbiBvYmplY3Qgd2hvc2UgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZVxuXHQgKiAgICAgICAgIGFkZGVkLCBieSByZWZlcmVuY2Ugb25seVxuXHQgKi9cblx0VXRpbHMuY29weSA9IGZ1bmN0aW9uKHNyYykge1xuXHRcdHJldHVybiBVdGlscy5taXhpbih7fSwgc3JjKTtcblx0fTtcblxuXHQvKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBnaXZlbiBvYmplY3QgaXNcblx0ICogYW4gYXJyYXkuXG5cdCAqL1xuXHRVdGlscy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYikge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2IpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cblx0Lypcblx0ICogRW5zdXJlcyB0aGF0IGFuIEFycmF5IG9iamVjdCBpcyBhbHdheXMgcmV0dXJuZWRcblx0ICogcmV0dXJuaW5nIHRoZSBvcmlnaW5hbCBBcnJheSBvZiBvYmogaXMgYW4gQXJyYXlcblx0ICogZWxzZSB3cmFwcGluZyB0aGUgb2JqIGluIGEgc2luZ2xlIGVsZW1lbnQgQXJyYXlcblx0ICovXG5cdFV0aWxzLmVuc3VyZUFycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYoVXRpbHMuaXNFbXB0eUFyZyhvYmopKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdGlmKFV0aWxzLmlzQXJyYXkob2JqKSkge1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9XG5cdFx0cmV0dXJuIFtvYmpdO1xuXHR9XG5cblx0LyogLi4uT3IgYW4gT2JqZWN0IChpbiB0aGUgbmFycm93IHNlbnNlKSAqL1xuXHRVdGlscy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYikgPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdH07XG5cblx0Lypcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBjb250YWluc1xuXHQgKiBhbnkgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuXHQgKiBvYjogdGhlIG9iamVjdFxuXHQgKi9cblx0VXRpbHMuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iKSB7XG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdFV0aWxzLmlzT25seVByb3BJbiA9IGZ1bmN0aW9uKG9iLCBwcm9wZXJ0eSkge1xuXHRcdGZvcih2YXIgcHJvcCBpbiBvYikge1xuXHRcdFx0aWYocHJvcCAhPT0gcHJvcGVydHkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gYXJndW1lbnQgdG8gYW4gb3ZlcmxvYWRlZCBmdW5jdGlvbiBpc1xuXHQgKiB1bmRlZmluZWQgKG1pc3NpbmcpIG9yIG51bGwuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIGNvbnN0cnVjdGluZyBmdW5jdGlvbnMgc3VjaCBhcyAoV2ViSURMIHRlcm1pbm9sb2d5KTpcblx0ICogICBvZmYoW1RyZWF0VW5kZWZpbmVkQXM9TnVsbF0gRE9NU3RyaW5nPyBldmVudClcblx0ICogYXMgeW91IGNhbiB0aGVuIGNvbmZpcm0gdGhlIGFyZ3VtZW50IHVzaW5nOlxuXHQgKiAgIFV0aWxzLmlzRW1wdHlBcmcoZXZlbnQpXG5cdCAqL1xuXG5cdFV0aWxzLmlzRW1wdHlBcmcgPSBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gYXJnID09PSBudWxsIHx8IGFyZyA9PT0gdW5kZWZpbmVkO1xuXHR9XG5cblx0Lypcblx0ICogUGVyZm9ybSBhIHNpbXBsZSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdC5cblx0ICogUmVzdWx0IGlzIGFuIG9iamVjdCBpcnJlc3BlY3RpdmUgb2Ygd2hldGhlclxuXHQgKiB0aGUgaW5wdXQgaXMgYW4gb2JqZWN0IG9yIGFycmF5LiBBbGxcblx0ICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQuXG5cdCAqIG9iOiB0aGUgb2JqZWN0XG5cdCAqL1xuXHRVdGlscy5zaGFsbG93Q2xvbmUgPSBmdW5jdGlvbihvYikge1xuXHRcdHZhciByZXN1bHQgPSBuZXcgT2JqZWN0KCk7XG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKVxuXHRcdFx0cmVzdWx0W3Byb3BdID0gb2JbcHJvcF07XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKlxuXHQgKiBDbG9uZSBhbiBvYmplY3QgYnkgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHdpdGggdGhlXG5cdCAqIGdpdmVuIG9iamVjdCBhcyBpdHMgcHJvdG90eXBlLiBPcHRpb25hbGx5XG5cdCAqIGEgc2V0IG9mIGFkZGl0aW9uYWwgb3duIHByb3BlcnRpZXMgY2FuIGJlXG5cdCAqIHN1cHBsaWVkIHRvIGJlIGFkZGVkIHRvIHRoZSBuZXdseSBjcmVhdGVkIGNsb25lLlxuXHQgKiBvYjogICAgICAgICAgICB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuXHQgKiBvd25Qcm9wZXJ0aWVzOiBvcHRpb25hbCBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsXG5cdCAqICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgdG8gYWRkXG5cdCAqL1xuXHRVdGlscy5wcm90b3R5cGljYWxDbG9uZSA9IGZ1bmN0aW9uKG9iLCBvd25Qcm9wZXJ0aWVzKSB7XG5cdFx0ZnVuY3Rpb24gRigpIHt9XG5cdFx0Ri5wcm90b3R5cGUgPSBvYjtcblx0XHR2YXIgcmVzdWx0ID0gbmV3IEYoKTtcblx0XHRpZihvd25Qcm9wZXJ0aWVzKVxuXHRcdFx0VXRpbHMubWl4aW4ocmVzdWx0LCBvd25Qcm9wZXJ0aWVzKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qXG5cdCAqIERlY2xhcmUgYSBjb25zdHJ1Y3RvciB0byByZXByZXNlbnQgYSBzdWJjbGFzc1xuXHQgKiBvZiBhbm90aGVyIGNvbnN0cnVjdG9yXG5cdCAqIElmIHBsYXRmb3JtIGhhcyBhIGJ1aWx0LWluIHZlcnNpb24gd2UgdXNlIHRoYXQgZnJvbSBQbGF0Zm9ybSwgZWxzZSB3ZVxuXHQgKiBkZWZpbmUgaGVyZSAoc28gY2FuIG1ha2UgdXNlIG9mIG90aGVyIFV0aWxzIGZucylcblx0ICogU2VlIG5vZGUuanMgdXRpbC5pbmhlcml0c1xuXHQgKi9cblx0VXRpbHMuaW5oZXJpdHMgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzIHx8IGZ1bmN0aW9uKGN0b3IsIHN1cGVyQ3Rvcikge1xuXHRcdGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuXHRcdGN0b3IucHJvdG90eXBlID0gVXRpbHMucHJvdG90eXBpY2FsQ2xvbmUoc3VwZXJDdG9yLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogY3RvciB9KTtcblx0fTtcblxuXHQvKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBhbiBlbnVtZXJhYmxlXG5cdCAqIHByb3BlcnR5IHdob3NlIHZhbHVlIGVxdWFscyBhIGdpdmVuIHZhbHVlLlxuXHQgKiBvYjogIHRoZSBvYmplY3Rcblx0ICogdmFsOiB0aGUgdmFsdWUgdG8gZmluZFxuXHQgKi9cblx0VXRpbHMuY29udGFpbnNWYWx1ZSA9IGZ1bmN0aW9uKG9iLCB2YWwpIHtcblx0XHRmb3IodmFyIGkgaW4gb2IpIHtcblx0XHRcdGlmKG9iW2ldID09IHZhbClcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXHRVdGlscy5pbnRlcnNlY3QgPSBmdW5jdGlvbihhcnIsIG9iKSB7IHJldHVybiBVdGlscy5pc0FycmF5KG9iKSA/IFV0aWxzLmFyckludGVyc2VjdChhcnIsIG9iKSA6IFV0aWxzLmFyckludGVyc2VjdE9iKGFyciwgb2IpOyB9O1xuXG5cdFV0aWxzLmFyckludGVyc2VjdCA9IGZ1bmN0aW9uKGFycjEsIGFycjIpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtZW1iZXIgPSBhcnIxW2ldO1xuXHRcdFx0aWYoVXRpbHMuYXJySW5kZXhPZihhcnIyLCBtZW1iZXIpICE9IC0xKVxuXHRcdFx0XHRyZXN1bHQucHVzaChtZW1iZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFV0aWxzLmFyckludGVyc2VjdE9iID0gZnVuY3Rpb24oYXJyLCBvYikge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbWVtYmVyID0gYXJyW2ldO1xuXHRcdFx0aWYobWVtYmVyIGluIG9iKVxuXHRcdFx0XHRyZXN1bHQucHVzaChtZW1iZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFV0aWxzLmFyclN1YnRyYWN0ID0gZnVuY3Rpb24oYXJyMSwgYXJyMikge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBhcnIxW2ldO1xuXHRcdFx0aWYoVXRpbHMuYXJySW5kZXhPZihhcnIyLCBlbGVtZW50KSA9PSAtMSlcblx0XHRcdFx0cmVzdWx0LnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMuYXJySW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mXG5cdFx0PyBmdW5jdGlvbihhcnIsIGVsZW0sIGZyb21JbmRleCkge1xuXHRcdFx0cmV0dXJuIGFyci5pbmRleE9mKGVsZW0sICBmcm9tSW5kZXgpO1xuXHRcdH1cblx0XHQ6IGZ1bmN0aW9uKGFyciwgZWxlbSwgZnJvbUluZGV4KSB7XG5cdFx0XHRmcm9tSW5kZXggPSBmcm9tSW5kZXggfHwgMDtcblx0XHRcdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yKDtmcm9tSW5kZXggPCBsZW47IGZyb21JbmRleCsrKSB7XG5cdFx0XHRcdGlmKGFycltmcm9tSW5kZXhdID09PSBlbGVtKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21JbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH07XG5cblx0VXRpbHMuYXJySW4gPSBmdW5jdGlvbihhcnIsIHZhbCkge1xuXHRcdHJldHVybiBVdGlscy5hcnJJbmRleE9mKGFyciwgdmFsKSAhPT0gLTE7XG5cdH07XG5cblx0VXRpbHMuYXJyRGVsZXRlVmFsdWUgPSBmdW5jdGlvbihhcnIsIHZhbCkge1xuXHRcdHZhciBpZHggPSBVdGlscy5hcnJJbmRleE9mKGFyciwgdmFsKTtcblx0XHR2YXIgcmVzID0gKGlkeCAhPSAtMSk7XG5cdFx0aWYocmVzKVxuXHRcdFx0YXJyLnNwbGljZShpZHgsIDEpO1xuXHRcdHJldHVybiByZXM7XG5cdH07XG5cblx0VXRpbHMuYXJyV2l0aG91dFZhbHVlID0gZnVuY3Rpb24oYXJyLCB2YWwpIHtcblx0XHR2YXIgbmV3QXJyID0gYXJyLnNsaWNlKCk7XG5cdFx0VXRpbHMuYXJyRGVsZXRlVmFsdWUobmV3QXJyLCB2YWwpO1xuXHRcdHJldHVybiBuZXdBcnI7XG5cdH07XG5cblx0Lypcblx0ICogQ29uc3RydWN0IGFuIGFycmF5IG9mIHRoZSBrZXlzIG9mIHRoZSBlbnVtZXJhYmxlXG5cdCAqIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBvYmplY3QsIG9wdGlvbmFsbHkgbGltaXRlZFxuXHQgKiB0byBvbmx5IHRoZSBvd24gcHJvcGVydGllcy5cblx0ICogb2I6ICAgICAgdGhlIG9iamVjdFxuXHQgKiBvd25Pbmx5OiBib29sZWFuLCBnZXQgb3duIHByb3BlcnRpZXMgb25seVxuXHQgKi9cblx0VXRpbHMua2V5c0FycmF5ID0gZnVuY3Rpb24ob2IsIG93bk9ubHkpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKSB7XG5cdFx0XHRpZihvd25Pbmx5ICYmICFvYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG5cdFx0XHRyZXN1bHQucHVzaChwcm9wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKlxuXHQgKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgZW51bWVyYWJsZVxuXHQgKiBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCBvcHRpb25hbGx5IGxpbWl0ZWRcblx0ICogdG8gb25seSB0aGUgb3duIHByb3BlcnRpZXMuXG5cdCAqIG9iOiAgICAgIHRoZSBvYmplY3Rcblx0ICogb3duT25seTogYm9vbGVhbiwgZ2V0IG93biBwcm9wZXJ0aWVzIG9ubHlcblx0ICovXG5cdFV0aWxzLnZhbHVlc0FycmF5ID0gZnVuY3Rpb24ob2IsIG93bk9ubHkpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKSB7XG5cdFx0XHRpZihvd25Pbmx5ICYmICFvYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG5cdFx0XHRyZXN1bHQucHVzaChvYltwcm9wXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMuZm9ySW5Pd25Ob25OdWxsUHJvcHMgPSBmdW5jdGlvbihvYiwgZm4pIHtcblx0XHRmb3IgKHZhciBwcm9wIGluIG9iKSB7XG5cdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSAmJiBvYltwcm9wXSkge1xuXHRcdFx0XHRmbihwcm9wKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0VXRpbHMuYXJyRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID9cblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHRhcnIuZm9yRWFjaChmbik7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdFx0dmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Zm4oYXJyW2ldLCBpLCBhcnIpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0LyogVXNlZnVsIHdoZW4gdGhlIGZ1bmN0aW9uIG1heSBtdXRhdGUgdGhlIGFycmF5ICovXG5cdFV0aWxzLnNhZmVBcnJGb3JFYWNoID0gZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdHJldHVybiBVdGlscy5hcnJGb3JFYWNoKGFyci5zbGljZSgpLCBmbik7XG5cdH07XG5cblx0VXRpbHMuYXJyTWFwID0gQXJyYXkucHJvdG90eXBlLm1hcCA/XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdFx0cmV0dXJuIGFyci5tYXAoZm4pO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKGFyciwgZm4pXHR7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goZm4oYXJyW2ldLCBpLCBhcnIpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRVdGlscy5hcnJGaWx0ZXIgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyID9cblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHRyZXR1cm4gYXJyLmZpbHRlcihmbik7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbilcdHtcblx0XHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZihmbihhcnJbaV0pKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goYXJyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFV0aWxzLmFyckV2ZXJ5ID0gQXJyYXkucHJvdG90eXBlLmV2ZXJ5ID9cblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHRyZXR1cm4gYXJyLmV2ZXJ5KGZuKTtcblx0XHR9IDogZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdFx0dmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aWYoIWZuKGFycltpXSwgaSwgYXJyKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0VXRpbHMuYWxsU2FtZSA9IGZ1bmN0aW9uKGFyciwgcHJvcCkge1xuXHRcdGlmKGFyci5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgZmlyc3QgPSBhcnJbMF1bcHJvcF07XG5cdFx0cmV0dXJuIFV0aWxzLmFyckV2ZXJ5KGFyciwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW1bcHJvcF0gPT09IGZpcnN0O1xuXHRcdH0pO1xuXHR9O1xuXG5cdFV0aWxzLm5leHRUaWNrID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljaztcblxuXHR2YXIgY29udGVudFR5cGVzID0ge1xuXHRcdGpzb246ICAgJ2FwcGxpY2F0aW9uL2pzb24nLFxuXHRcdGpzb25wOiAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuXHRcdHhtbDogICAgJ2FwcGxpY2F0aW9uL3htbCcsXG5cdFx0aHRtbDogICAndGV4dC9odG1sJyxcblx0XHRtc2dwYWNrOiAnYXBwbGljYXRpb24veC1tc2dwYWNrJ1xuXHR9O1xuXG5cdFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzID0gZnVuY3Rpb24oZm9ybWF0KSB7XG5cdFx0dmFyIGFjY2VwdCA9IGNvbnRlbnRUeXBlc1tmb3JtYXQgfHwgJ2pzb24nXTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YWNjZXB0OiBhY2NlcHQsXG5cdFx0XHQnWC1BYmx5LVZlcnNpb24nOiBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcGlWZXJzaW9uLFxuXHRcdFx0J1gtQWJseS1MaWInOiBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5saWJzdHJpbmdcblx0XHR9O1xuXHR9O1xuXG5cdFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuXHRcdHZhciBhY2NlcHQsIGNvbnRlbnRUeXBlO1xuXHRcdGFjY2VwdCA9IGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVzW2Zvcm1hdCB8fCAnanNvbiddO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFjY2VwdDogYWNjZXB0LFxuXHRcdFx0J2NvbnRlbnQtdHlwZSc6IGNvbnRlbnRUeXBlLFxuXHRcdFx0J1gtQWJseS1WZXJzaW9uJzogX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXBpVmVyc2lvbixcblx0XHRcdCdYLUFibHktTGliJzogX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubGlic3RyaW5nXG5cdFx0fTtcblx0fTtcblxuXHRVdGlscy5hcnJQb3BSYW5kb21FbGVtZW50ID0gZnVuY3Rpb24oYXJyKSB7XG5cdFx0cmV0dXJuIGFyci5zcGxpY2UocmFuZG9tUG9zbihhcnIpLCAxKVswXTtcblx0fTtcblxuXHRVdGlscy50b1F1ZXJ5U3RyaW5nID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0dmFyIHBhcnRzID0gW107XG5cdFx0aWYocGFyYW1zKSB7XG5cdFx0XHRmb3IodmFyIGtleSBpbiBwYXJhbXMpXG5cdFx0XHRcdHBhcnRzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnRzLmxlbmd0aCA/ICc/JyArIHBhcnRzLmpvaW4oJyYnKSA6ICcnO1xuXHR9O1xuXG5cdFV0aWxzLnBhcnNlUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihxdWVyeSkge1xuXHRcdHZhciBtYXRjaCxcblx0XHRcdHNlYXJjaCA9IC8oW14/Jj1dKyk9PyhbXiZdKikvZyxcblx0XHRcdHJlc3VsdCA9IHt9O1xuXG5cdFx0d2hpbGUgKG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpKVxuXHRcdFx0cmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzJdKTtcblxuIFx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFV0aWxzLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuXHRcdC8qIElFIDggKi9cblx0XHRyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdH07XG5cblx0VXRpbHMuaW5zcGVjdCA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdDtcblxuXHRVdGlscy5pc0Vycm9ySW5mbyA9IGZ1bmN0aW9uKGVycikge1xuXHRcdHJldHVybiBlcnIuY29uc3RydWN0b3IubmFtZSA9PSAnRXJyb3JJbmZvJ1xuXHR9O1xuXG5cdFV0aWxzLmluc3BlY3RFcnJvciA9IGZ1bmN0aW9uKHgpIHtcblx0XHQvKiByZWR1bmRhbnQsIGJ1dCBub2RlIHZtY29udGV4dCBpc3N1ZSBtYWtlcyBpbnN0YW5jZW9mIHVucmVsaWFibGUsIGFuZFxuXHRcdCAqIGNhbid0IHVzZSBqdXN0IGNvbnN0cnVjdG9yIHRlc3QgYXMgY291bGQgYmUgYSBUeXBlRXJyb3IgY29uc3RydWN0b3IgZXRjLiAqL1xuXHRcdHJldHVybiAoeCAmJiAoVXRpbHMuaXNFcnJvckluZm8oeCkgfHxcblx0XHRcdHguY29uc3RydWN0b3IubmFtZSA9PSAnRXJyb3InIHx8XG5cdFx0XHR4IGluc3RhbmNlb2YgRXJyb3IpKSA/XG5cdFx0XHR4LnRvU3RyaW5nKCkgOlxuXHRcdFx0VXRpbHMuaW5zcGVjdCh4KTtcblx0fTtcblxuXHRVdGlscy5pbnNwZWN0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcblx0XHRpZihwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0XHRyZXR1cm4gYm9keS50b1N0cmluZygpO1xuXHRcdH0gZWxzZSBpZih0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBib2R5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0KGJvZHkpO1xuXHRcdH1cblx0fTtcblxuXHQvKiBEYXRhIGlzIGFzc3VtZWQgdG8gYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgYnVmZmVyLiAqL1xuXHRVdGlscy5kYXRhU2l6ZUJ5dGVzID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdGlmKHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkpIHtcblx0XHRcdHJldHVybiBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJ5dGVMZW5ndGgoZGF0YSk7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc3RyaW5nQnl0ZVNpemUoZGF0YSk7XG5cdFx0fVxuXHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIFV0aWxzLmRhdGFTaXplQnl0ZXMgdG8gYmUgYSBidWZmZXIgb3Igc3RyaW5nLCBidXQgd2FzOiBcIiArICh0eXBlb2YgZGF0YSkpO1xuXHR9O1xuXG5cdFV0aWxzLmNoZWFwUmFuZFN0ciA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc3Vic3RyKDIpO1xuXHR9O1xuXG5cdC8qIFRha2VzIHBhcmFtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBieXRlcyBvZiBlbnRyb3B5IHRoZSBzdHJpbmcgbXVzdFxuXHQgKiBpbmNsdWRlLCBub3QgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLiBTdHJpbmcgbGVuZ3RoIHByb2R1Y2VkIGlzIG5vdFxuXHQgKiBndWFyYW50ZWVkLiAqL1xuXHRVdGlscy5yYW5kb21TdHJpbmcgPSAocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXMgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSA/XG5cdFx0ZnVuY3Rpb24obnVtQnl0ZXMpIHtcblx0XHRcdHZhciB1SW50QXJyID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXMpO1xuXHRcdFx0cGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXModUludEFycik7XG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRFbmNvZGUodUludEFycik7XG5cdFx0fSA6IGZ1bmN0aW9uKG51bUJ5dGVzKSB7XG5cdFx0XHQvKiBPbGQgYnJvd3NlcjsgZmFsbCBiYWNrIHRvIE1hdGgucmFuZG9tLiBDb3VsZCBqdXN0IHVzZSBhXG5cdFx0XHQgKiBDcnlwdG9KUyB2ZXJzaW9uIG9mIHRoZSBhYm92ZSwgYnV0IHdhbnQgdGhpcyB0byBzdGlsbCB3b3JrIGluIG5vY3J5cHRvXG5cdFx0XHQgKiB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeSAqL1xuXHRcdFx0dmFyIGNoYXJzZXQgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NENoYXJTZXQ7XG5cdFx0XHQvKiBiYXNlNjQgaGFzIDMzJSBvdmVyaGVhZDsgcm91bmQgbGVuZ3RoIHVwICovXG5cdFx0XHR2YXIgbGVuZ3RoID0gTWF0aC5yb3VuZChudW1CeXRlcyAqIDQvMyk7XG5cdFx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRVdGlscy5yYW5kb21IZXhTdHJpbmcgPSAocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXMgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSA/XG5cdFx0ZnVuY3Rpb24obnVtQnl0ZXMpIHtcblx0XHRcdHZhciB1SW50QXJyID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXMpO1xuXHRcdFx0cGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21WYWx1ZXModUludEFycik7XG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5oZXhFbmNvZGUodUludEFycik7XG5cdFx0fSA6IGZ1bmN0aW9uKG51bUJ5dGVzKSB7XG5cdFx0XHR2YXIgY2hhcnNldCA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaGV4Q2hhclNldDtcblx0XHRcdHZhciBsZW5ndGggPSBudW1CeXRlcyAqIDI7XG5cdFx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHQvKiBQaWNrIG4gZWxlbWVudHMgYXQgcmFuZG9tIHdpdGhvdXQgcmVwbGFjZW1lbnQgZnJvbSBhbiBhcnJheSAqL1xuXHRVdGlscy5hcnJDaG9vc2VOID0gZnVuY3Rpb24oYXJyLCBuKSB7XG5cdFx0dmFyIG51bUl0ZW1zID0gTWF0aC5taW4obiwgYXJyLmxlbmd0aCksXG5cdFx0XHRtdXRhYmxlQXJyID0gYXJyLnNsaWNlKCksXG5cdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbnVtSXRlbXM7IGkrKykge1xuXHRcdFx0cmVzdWx0LnB1c2goVXRpbHMuYXJyUG9wUmFuZG9tRWxlbWVudChtdXRhYmxlQXJyKSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMudHJpbSA9IFN0cmluZy5wcm90b3R5cGUudHJpbSA/IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHR9IDogZnVuY3Rpb24oc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXHR9O1xuXG5cdFV0aWxzLnByb21pc2lmeSA9IGZ1bmN0aW9uKG9iLCBmbk5hbWUsIGFyZ3MpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRvYltmbk5hbWVdLmFwcGx5KG9iLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5jb25jYXQoZnVuY3Rpb24oZXJyLCByZXMpIHtcblx0XHRcdFx0ZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlcyk7XG5cdFx0XHR9KSk7XG5cdFx0fSk7XG5cdH07XG5cblx0VXRpbHMuZGVjb2RlQm9keSA9IGZ1bmN0aW9uKGJvZHksIGZvcm1hdCkge1xuXHRcdHJldHVybiAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmRlY29kZShib2R5KSA6IEpTT04ucGFyc2UoU3RyaW5nKGJvZHkpKTtcblx0fTtcblxuXHRVdGlscy5lbmNvZGVCb2R5ID0gZnVuY3Rpb24oYm9keSwgZm9ybWF0KSB7XG5cdFx0cmV0dXJuIChmb3JtYXQgPT0gJ21zZ3BhY2snKSA/IG1zZ3BhY2suZW5jb2RlKGJvZHksIHRydWUpIDogSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdH07XG5cblx0VXRpbHMuYWxsVG9Mb3dlckNhc2UgPSBmdW5jdGlvbihhcnIpIHtcblx0XHRyZXR1cm4gVXRpbHMuYXJyTWFwKGFyciwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC50b0xvd2VyQ2FzZSgpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFV0aWxzLmFsbFRvVXBwZXJDYXNlID0gZnVuY3Rpb24oYXJyKSB7XG5cdFx0cmV0dXJuIFV0aWxzLmFyck1hcChhcnIsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4gVXRpbHM7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFV0aWxzKTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cblxudmFyIEVycm9ySW5mbyA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSwgY2F1c2UpIHtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdHRoaXMuY29kZSA9IGNvZGU7XG5cdFx0dGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcblx0XHR0aGlzLmNhdXNlID0gY2F1c2U7XG5cdFx0dGhpcy5ocmVmID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0RXJyb3JJbmZvLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSAnWycgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdFx0aWYodGhpcy5tZXNzYWdlKSByZXN1bHQgKz0gJzogJyArIHRoaXMubWVzc2FnZTtcblx0XHRpZih0aGlzLnN0YXR1c0NvZGUpIHJlc3VsdCArPSAnOyBzdGF0dXNDb2RlPScgKyB0aGlzLnN0YXR1c0NvZGU7XG5cdFx0aWYodGhpcy5jb2RlKSByZXN1bHQgKz0gJzsgY29kZT0nICsgdGhpcy5jb2RlO1xuXHRcdGlmKHRoaXMuY2F1c2UpIHJlc3VsdCArPSAnOyBjYXVzZT0nICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IodGhpcy5jYXVzZSk7XG5cdFx0aWYodGhpcy5ocmVmICYmICEodGhpcy5tZXNzYWdlICYmIHRoaXMubWVzc2FnZS5pbmRleE9mKCdoZWxwLmFibHkuaW8nKSA+IC0xKSkgcmVzdWx0ICs9ICc7IHNlZSAnICsgdGhpcy5ocmVmICsgJyAnO1xuXHRcdHJlc3VsdCArPSAnXSc7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRFcnJvckluZm8uZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHZhciByZXN1bHQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKG5ldyBFcnJvckluZm8oKSwgdmFsdWVzKTtcblx0XHRpZiAodmFsdWVzIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdC8qIEVycm9yLm1lc3NhZ2UgaXMgbm90IGVudW1lcmFibGUsIHNvIG1peGluIGxvc2VzIHRoZSBtZXNzYWdlICovXG5cdFx0XHRyZXN1bHQubWVzc2FnZSA9IHZhbHVlcy5tZXNzYWdlO1xuXHRcdH1cblx0XHRpZihyZXN1bHQuY29kZSAmJiAhcmVzdWx0LmhyZWYpIHtcblx0XHRcdHJlc3VsdC5ocmVmID0gJ2h0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLycgKyByZXN1bHQuY29kZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRyZXR1cm4gRXJyb3JJbmZvO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChFcnJvckluZm8pO1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpYl91dGlsX21zZ3BhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG5cbmlmKHR5cGVvZiBXaW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0Y29uc29sZS5sb2coXCJXYXJuaW5nOiB0aGlzIGRpc3RyaWJ1dGlvbiBvZiBBYmx5IGlzIGludGVuZGVkIGZvciBicm93c2Vycy4gT24gbm9kZWpzLCBwbGVhc2UgdXNlIHRoZSAnYWJseScgcGFja2FnZSBvbiBucG1cIik7XG59XG5cbmZ1bmN0aW9uIGFsbG93Q29tZXQoKSB7XG5cdC8qIHhociByZXF1ZXN0cyBmcm9tIGxvY2FsIGZpbGVzIGFyZSB1bnJlbGlhYmxlIGluIHNvbWUgYnJvd3NlcnMsIHN1Y2ggYXMgQ2hyb21lIDY1IGFuZCBoaWdoZXIgLS0gc2VlIGVnXG5cdCAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5MjU2NDI5L2Nocm9tZS02NS11bmFibGUtdG8tbWFrZS1wb3N0LXJlcXVlc3RzLWZyb20tbG9jYWwtZmlsZXMtdG8tZmxhc2tcblx0ICogU28gaWYgd2Vic29ja2V0cyBhcmUgc3VwcG9ydGVkLCB0aGVuIGp1c3QgZm9yZ2V0IGFib3V0IGNvbWV0IHRyYW5zcG9ydHMgYW5kIHVzZSB0aGF0ICovXG5cdHZhciBsb2MgPSBnbG9iYWwubG9jYXRpb247XG5cdHJldHVybiAoIWdsb2JhbC5XZWJTb2NrZXQgfHwgIWxvYyB8fCAhbG9jLm9yaWdpbiB8fCBsb2Mub3JpZ2luLmluZGV4T2YoXCJodHRwXCIpID4gLTEpO1xufVxuXG52YXIgdXNlckFnZW50ID0gZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudC50b1N0cmluZygpO1xudmFyIGN1cnJlbnRVcmwgPSBnbG9iYWwubG9jYXRpb24gJiYgZ2xvYmFsLmxvY2F0aW9uLmhyZWY7XG5cbnZhciBQbGF0Zm9ybSA9IHtcblx0bGlidmVyOiAnanMtd2ViJyxcblx0bG9nVGltZXN0YW1wczogdHJ1ZSxcblx0dXNlckFnZW50OiB1c2VyQWdlbnQsXG5cdGN1cnJlbnRVcmw6IGN1cnJlbnRVcmwsXG5cdG5vVXBncmFkZTogdXNlckFnZW50ICYmIHVzZXJBZ2VudC5tYXRjaCgvTVNJRVxcczhcXC4wLyksXG5cdGJpbmFyeVR5cGU6ICdhcnJheWJ1ZmZlcicsXG5cdFdlYlNvY2tldDogZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0LFxuXHR4aHJTdXBwb3J0ZWQ6IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcblx0anNvbnBTdXBwb3J0ZWQ6IHR5cGVvZihkb2N1bWVudCkgIT09ICd1bmRlZmluZWQnLFxuXHRhbGxvd0NvbWV0OiBhbGxvd0NvbWV0KCksXG5cdHN0cmVhbWluZ1N1cHBvcnRlZDogdHJ1ZSxcblx0dXNlUHJvdG9jb2xIZWFydGJlYXRzOiB0cnVlLFxuXHRjcmVhdGVIbWFjOiBudWxsLFxuXHRtc2dwYWNrOiBfbGliX3V0aWxfbXNncGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLFxuXHRzdXBwb3J0c0JpbmFyeTogISFnbG9iYWwuVGV4dERlY29kZXIsXG5cdHByZWZlckJpbmFyeTogZmFsc2UsXG5cdEFycmF5QnVmZmVyOiBnbG9iYWwuQXJyYXlCdWZmZXIsXG5cdGF0b2I6IGdsb2JhbC5hdG9iLFxuXHRuZXh0VGljazogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDApOyB9LFxuXHRhZGRFdmVudExpc3RlbmVyOiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcixcblx0aW5zcGVjdDogSlNPTi5zdHJpbmdpZnksXG5cdHN0cmluZ0J5dGVTaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHQvKiBzdHIubGVuZ3RoIHdpbGwgYmUgYW4gdW5kZXJlc3RpbWF0ZSBmb3Igbm9uLWFzY2lpIHN0cmluZ3MuIEJ1dCBpZiB3ZSdyZVxuXHRcdCAqIGluIGEgYnJvd3NlciB0b28gb2xkIHRvIHN1cHBvcnQgVGV4dERlY29kZXIsIG5vdCBtdWNoIHdlIGNhbiBkby4gQmV0dGVyXG5cdFx0ICogdG8gdW5kZXJlc3RpbWF0ZSwgc28gaWYgd2UgZG8gZ28gb3Zlci1zaXplLCB0aGUgc2VydmVyIHdpbGwgcmVqZWN0IHRoZVxuXHRcdCAqIG1lc3NhZ2UgKi9cblx0XHRyZXR1cm4gZ2xvYmFsLlRleHREZWNvZGVyICYmXG5cdFx0XHQobmV3IGdsb2JhbC5UZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKS5sZW5ndGggfHxcblx0XHRcdHN0ci5sZW5ndGg7XG5cdH0sXG5cdFRleHRFbmNvZGVyOiBnbG9iYWwuVGV4dEVuY29kZXIsXG5cdFRleHREZWNvZGVyOiBnbG9iYWwuVGV4dERlY29kZXIsXG5cdFByb21pc2U6IGdsb2JhbC5Qcm9taXNlLFxuXHRnZXRSYW5kb21WYWx1ZXM6IChmdW5jdGlvbihjcnlwdG8pIHtcblx0XHRpZiAoY3J5cHRvID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbihhcnIsIGNhbGxiYWNrKSB7XG5cdFx0XHRjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG5cdFx0XHRpZihjYWxsYmFjaykge1xuXHRcdFx0XHRjYWxsYmFjayhudWxsKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KShnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykgLy8gbXNjcnlwdG8gZm9yIElFMTFcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUGxhdGZvcm0pO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpKVxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX3V0ZjhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfZW5jX3V0ZjhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblxuXG5cblxuXG52YXIgQnVmZmVyVXRpbHMgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBBcnJheUJ1ZmZlciA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uQXJyYXlCdWZmZXI7XG5cdHZhciBhdG9iID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hdG9iO1xuXHR2YXIgVGV4dEVuY29kZXIgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRleHRFbmNvZGVyO1xuXHR2YXIgVGV4dERlY29kZXIgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRleHREZWNvZGVyO1xuXHR2YXIgYmFzZTY0Q2hhclNldCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblx0dmFyIGhleENoYXJTZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cblx0ZnVuY3Rpb24gaXNXb3JkQXJyYXkob2IpIHsgcmV0dXJuIG9iICE9PSBudWxsICYmIG9iICE9PSB1bmRlZmluZWQgJiYgb2Iuc2lnQnl0ZXMgIT09IHVuZGVmaW5lZDsgfVxuXHRmdW5jdGlvbiBpc0FycmF5QnVmZmVyKG9iKSB7IHJldHVybiBvYiAhPT0gbnVsbCAmJiBvYiAhPT0gdW5kZWZpbmVkICYmIG9iLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjsgfVxuXHRmdW5jdGlvbiBpc1R5cGVkQXJyYXkob2IpIHsgcmV0dXJuIEFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2IpOyB9XG5cblx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qb25sZWlnaHRvbi85NTg4NDEvcmF3L2YyMDBlMzBkZmU5NTIxMmMwMTY1Y2NmMWFlMDAwY2E1MWU5ZGU4MDMvZ2lzdGZpbGUxLmpzXG5cdGZ1bmN0aW9uIHVpbnQ4Vmlld1RvQmFzZTY0KGJ5dGVzKSB7XG5cdFx0dmFyIGJhc2U2NCAgICA9ICcnXG5cdFx0dmFyIGVuY29kaW5ncyA9IGJhc2U2NENoYXJTZXQ7XG5cblx0XHR2YXIgYnl0ZUxlbmd0aCAgICA9IGJ5dGVzLmJ5dGVMZW5ndGhcblx0XHR2YXIgYnl0ZVJlbWFpbmRlciA9IGJ5dGVMZW5ndGggJSAzXG5cdFx0dmFyIG1haW5MZW5ndGggICAgPSBieXRlTGVuZ3RoIC0gYnl0ZVJlbWFpbmRlclxuXG5cdFx0dmFyIGEsIGIsIGMsIGRcblx0XHR2YXIgY2h1bmtcblxuXHRcdC8vIE1haW4gbG9vcCBkZWFscyB3aXRoIGJ5dGVzIGluIGNodW5rcyBvZiAzXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYWluTGVuZ3RoOyBpID0gaSArIDMpIHtcblx0XHRcdC8vIENvbWJpbmUgdGhlIHRocmVlIGJ5dGVzIGludG8gYSBzaW5nbGUgaW50ZWdlclxuXHRcdFx0Y2h1bmsgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXVxuXG5cdFx0XHQvLyBVc2UgYml0bWFza3MgdG8gZXh0cmFjdCA2LWJpdCBzZWdtZW50cyBmcm9tIHRoZSB0cmlwbGV0XG5cdFx0XHRhID0gKGNodW5rICYgMTY1MTUwNzIpID4+IDE4IC8vIDE2NTE1MDcyID0gKDJeNiAtIDEpIDw8IDE4XG5cdFx0XHRiID0gKGNodW5rICYgMjU4MDQ4KSAgID4+IDEyIC8vIDI1ODA0OCAgID0gKDJeNiAtIDEpIDw8IDEyXG5cdFx0XHRjID0gKGNodW5rICYgNDAzMikgICAgID4+ICA2IC8vIDQwMzIgICAgID0gKDJeNiAtIDEpIDw8IDZcblx0XHRcdGQgPSBjaHVuayAmIDYzICAgICAgICAgICAgICAgLy8gNjMgICAgICAgPSAyXjYgLSAxXG5cblx0XHRcdC8vIENvbnZlcnQgdGhlIHJhdyBiaW5hcnkgc2VnbWVudHMgdG8gdGhlIGFwcHJvcHJpYXRlIEFTQ0lJIGVuY29kaW5nXG5cdFx0XHRiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgZW5jb2RpbmdzW2RdXG5cdFx0fVxuXG5cdFx0Ly8gRGVhbCB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMgYW5kIHBhZGRpbmdcblx0XHRpZiAoYnl0ZVJlbWFpbmRlciA9PSAxKSB7XG5cdFx0XHRjaHVuayA9IGJ5dGVzW21haW5MZW5ndGhdXG5cblx0XHRcdGEgPSAoY2h1bmsgJiAyNTIpID4+IDIgLy8gMjUyID0gKDJeNiAtIDEpIDw8IDJcblxuXHRcdFx0Ly8gU2V0IHRoZSA0IGxlYXN0IHNpZ25pZmljYW50IGJpdHMgdG8gemVyb1xuXHRcdFx0YiA9IChjaHVuayAmIDMpICAgPDwgNCAvLyAzICAgPSAyXjIgLSAxXG5cblx0XHRcdGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyAnPT0nXG5cdFx0fSBlbHNlIGlmIChieXRlUmVtYWluZGVyID09IDIpIHtcblx0XHRcdGNodW5rID0gKGJ5dGVzW21haW5MZW5ndGhdIDw8IDgpIHwgYnl0ZXNbbWFpbkxlbmd0aCArIDFdXG5cblx0XHRcdGEgPSAoY2h1bmsgJiA2NDUxMikgPj4gMTAgLy8gNjQ1MTIgPSAoMl42IC0gMSkgPDwgMTBcblx0XHRcdGIgPSAoY2h1bmsgJiAxMDA4KSAgPj4gIDQgLy8gMTAwOCAgPSAoMl42IC0gMSkgPDwgNFxuXG5cdFx0XHQvLyBTZXQgdGhlIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB0byB6ZXJvXG5cdFx0XHRjID0gKGNodW5rICYgMTUpICAgIDw8ICAyIC8vIDE1ICAgID0gMl40IC0gMVxuXG5cdFx0XHRiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgJz0nXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJhc2U2NFxuXHR9XG5cblx0ZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQpIHtcblx0XHR2YXIgYmluYXJ5X3N0cmluZyA9ICBhdG9iKGJhc2U2NCk7XG5cdFx0dmFyIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuXHRcdHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KCBsZW4gKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSAgICAgICAge1xuXHRcdFx0dmFyIGFzY2lpID0gYmluYXJ5X3N0cmluZy5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0Ynl0ZXNbaV0gPSBhc2NpaTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVzLmJ1ZmZlcjtcblx0fVxuXG5cdC8qIE1vc3QgQnVmZmVyVXRpbHMgbWV0aG9kcyB0aGF0IHJldHVybiBhIGJpbmFyeSBvYmplY3QgcmV0dXJuIGFuIEFycmF5QnVmZmVyXG5cdCAqIGlmIHN1cHBvcnRlZCwgZWxzZSBhIENyeXB0b0pTIFdvcmRBcnJheS4gVGhlIGV4Y2VwdGlvbiBpcyB0b0J1ZmZlciwgd2hpY2hcblx0ICogcmV0dXJucyBhIFVpbnQ4QXJyYXkgKGFuZCB3b24ndCB3b3JrIG9uIGJyb3dzZXJzIHRvbyBvbGQgdG8gc3VwcG9ydCBpdCkgKi9cblx0ZnVuY3Rpb24gQnVmZmVyVXRpbHMoKSB7fVxuXG5cdEJ1ZmZlclV0aWxzLmJhc2U2NENoYXJTZXQgPSBiYXNlNjRDaGFyU2V0O1xuXHRCdWZmZXJVdGlscy5oZXhDaGFyU2V0ID0gaGV4Q2hhclNldDtcblxuXHR2YXIgaXNCdWZmZXIgPSBCdWZmZXJVdGlscy5pc0J1ZmZlciA9IGZ1bmN0aW9uKGJ1ZikgeyByZXR1cm4gaXNBcnJheUJ1ZmZlcihidWYpIHx8IGlzV29yZEFycmF5KGJ1ZikgfHwgaXNUeXBlZEFycmF5KGJ1Zik7IH07XG5cblx0LyogSW4gYnJvd3NlcnMsIHJldHVybnMgYSBVaW50OEFycmF5ICovXG5cdHZhciB0b0J1ZmZlciA9IEJ1ZmZlclV0aWxzLnRvQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoIUFycmF5QnVmZmVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0IHRvIEJ1ZmZlcjogYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBuZWNlc3NhcnkgdHlwZXNcIik7XG5cdFx0fVxuXG5cdFx0aWYoaXNBcnJheUJ1ZmZlcihidWYpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcblx0XHR9XG5cblx0XHRpZihpc1R5cGVkQXJyYXkoYnVmKSkge1xuXHRcdFx0cmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIpO1xuXHRcdH1cblxuXHRcdGlmKGlzV29yZEFycmF5KGJ1ZikpIHtcblx0XHRcdC8qIEJhY2twb3J0ZWQgZnJvbSB1bnJlbGVhc2VkIENyeXB0b0pTXG5cdFx0XHQqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3NvdXJjZS9icm93c2UvYnJhbmNoZXMvMy54L3NyYy9saWItdHlwZWRhcnJheXMuanM/cj02NjEgKi9cblx0XHRcdHZhciBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWYuc2lnQnl0ZXMpO1xuXHRcdFx0dmFyIHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBidWYuc2lnQnl0ZXM7IGkrKykge1xuXHRcdFx0XHR1aW50OFZpZXdbaV0gPSAoYnVmLndvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVpbnQ4Vmlldztcblx0XHR9O1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyVXRpbHMudG9CdWZmZXIgZXhwZWN0ZWQgYW4gYXJyYXlidWZmZXIsIHR5cGVkIGFycmF5LCBvciBDcnlwdG9KUyB3b3JkYXJyYXlcIik7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGlmKGlzQXJyYXlCdWZmZXIoYnVmKSkge1xuXHRcdFx0cmV0dXJuIGJ1Zjtcblx0XHR9XG5cdFx0cmV0dXJuIHRvQnVmZmVyKGJ1ZikuYnVmZmVyO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5ID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoaXNUeXBlZEFycmF5KGJ1ZikpIHtcblx0XHRcdGJ1ZiA9IGJ1Zi5idWZmZXI7XG5cdFx0fVxuXHRcdHJldHVybiBpc1dvcmRBcnJheShidWYpID8gYnVmIDogY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5jcmVhdGUoYnVmKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUgPSBmdW5jdGlvbihidWYpIHtcblx0XHRpZihpc1dvcmRBcnJheShidWYpKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJzdHJpbmdpZnlcIl0pKGJ1Zik7XG5cdFx0fVxuXHRcdHJldHVybiB1aW50OFZpZXdUb0Jhc2U2NCh0b0J1ZmZlcihidWYpKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5iYXNlNjREZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcblx0XHRpZihBcnJheUJ1ZmZlciAmJiBhdG9iKSB7XG5cdFx0XHRyZXR1cm4gYmFzZTY0VG9BcnJheUJ1ZmZlcihzdHIpO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJwYXJzZVwiXSkoc3RyKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5oZXhFbmNvZGUgPSBmdW5jdGlvbihidWYpIHtcblx0XHRidWYgPSBCdWZmZXJVdGlscy50b1dvcmRBcnJheShidWYpO1xuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInN0cmluZ2lmeVwiXSkoYnVmKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5oZXhEZWNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHR2YXIgd29yZEFycmF5ID0gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJwYXJzZVwiXSkoc3RyaW5nKTtcblx0XHRyZXR1cm4gQXJyYXlCdWZmZXIgPyBCdWZmZXJVdGlscy50b0FycmF5QnVmZmVyKHdvcmRBcnJheSkgOiB3b3JkQXJyYXk7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMudXRmOEVuY29kZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdGlmKFRleHRFbmNvZGVyKSB7XG5cdFx0XHRyZXR1cm4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUoc3RyaW5nKS5idWZmZXI7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwYXJzZVwiXSkoc3RyaW5nKTtcblx0fTtcblxuXHQvKiBGb3IgdXRmOCBkZWNvZGluZyB3ZSBhcHBseSBzbGlnaHRseSBzdHJpY3RlciBpbnB1dCB2YWxpZGF0aW9uIHRoYW4gdG9cblx0ICogaGV4RW5jb2RlL2Jhc2U2NEVuY29kZS9ldGM6IGluIHRob3NlIHdlIGFjY2VwdCBhbnl0aGluZyB0aGF0IEJ1ZmZlci5mcm9tXG5cdCAqIGNhbiB0YWtlIChpbiBwYXJ0aWN1bGFyIGFsbG93aW5nIHN0cmluZ3MsIHdoaWNoIGFyZSBqdXN0IGludGVycHJldGVkIGFzXG5cdCAqIGJpbmFyeSk7IGhlcmUgd2UgZW5zdXJlIHRoYXQgdGhlIGlucHV0IGlzIGFjdHVhbGx5IGEgYnVmZmVyIHNpbmNlIHRyeWluZ1xuXHQgKiB0byB1dGY4LWRlY29kZSBhIHN0cmluZyB0byBhbm90aGVyIHN0cmluZyBpcyBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSAqL1xuXHRCdWZmZXJVdGlscy51dGY4RGVjb2RlID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoIWlzQnVmZmVyKGJ1ZikpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIHV0ZjhkZWNvZGUgdG8gYmUgYW4gYXJyYXlidWZmZXIsIHR5cGVkIGFycmF5LCBvciBDcnlwdG9KUyB3b3JkYXJyYXlcIik7XG5cdFx0fVxuXHRcdGlmKFRleHREZWNvZGVyICYmICFpc1dvcmRBcnJheShidWYpKSB7XG5cdFx0XHRyZXR1cm4gKG5ldyBUZXh0RGVjb2RlcigpKS5kZWNvZGUoYnVmKTtcblx0XHR9XG5cdFx0YnVmID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmKTtcblx0XHRyZXR1cm4gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfdXRmOF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wic3RyaW5naWZ5XCJdKShidWYpO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLmJ1ZmZlckNvbXBhcmUgPSBmdW5jdGlvbihidWYxLCBidWYyKSB7XG5cdFx0aWYoIWJ1ZjEpIHJldHVybiAtMTtcblx0XHRpZighYnVmMikgcmV0dXJuIDE7XG5cdFx0YnVmMSA9IEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KGJ1ZjEpO1xuXHRcdGJ1ZjIgPSBCdWZmZXJVdGlscy50b1dvcmRBcnJheShidWYyKTtcblx0XHRidWYxLmNsYW1wKCk7IGJ1ZjIuY2xhbXAoKTtcblxuXHRcdHZhciBjbXAgPSBidWYxLnNpZ0J5dGVzIC0gYnVmMi5zaWdCeXRlcztcblx0XHRpZihjbXAgIT0gMCkgcmV0dXJuIGNtcDtcblx0XHRidWYxID0gYnVmMS53b3JkczsgYnVmMiA9IGJ1ZjIud29yZHM7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGJ1ZjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNtcCA9IGJ1ZjFbaV0gLSBidWYyW2ldO1xuXHRcdFx0aWYoY21wICE9IDApIHJldHVybiBjbXA7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLmJ5dGVMZW5ndGggPSBmdW5jdGlvbihidWYpIHtcblx0XHRpZihpc0FycmF5QnVmZmVyKGJ1ZikgfHwgaXNUeXBlZEFycmF5KGJ1ZikpIHtcblx0XHRcdHJldHVybiBidWYuYnl0ZUxlbmd0aFxuXHRcdH0gZWxzZSBpZihpc1dvcmRBcnJheShidWYpKSB7XG5cdFx0XHRyZXR1cm4gYnVmLnNpZ0J5dGVzO1xuXHRcdH1cblx0fTtcblxuXHQvKiBSZXR1cm5zIEFycmF5QnVmZmVyIG9uIGJyb3dzZXIgYW5kIEJ1ZmZlciBvbiBOb2RlLmpzICovXG5cdEJ1ZmZlclV0aWxzLnR5cGVkQXJyYXlUb0J1ZmZlciA9IGZ1bmN0aW9uKHR5cGVkQXJyYXkpIHtcblx0XHRyZXR1cm4gdHlwZWRBcnJheS5idWZmZXI7XG5cdH07XG5cblx0cmV0dXJuIEJ1ZmZlclV0aWxzO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChCdWZmZXJVdGlscyk7XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9mcmFnbWVudHMvcGxhdGZvcm0tYnJvd3Nlci5qc1xudmFyIHBsYXRmb3JtX2Jyb3dzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvZGVmYXVsdHMuanNcblxuXG52YXIgRGVmYXVsdHMgPSB7XG5cdGludGVybmV0VXBVcmw6ICdodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC50eHQnLFxuXHRqc29ucEludGVybmV0VXBVcmw6ICdodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC0wLTkuanMnLFxuXHQvKiBPcmRlciBtYXR0ZXJzIGhlcmU6IHRoZSBiYXNlIHRyYW5zcG9ydCBpcyB0aGUgbGVmdG1vc3Qgb25lIGluIHRoZVxuXHQgKiBpbnRlcnNlY3Rpb24gb2YgYmFzZVRyYW5zcG9ydE9yZGVyIGFuZCB0aGUgdHJhbnNwb3J0cyBjbGllbnRPcHRpb24gdGhhdCdzXG5cdCAqIHN1cHBvcnRlZC4gIFRoaXMgaXMgbm90IHF1aXRlIHRoZSBzYW1lIGFzIHRoZSBwcmVmZXJlbmNlIG9yZGVyIC0tIGUuZy5cblx0ICogeGhyX3BvbGxpbmcgaXMgcHJlZmVycmVkIHRvIGpzb25wLCBidXQgZm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCB3ZSB3YW50XG5cdCAqIHRoZSBiYXNlIHRyYW5zcG9ydCB0byBiZSB4aHJfcG9sbGluZywgbm90IGpzb25wICovXG5cdGRlZmF1bHRUcmFuc3BvcnRzOiBbJ3hocl9wb2xsaW5nJywgJ3hocl9zdHJlYW1pbmcnLCAnanNvbnAnLCAnd2ViX3NvY2tldCddLFxuXHRiYXNlVHJhbnNwb3J0T3JkZXI6IFsneGhyX3BvbGxpbmcnLCAneGhyX3N0cmVhbWluZycsICdqc29ucCcsICd3ZWJfc29ja2V0J10sXG5cdHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlcjogWydqc29ucCcsICd4aHJfcG9sbGluZycsICd4aHJfc3RyZWFtaW5nJywgJ3dlYl9zb2NrZXQnXSxcblx0dXBncmFkZVRyYW5zcG9ydHM6IFsneGhyX3N0cmVhbWluZycsICd3ZWJfc29ja2V0J11cbn07XG5cbi8qIElmIHVzaW5nIElFOCwgZG9uJ3QgYXR0ZW1wdCB0byB1cGdyYWRlIGZyb20geGhyX3BvbGxpbmcgdG8geGhyX3N0cmVhbWluZyAtXG4qIHdoaWxlIGl0IGNhbiBkbyBzdHJlYW1pbmcsIHRoZSBsb3cgbWF4IGh0dHAtY29ubmVjdGlvbnMtcGVyLWhvc3QgbGltaXQgbWVhbnNcbiogdGhhdCB0aGUgcG9sbGluZyB0cmFuc3BvcnQgaXMgY3JpcHBsZWQgZHVyaW5nIHRoZSB1cGdyYWRlIHByb2Nlc3MuIFNvIGp1c3RcbiogbGVhdmUgaXQgYXQgdGhlIGJhc2UgdHJhbnNwb3J0ICovXG5pZihwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vVXBncmFkZSkge1xuXHREZWZhdWx0cy51cGdyYWRlVHJhbnNwb3J0cyA9IFtdO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWZhdWx0cyA9IChEZWZhdWx0cyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvdXRpbHMuanNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2J1ZmZlcnV0aWxzLmpzXG52YXIgYnVmZmVydXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2xvZ2dlci5qc1xudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL2Vycm9yaW5mby5qc1xudmFyIGVycm9yaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2RlZmF1bHRzLmpzXG5cblxuXG5cblxuXG5cbmRlZmF1bHRzLkVOVklST05NRU5UICAgICAgICAgICAgICA9ICcnO1xuZGVmYXVsdHMuUkVTVF9IT1NUICAgICAgICAgICAgICAgID0gJ3Jlc3QuYWJseS5pbyc7XG5kZWZhdWx0cy5SRUFMVElNRV9IT1NUICAgICAgICAgICAgPSAncmVhbHRpbWUuYWJseS5pbyc7XG5kZWZhdWx0cy5GQUxMQkFDS19IT1NUUyAgICAgICAgICAgPSBbJ0EuYWJseS1yZWFsdGltZS5jb20nLCAnQi5hYmx5LXJlYWx0aW1lLmNvbScsICdDLmFibHktcmVhbHRpbWUuY29tJywgJ0QuYWJseS1yZWFsdGltZS5jb20nLCAnRS5hYmx5LXJlYWx0aW1lLmNvbSddO1xuZGVmYXVsdHMuUE9SVCAgICAgICAgICAgICAgICAgICAgID0gODA7XG5kZWZhdWx0cy5UTFNfUE9SVCAgICAgICAgICAgICAgICAgPSA0NDM7XG5kZWZhdWx0cy5USU1FT1VUUyA9IHtcblx0LyogRG9jdW1lbnRlZCBhcyBvcHRpb25zIHBhcmFtczogKi9cblx0ZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0ICAgOiAxNTAwMCxcblx0c3VzcGVuZGVkUmV0cnlUaW1lb3V0ICAgICAgOiAzMDAwMCxcblx0LyogVW5kb2N1bWVudGVkLCBidXQgcGFydCBvZiB0aGUgYXBpIGFuZCBjYW4gYmUgdXNlZCBieSBjdXN0b21lcnM6ICovXG5cdGh0dHBSZXF1ZXN0VGltZW91dCAgICAgICAgIDogMTUwMDAsXG5cdGNoYW5uZWxSZXRyeVRpbWVvdXQgICAgICAgIDogMTUwMDAsXG5cdGZhbGxiYWNrUmV0cnlUaW1lb3V0ICAgICAgIDogNjAwMDAwLFxuXHQvKiBGb3IgaW50ZXJuYWwgLyB0ZXN0IHVzZSBvbmx5OiAqL1xuXHRjb25uZWN0aW9uU3RhdGVUdGwgICAgICAgICA6IDEyMDAwMCxcblx0cmVhbHRpbWVSZXF1ZXN0VGltZW91dCAgICAgOiAxMDAwMCxcblx0cmVjdlRpbWVvdXQgICAgICAgICAgICAgICAgOiA5MDAwMCxcblx0cHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0ICAgOiA2MDAwLFxuXHRwYXJhbGxlbFVwZ3JhZGVEZWxheSAgICAgICA6IDYwMDBcbn07XG5kZWZhdWx0cy5odHRwTWF4UmV0cnlDb3VudCA9IDM7XG5kZWZhdWx0cy5tYXhNZXNzYWdlU2l6ZSAgICA9IDY1NTM2O1xuXG5kZWZhdWx0cy5lcnJvclJlcG9ydGluZ1VybCA9ICdodHRwczovL2Vycm9ycy5hYmx5LmlvL2FwaS8xNS9zdG9yZS8nO1xuZGVmYXVsdHMuZXJyb3JSZXBvcnRpbmdIZWFkZXJzID0ge1xuXHRcIlgtU2VudHJ5LUF1dGhcIjogXCJTZW50cnkgc2VudHJ5X3ZlcnNpb249Nywgc2VudHJ5X2tleT1hMDRlMzNjODY3NGM0NTFmOGEzMTBmYmVjMDI5YWNmNSwgc2VudHJ5X2NsaWVudD1hYmx5LWpzLzAuMVwiLFxuXHRcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxufTtcblxuZGVmYXVsdHMudmVyc2lvbiAgICAgICAgICA9ICcxLjIuNS1iZXRhLjEnO1xuZGVmYXVsdHMubGlic3RyaW5nICAgICAgICA9IHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubGlidmVyICsgJy0nICsgZGVmYXVsdHMudmVyc2lvbjtcbmRlZmF1bHRzLmFwaVZlcnNpb24gICAgICAgPSAnMS4yJztcblxuZGVmYXVsdHMuZ2V0SG9zdCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGhvc3QsIHdzKSB7XG5cdGlmKHdzKVxuXHRcdGhvc3QgPSAoKGhvc3QgPT0gb3B0aW9ucy5yZXN0SG9zdCkgJiYgb3B0aW9ucy5yZWFsdGltZUhvc3QpIHx8IGhvc3QgfHwgb3B0aW9ucy5yZWFsdGltZUhvc3Q7XG5cdGVsc2Vcblx0XHRob3N0ID0gaG9zdCB8fCBvcHRpb25zLnJlc3RIb3N0O1xuXG5cdHJldHVybiBob3N0O1xufTtcblxuZGVmYXVsdHMuZ2V0UG9ydCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRscykge1xuXHRyZXR1cm4gKHRscyB8fCBvcHRpb25zLnRscykgPyBvcHRpb25zLnRsc1BvcnQgOiBvcHRpb25zLnBvcnQ7XG59O1xuXG5kZWZhdWx0cy5nZXRIdHRwU2NoZW1lID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRyZXR1cm4gb3B0aW9ucy50bHMgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nO1xufTtcblxuLy8gY29uc3RydWN0IGVudmlyb25tZW50IGZhbGxiYWNrIGhvc3RzIGFzIHBlciBSU0MxNWlcbmRlZmF1bHRzLmVudmlyb25tZW50RmFsbGJhY2tIb3N0cyA9IGZ1bmN0aW9uKGVudmlyb25tZW50KSB7XG5cdHJldHVybiBbXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWEtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuXHRcdGVudmlyb25tZW50ICsgJy1iLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcblx0XHRlbnZpcm9ubWVudCArICctYy1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWQtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuXHRcdGVudmlyb25tZW50ICsgJy1lLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJ1xuXHRdO1xufTtcblxuZGVmYXVsdHMuZ2V0RmFsbGJhY2tIb3N0cyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0dmFyIGZhbGxiYWNrSG9zdHMgPSBvcHRpb25zLmZhbGxiYWNrSG9zdHMsXG5cdFx0aHR0cE1heFJldHJ5Q291bnQgPSB0eXBlb2Yob3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCA6IGRlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50O1xuXG5cdHJldHVybiBmYWxsYmFja0hvc3RzID8gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyQ2hvb3NlTihmYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCkgOiBbXTtcbn07XG5cbmRlZmF1bHRzLmdldEhvc3RzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRyZXR1cm4gW29wdGlvbnMucmVzdEhvc3RdLmNvbmNhdChkZWZhdWx0cy5nZXRGYWxsYmFja0hvc3RzKG9wdGlvbnMpKTtcbn07XG5cbmZ1bmN0aW9uIGNoZWNrSG9zdChob3N0KSB7XG5cdGlmKHR5cGVvZiBob3N0ICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2hvc3QgbXVzdCBiZSBhIHN0cmluZzsgd2FzIGEgJyArIHR5cGVvZiBob3N0LCA0MDAwMCwgNDAwKTtcblx0fTtcblx0aWYoIWhvc3QubGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnaG9zdCBtdXN0IG5vdCBiZSB6ZXJvLWxlbmd0aCcsIDQwMDAwLCA0MDApO1xuXHR9O1xufVxuXG5kZWZhdWx0cy5vYmplY3RpZnlPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRpZih0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiAob3B0aW9ucy5pbmRleE9mKCc6JykgPT0gLTEpID8ge3Rva2VuOiBvcHRpb25zfSA6IHtrZXk6IG9wdGlvbnN9O1xuXHR9XG5cdHJldHVybiBvcHRpb25zO1xufTtcblxuZGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0LyogRGVwcmVjYXRlZCBvcHRpb25zICovXG5cdGlmKG9wdGlvbnMuaG9zdCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdob3N0JywgJ3Jlc3RIb3N0Jyk7XG5cdFx0b3B0aW9ucy5yZXN0SG9zdCA9IG9wdGlvbnMuaG9zdDtcblx0fVxuXHRpZihvcHRpb25zLndzSG9zdCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCd3c0hvc3QnLCAncmVhbHRpbWVIb3N0Jyk7XG5cdFx0b3B0aW9ucy5yZWFsdGltZUhvc3QgPSBvcHRpb25zLndzSG9zdDtcblx0fVxuXHRpZihvcHRpb25zLnF1ZXVlRXZlbnRzKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ3F1ZXVlRXZlbnRzJywgJ3F1ZXVlTWVzc2FnZXMnKTtcblx0XHRvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSBvcHRpb25zLnF1ZXVlRXZlbnRzO1xuXHR9XG5cblx0aWYob3B0aW9ucy5mYWxsYmFja0hvc3RzVXNlRGVmYXVsdCkge1xuXHRcdC8qIGZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGFuZCBmYWxsYmFja0hvc3RzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgYXMgcGVyIFRPM2s3ICovXG5cdFx0aWYob3B0aW9ucy5mYWxsYmFja0hvc3RzKSB7XG5cdFx0XHR2YXIgbXNnID0gJ2ZhbGxiYWNrSG9zdHMgYW5kIGZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGNhbm5vdCBib3RoIGJlIHNldCc7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgbXNnKTtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDAwMCwgNDAwKTtcblx0XHR9XG5cblx0XHQvKiBkZWZhdWx0IGZhbGxiYWNrcyBjYW4ndCBiZSB1c2VkIHdpdGggY3VzdG9tIHBvcnRzICovXG5cdFx0aWYob3B0aW9ucy5wb3J0IHx8IG9wdGlvbnMudGxzUG9ydCkge1xuXHRcdFx0dmFyIG1zZyA9ICdmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCBjYW5ub3QgYmUgc2V0IHdoZW4gcG9ydCBvciB0bHNQb3J0IGFyZSBzZXQnO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsIG1zZyk7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAwMDAsIDQwMCk7XG5cdFx0fVxuXG5cdFx0LyogZW1pdCBhbiBhcHByb3ByaWF0ZSBkZXByZWNhdGlvbiB3YXJuaW5nICovXG5cdFx0aWYob3B0aW9ucy5lbnZpcm9ubWVudCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWRXaXRoTXNnKCdmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCcsICdUaGVyZSBpcyBubyBsb25nZXIgYSBuZWVkIHRvIHNldCB0aGlzIHdoZW4gdGhlIGVudmlyb25tZW50IG9wdGlvbiBpcyBhbHNvIHNldCBzaW5jZSB0aGUgbGlicmFyeSB3aWxsIG5vdyBnZW5lcmF0ZSB0aGUgY29ycmVjdCBmYWxsYmFjayBob3N0cyB1c2luZyB0aGUgZW52aXJvbm1lbnQgb3B0aW9uLicpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQnLCAnZmFsbGJhY2tIb3N0czogQWJseS5EZWZhdWx0cy5GQUxMQkFDS19IT1NUUycpO1xuXHRcdH1cblxuXHRcdC8qIHVzZSB0aGUgZGVmYXVsdCBmYWxsYmFjayBob3N0cyBhcyByZXF1ZXN0ZWQgKi9cblx0XHRvcHRpb25zLmZhbGxiYWNrSG9zdHMgPSBkZWZhdWx0cy5GQUxMQkFDS19IT1NUUztcblx0fVxuXG5cdGlmKG9wdGlvbnMucmVjb3ZlciA9PT0gdHJ1ZSkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCd7cmVjb3ZlcjogdHJ1ZX0nLCAne3JlY292ZXI6IGZ1bmN0aW9uKGxhc3RDb25uZWN0aW9uRGV0YWlscywgY2IpIHsgY2IodHJ1ZSk7IH19Jyk7XG5cdFx0b3B0aW9ucy5yZWNvdmVyID0gZnVuY3Rpb24obGFzdENvbm5lY3Rpb25EZXRhaWxzLCBjYikgeyBjYih0cnVlKTsgfTtcblx0fVxuXG5cdGlmKHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID09PSB0cnVlKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICdjbG9zZU9uVW5sb2FkIHdhcyB0cnVlIGFuZCBhIHNlc3Npb24gcmVjb3ZlcnkgZnVuY3Rpb24gd2FzIHNldCAtIHRoZXNlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIHVuc2V0dGluZyB0aGUgbGF0dGVyJyk7XG5cdFx0b3B0aW9ucy5yZWNvdmVyID0gbnVsbDtcblx0fVxuXG5cdGlmKCEoJ2Nsb3NlT25VbmxvYWQnIGluIG9wdGlvbnMpKSB7XG5cdFx0LyogSGF2ZSBjbG9zZU9uVW5sb2FkIGRlZmF1bHQgdG8gdHJ1ZSB1bmxlc3Mgd2UgaGF2ZSBhbnkgaW5kaWNhdGlvbiB0aGF0XG5cdFx0ICogdGhlIHVzZXIgbWF5IHdhbnQgdG8gcmVjb3ZlciB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdG9wdGlvbnMuY2xvc2VPblVubG9hZCA9ICFvcHRpb25zLnJlY292ZXI7XG5cdH1cblxuXHRpZihvcHRpb25zLnRyYW5zcG9ydHMgJiYgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJySW4ob3B0aW9ucy50cmFuc3BvcnRzLCAneGhyJykpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgndHJhbnNwb3J0czogW1wieGhyXCJdJywgJ3RyYW5zcG9ydHM6IFtcInhocl9zdHJlYW1pbmdcIl0nKTtcblx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJEZWxldGVWYWx1ZShvcHRpb25zLnRyYW5zcG9ydHMsICd4aHInKTtcblx0XHRvcHRpb25zLnRyYW5zcG9ydHMucHVzaCgneGhyX3N0cmVhbWluZycpO1xuXHR9XG5cblx0aWYoISgncXVldWVNZXNzYWdlcycgaW4gb3B0aW9ucykpXG5cdFx0b3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gdHJ1ZTtcblxuXHQvKiBpbmZlciBob3N0cyBhbmQgZmFsbGJhY2tzIGJhc2VkIG9uIHRoZSBjb25maWd1cmVkIGVudmlyb25tZW50ICovXG5cdHZhciBlbnZpcm9ubWVudCA9IChvcHRpb25zLmVudmlyb25tZW50ICYmIFN0cmluZyhvcHRpb25zLmVudmlyb25tZW50KS50b0xvd2VyQ2FzZSgpKSB8fCBkZWZhdWx0cy5FTlZJUk9OTUVOVDtcblx0dmFyIHByb2R1Y3Rpb24gPSAhZW52aXJvbm1lbnQgfHwgKGVudmlyb25tZW50ID09PSAncHJvZHVjdGlvbicpO1xuXG5cdGlmKCFvcHRpb25zLmZhbGxiYWNrSG9zdHMgJiYgIW9wdGlvbnMucmVzdEhvc3QgJiYgIW9wdGlvbnMucmVhbHRpbWVIb3N0ICYmICFvcHRpb25zLnBvcnQgJiYgIW9wdGlvbnMudGxzUG9ydCkge1xuXHRcdG9wdGlvbnMuZmFsbGJhY2tIb3N0cyA9IHByb2R1Y3Rpb24gPyBkZWZhdWx0cy5GQUxMQkFDS19IT1NUUyA6IGRlZmF1bHRzLmVudmlyb25tZW50RmFsbGJhY2tIb3N0cyhlbnZpcm9ubWVudCk7XG5cdH1cblxuXHRpZighb3B0aW9ucy5yZWFsdGltZUhvc3QpIHtcblx0XHQvKiBwcmVmZXIgc2V0dGluZyByZWFsdGltZUhvc3QgdG8gcmVzdEhvc3QgYXMgYSBjdXN0b20gcmVzdEhvc3QgdHlwaWNhbGx5IGluZGljYXRlc1xuXHRcdCAqIGEgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnQgaXMgYmVpbmcgdXNlZCB0aGF0IGNhbid0IGJlIGluZmVycmVkIGJ5IHRoZSBsaWJyYXJ5ICovXG5cdFx0aWYob3B0aW9ucy5yZXN0SG9zdCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX1dBUk4sICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgJ3Jlc3RIb3N0IGlzIHNldCB0byBcIicgKyBvcHRpb25zLnJlc3RIb3N0ICsgJ1wiIGJ1dCByZWFsdGltZUhvc3QgaXMgbm90IHNldCwgc28gc2V0dGluZyByZWFsdGltZUhvc3QgdG8gXCInICsgb3B0aW9ucy5yZXN0SG9zdCArICdcIiB0b28uIElmIHRoaXMgaXMgbm90IHdoYXQgeW91IHdhbnQsIHBsZWFzZSBzZXQgcmVhbHRpbWVIb3N0IGV4cGxpY2l0bHkuJyk7XG5cdFx0XHRvcHRpb25zLnJlYWx0aW1lSG9zdCA9IG9wdGlvbnMucmVzdEhvc3Rcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3B0aW9ucy5yZWFsdGltZUhvc3QgPSBwcm9kdWN0aW9uID8gZGVmYXVsdHMuUkVBTFRJTUVfSE9TVCA6IGVudmlyb25tZW50ICsgJy0nICsgZGVmYXVsdHMuUkVBTFRJTUVfSE9TVDtcblx0XHR9XG5cdH1cblxuXHRpZighb3B0aW9ucy5yZXN0SG9zdCkge1xuXHRcdG9wdGlvbnMucmVzdEhvc3QgPSBwcm9kdWN0aW9uID8gZGVmYXVsdHMuUkVTVF9IT1NUIDogZW52aXJvbm1lbnQgKyAnLScgKyBkZWZhdWx0cy5SRVNUX0hPU1Q7XG5cdH1cblxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKChvcHRpb25zLmZhbGxiYWNrSG9zdHMgfHwgW10pLmNvbmNhdChvcHRpb25zLnJlc3RIb3N0LCBvcHRpb25zLnJlYWx0aW1lSG9zdCksIGNoZWNrSG9zdCk7XG5cblx0b3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wb3J0IHx8IGRlZmF1bHRzLlBPUlQ7XG5cdG9wdGlvbnMudGxzUG9ydCA9IG9wdGlvbnMudGxzUG9ydCB8fCBkZWZhdWx0cy5UTFNfUE9SVDtcblx0b3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSA9IG9wdGlvbnMubWF4TWVzc2FnZVNpemUgfHwgZGVmYXVsdHMubWF4TWVzc2FnZVNpemU7XG5cdGlmKCEoJ3RscycgaW4gb3B0aW9ucykpIG9wdGlvbnMudGxzID0gdHJ1ZTtcblxuXHQvKiBBbGxvdyB2YWx1ZXMgcGFzc2VkIGluIG9wdGlvbnMgdG8gb3ZlcnJpZGUgZGVmYXVsdCB0aW1lb3V0cyAqL1xuXHRvcHRpb25zLnRpbWVvdXRzID0ge307XG5cdGZvcih2YXIgcHJvcCBpbiBkZWZhdWx0cy5USU1FT1VUUykge1xuXHRcdG9wdGlvbnMudGltZW91dHNbcHJvcF0gPSBvcHRpb25zW3Byb3BdIHx8IGRlZmF1bHRzLlRJTUVPVVRTW3Byb3BdO1xuXHR9O1xuXG5cdGlmKCd1c2VCaW5hcnlQcm90b2NvbCcgaW4gb3B0aW9ucykge1xuXHRcdG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzQmluYXJ5ICYmIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2w7XG5cdH0gZWxzZSB7XG5cdFx0b3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJlZmVyQmluYXJ5O1xuXHR9XG5cblx0aWYob3B0aW9ucy5jbGllbnRJZCkge1xuXHRcdHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuXHRcdGhlYWRlcnNbJ1gtQWJseS1DbGllbnRJZCddID0gYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYmFzZTY0RW5jb2RlKGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnV0ZjhFbmNvZGUob3B0aW9ucy5jbGllbnRJZCkpO1xuXHR9XG5cblx0aWYoISgnaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nJyBpbiBvcHRpb25zKSkge1xuXHRcdG9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gdHJ1ZTtcblx0fVxuXG5cdGlmKG9wdGlvbnMucHJvbWlzZXMgJiYgIXBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uUHJvbWlzZSkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCAne3Byb21pc2VzOiB0cnVlfSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gUHJvbWlzZSBjb25zdHJ1Y3RvciBmb3VuZDsgZGlzYWJsaW5nIHByb21pc2VzJyk7XG5cdFx0b3B0aW9ucy5wcm9taXNlcyA9IGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1dGlsX2RlZmF1bHRzID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoZGVmYXVsdHMpO1xuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblxuXG52YXIgSHR0cCA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdGZ1bmN0aW9uIEh0dHAoKSB7fVxuXG5cdHZhciBub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcblx0XHQvKiBJRSA4ICovXG5cdFx0cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHNob3VsZEZhbGxiYWNrKGVycikge1xuXHRcdHZhciBzdGF0dXNDb2RlID0gZXJyLnN0YXR1c0NvZGU7XG5cdFx0LyogNDAwICsgbm8gY29kZSA9IGEgZ2VuZXJpYyB4aHIgb25lcnJvci4gQnJvd3NlciBkb2Vzbid0IGdpdmUgdXMgZW5vdWdoXG5cdFx0ICogZGV0YWlsIHRvIGtub3cgd2hldGhlciBpdCdzIGZhbGxiYWNrLWZpeGFibGUsIGJ1dCBpdCBtYXkgYmUgKGVnIGlmIGFcblx0XHQgKiBuZXR3b3JrIGlzc3VlKSwgc28gdHJ5IGp1c3QgaW4gY2FzZSAqL1xuXHRcdHJldHVybiAoc3RhdHVzQ29kZSA9PT0gNDA4ICYmICFlcnIuY29kZSkgfHxcblx0XHRcdChzdGF0dXNDb2RlID09PSA0MDAgJiYgIWVyci5jb2RlKSAgICAgIHx8XG5cdFx0XHQoc3RhdHVzQ29kZSA+PSA1MDAgJiYgc3RhdHVzQ29kZSA8PSA1MDQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SG9zdHMoY2xpZW50KSB7XG5cdFx0LyogSWYgd2UncmUgYSBjb25uZWN0ZWQgcmVhbHRpbWUgY2xpZW50LCB0cnkgdGhlIGVuZHBvaW50IHdlJ3JlIGNvbm5lY3RlZFxuXHRcdCAqIHRvIGZpcnN0IC0tIGJ1dCBzdGlsbCBoYXZlIGZhbGxiYWNrcywgYmVpbmcgY29ubmVjdGVkIGlzIG5vdCBhbiBhYnNvbHV0ZVxuXHRcdCAqIGd1YXJhbnRlZSB0aGF0IGEgZGF0YWNlbnRlciBoYXMgZnJlZSBjYXBhY2l0eSB0byBzZXJ2aWNlIFJFU1QgcmVxdWVzdHMuICovXG5cdFx0dmFyIGNvbm5lY3Rpb24gPSBjbGllbnQuY29ubmVjdGlvbixcblx0XHRcdGNvbm5lY3Rpb25Ib3N0ID0gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLmhvc3Q7XG5cblx0XHRpZihjb25uZWN0aW9uSG9zdCkge1xuXHRcdFx0cmV0dXJuIFtjb25uZWN0aW9uSG9zdF0uY29uY2F0KF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRGYWxsYmFja0hvc3RzKGNsaWVudC5vcHRpb25zKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRIb3N0cyhjbGllbnQub3B0aW9ucyk7XG5cdH1cblx0SHR0cC5fZ2V0SG9zdHMgPSBnZXRIb3N0cztcblxuXHRIdHRwLm1ldGhvZHMgPSBbJ2dldCcsICdkZWxldGUnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnXTtcblx0SHR0cC5tZXRob2RzV2l0aG91dEJvZHkgPSBbJ2dldCcsICdkZWxldGUnXTtcblx0SHR0cC5tZXRob2RzV2l0aEJvZHkgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyU3VidHJhY3QoSHR0cC5tZXRob2RzLCBIdHRwLm1ldGhvZHNXaXRob3V0Qm9keSk7XG5cblx0LyogLSBIdHRwLmdldCwgSHR0cC5wb3N0LCBIdHRwLnB1dCwgLi4uXG5cdCAqIFBlcmZvcm0gYW4gSFRUUCByZXF1ZXN0IGZvciBhIGdpdmVuIHBhdGggYWdhaW5zdCBwcmltZSBhbmQgZmFsbGJhY2sgQWJseSBob3N0c1xuXHQgKiBAcGFyYW0gcmVzdFxuXHQgKiBAcGFyYW0gcGF0aCB0aGUgZnVsbCBwYXRoXG5cdCAqIEBwYXJhbSBoZWFkZXJzIG9wdGlvbmFsIGhhc2ggb2YgaGVhZGVyc1xuXHQgKiBbb25seSBmb3IgbWV0aG9kcyB3aXRoIGJvZHk6IEBwYXJhbSBib2R5IG9iamVjdCBvciBidWZmZXIgY29udGFpbmluZyByZXF1ZXN0IGJvZHldXG5cdCAqIEBwYXJhbSBwYXJhbXMgb3B0aW9uYWwgaGFzaCBvZiBwYXJhbXNcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHJlc3BvbnNlKVxuXHQgKlxuXHQgKiAtIEh0dHAuZ2V0VXJpLCBIdHRwLnBvc3RVcmksIEh0dHAucHV0VXJpLCAuLi5cblx0ICogUGVyZm9ybSBhbiBIVFRQIHJlcXVlc3QgZm9yIGEgZ2l2ZW4gZnVsbCBVUklcblx0ICogQHBhcmFtIHJlc3Rcblx0ICogQHBhcmFtIHVyaSB0aGUgZnVsbCBVUklcblx0ICogQHBhcmFtIGhlYWRlcnMgb3B0aW9uYWwgaGFzaCBvZiBoZWFkZXJzXG5cdCAqIFtvbmx5IGZvciBtZXRob2RzIHdpdGggYm9keTogQHBhcmFtIGJvZHkgb2JqZWN0IG9yIGJ1ZmZlciBjb250YWluaW5nIHJlcXVlc3QgYm9keV1cblx0ICogQHBhcmFtIHBhcmFtcyBvcHRpb25hbCBoYXNoIG9mIHBhcmFtc1xuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwgcmVzcG9uc2UpXG5cdCAqL1xuXHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChIdHRwLm1ldGhvZHNXaXRob3V0Qm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XG5cdFx0SHR0cFttZXRob2RdID0gZnVuY3Rpb24ocmVzdCwgcGF0aCwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdFx0SHR0cFsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIGhlYWRlcnMsIG51bGwsIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdH07XG5cdFx0SHR0cFttZXRob2QgKyAnVXJpJ10gPSBmdW5jdGlvbihyZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdEh0dHAuZG9VcmkobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIG51bGwsIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdH07XG5cdH0pO1xuXG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKEh0dHAubWV0aG9kc1dpdGhCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRIdHRwW21ldGhvZF0gPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRIdHRwWydkbyddKG1ldGhvZCwgcmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0fTtcblx0XHRIdHRwW21ldGhvZCArICdVcmknXSA9IGZ1bmN0aW9uKHJlc3QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdFx0SHR0cC5kb1VyaShtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0fTtcblx0fSk7XG5cblx0LyogVW5saWtlIGZvciBkb1VyaSwgdGhlICdyZXN0JyBwYXJhbSBoZXJlIGlzIG1hbmRhdG9yeSwgYXMgaXQncyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBob3N0cyAqL1xuXHRIdHRwWydkbyddID0gZnVuY3Rpb24obWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXHRcdHZhciB1cmlGcm9tSG9zdCA9ICh0eXBlb2YocGF0aCkgPT0gJ2Z1bmN0aW9uJykgPyBwYXRoIDogZnVuY3Rpb24oaG9zdCkgeyByZXR1cm4gcmVzdC5iYXNlVXJpKGhvc3QpICsgcGF0aDsgfTtcblx0XHR2YXIgYmluYXJ5ID0gKGhlYWRlcnMgJiYgaGVhZGVycy5hY2NlcHQgIT0gJ2FwcGxpY2F0aW9uL2pzb24nKTtcblx0XHR2YXIgZG9BcmdzID0gYXJndW1lbnRzO1xuXG5cdFx0dmFyIGN1cnJlbnRGYWxsYmFjayA9IHJlc3QuX2N1cnJlbnRGYWxsYmFjaztcblx0XHRpZihjdXJyZW50RmFsbGJhY2spIHtcblx0XHRcdGlmKGN1cnJlbnRGYWxsYmFjay52YWxpZFVudGlsID4gbm93KCkpIHtcblx0XHRcdFx0LyogVXNlIHN0b3JlZCBmYWxsYmFjayAqL1xuXHRcdFx0XHRIdHRwLlJlcXVlc3QobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChjdXJyZW50RmFsbGJhY2suaG9zdCksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0aWYoZXJyICYmIHNob3VsZEZhbGxiYWNrKGVycikpIHtcblx0XHRcdFx0XHRcdC8qIHVuc3RvcmUgdGhlIGZhbGxiYWNrIGFuZCBzdGFydCBmcm9tIHRoZSB0b3Agd2l0aCB0aGUgZGVmYXVsdCBzZXF1ZW5jZSAqL1xuXHRcdFx0XHRcdFx0cmVzdC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdEh0dHBbJ2RvJ10uYXBwbHkoSHR0cCwgZG9BcmdzKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIEZhbGxiYWNrIGV4cGlyZWQ7IHJlbW92ZSBpdCBhbmQgZmFsbHRocm91Z2ggdG8gbm9ybWFsIHNlcXVlbmNlICovXG5cdFx0XHRcdHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGhvc3RzID0gZ2V0SG9zdHMocmVzdCk7XG5cblx0XHQvKiBpZiB0aGVyZSBpcyBvbmx5IG9uZSBob3N0IGRvIGl0ICovXG5cdFx0aWYoaG9zdHMubGVuZ3RoID09IDEpIHtcblx0XHRcdEh0dHAuZG9VcmkobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChob3N0c1swXSksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIGhvc3RzIGlzIGFuIGFycmF5IHdpdGggcHJlZmVycmVkIGhvc3QgcGx1cyBhdCBsZWFzdCBvbmUgZmFsbGJhY2sgKi9cblx0XHR2YXIgdHJ5QUhvc3QgPSBmdW5jdGlvbihjYW5kaWRhdGVIb3N0cywgcGVyc2lzdE9uU3VjY2Vzcykge1xuXHRcdFx0dmFyIGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuXHRcdFx0SHR0cC5kb1VyaShtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZihlcnIgJiYgc2hvdWxkRmFsbGJhY2soZXJyKSAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHR0cnlBSG9zdChjYW5kaWRhdGVIb3N0cywgdHJ1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHBlcnNpc3RPblN1Y2Nlc3MpIHtcblx0XHRcdFx0XHQvKiBSU0MxNWYgKi9cblx0XHRcdFx0XHRyZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSB7XG5cdFx0XHRcdFx0XHRob3N0OiBob3N0LFxuXHRcdFx0XHRcdFx0dmFsaWRVbnRpbDogbm93KCkgKyByZXN0Lm9wdGlvbnMudGltZW91dHMuZmFsbGJhY2tSZXRyeVRpbWVvdXRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHRcdHRyeUFIb3N0KGhvc3RzKTtcblx0fTtcblxuXHRIdHRwLmRvVXJpID0gZnVuY3Rpb24obWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRIdHRwLlJlcXVlc3QobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spO1xuXHR9O1xuXG5cdEh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycyA9IGZhbHNlO1xuXHRIdHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPSBmYWxzZTtcblx0cmV0dXJuIEh0dHA7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEh0dHApO1xuXG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuXG5cblxudmFyIEV2ZW50RW1pdHRlciA9IChmdW5jdGlvbigpIHtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuXHRcdHRoaXMuYW55ID0gW107XG5cdFx0dGhpcy5ldmVudHMgPSB7fTtcblx0XHR0aGlzLmFueU9uY2UgPSBbXTtcblx0XHR0aGlzLmV2ZW50c09uY2UgPSB7fTtcblx0fVxuXG5cdC8qIENhbGwgdGhlIGxpc3RlbmVyLCBjYXRjaCBhbnkgZXhjZXB0aW9ucyBhbmQgbG9nLCBidXQgY29udGludWUgb3BlcmF0aW9uKi9cblx0ZnVuY3Rpb24gY2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpIHtcblx0XHR0cnkge1xuXHRcdFx0bGlzdGVuZXIuYXBwbHkoZXZlbnRUaGlzLCBhcmdzKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0V2ZW50RW1pdHRlci5lbWl0KCknLCAnVW5leHBlY3RlZCBsaXN0ZW5lciBleGNlcHRpb246ICcgKyBlICsgJzsgc3RhY2sgPSAnICsgKGUgJiYgZS5zdGFjaykpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggbGlzdGVuZXJcblx0ICogQHBhcmFtIHRhcmdldExpc3RlbmVycyBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBhcnJheXMgb3IgZXZlbnQgb2JqZWN0cyB3aXRoIGFycmF5cyBvZiBsaXN0ZW5lcnNcblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciBjYWxsYmFjayB0byByZW1vdmVcblx0ICogQHBhcmFtIGV2ZW50RmlsdGVyIChvcHRpb25hbCkgZXZlbnQgbmFtZSBpbnN0cnVjdGluZyB0aGUgZnVuY3Rpb24gdG8gb25seSByZW1vdmUgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0YXJnZXRMaXN0ZW5lcnMsIGxpc3RlbmVyLCBldmVudEZpbHRlcikge1xuXHRcdHZhciBsaXN0ZW5lcnMsIGlkeCwgZXZlbnROYW1lLCB0YXJnZXRMaXN0ZW5lcnNJbmRleDtcblxuXHRcdGZvciAodGFyZ2V0TGlzdGVuZXJzSW5kZXggPSAwOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCA8IHRhcmdldExpc3RlbmVycy5sZW5ndGg7IHRhcmdldExpc3RlbmVyc0luZGV4KyspIHtcblx0XHRcdGxpc3RlbmVycyA9IHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF07XG5cdFx0XHRpZiAoZXZlbnRGaWx0ZXIpIHsgbGlzdGVuZXJzID0gbGlzdGVuZXJzW2V2ZW50RmlsdGVyXTsgfVxuXG5cdFx0XHRpZiAoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShsaXN0ZW5lcnMpKSB7XG5cdFx0XHRcdHdoaWxlICgoaWR4ID0gX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZihsaXN0ZW5lcnMsIGxpc3RlbmVyKSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qIElmIGV2ZW50cyBvYmplY3QgaGFzIGFuIGV2ZW50IG5hbWUga2V5IHdpdGggbm8gbGlzdGVuZXJzIHRoZW5cblx0XHRcdFx0ICAgcmVtb3ZlIHRoZSBrZXkgdG8gc3RvcCB0aGUgbGlzdCBncm93aW5nIGluZGVmaW5pdGVseSAqL1xuXHRcdFx0XHRpZiAoZXZlbnRGaWx0ZXIgJiYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF1bZXZlbnRGaWx0ZXJdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzT2JqZWN0KGxpc3RlbmVycykpIHtcblx0XHRcdFx0LyogZXZlbnRzICovXG5cdFx0XHRcdGZvciAoZXZlbnROYW1lIGluIGxpc3RlbmVycykge1xuXHRcdFx0XHRcdGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSAmJiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGxpc3RlbmVyc1tldmVudE5hbWVdKSkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlTGlzdGVuZXIoW2xpc3RlbmVyc10sIGxpc3RlbmVyLCBldmVudE5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcblx0ICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0b1xuXHQgKiAgICAgICAgaWYgbm90IHN1cHBsaWVkLCBhbGwgZXZlbnRzIHRyaWdnZXIgYSBjYWxsIHRvIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIGJlIGNhbGxlZFxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiB0eXBlb2YoZXZlbnQpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMuYW55LnB1c2goZXZlbnQpO1xuXHRcdH0gZWxzZSBpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGV2ZW50KSkge1xuXHRcdFx0dGhpcy5hbnkucHVzaChsaXN0ZW5lcik7XG5cdFx0fSBlbHNlIGlmKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkoZXZlbnQpKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKGV2ZW50LCBmdW5jdGlvbihldikge1xuXHRcdFx0XHRzZWxmLm9uKGV2LCBsaXN0ZW5lcik7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9ICh0aGlzLmV2ZW50c1tldmVudF0gfHwgKHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtdKSk7XG5cdFx0XHRsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgb25lIG9yIG1vcmUgZXZlbnQgbGlzdGVuZXJzXG5cdCAqIEBwYXJhbSBldmVudCAob3B0aW9uYWwpIHRoZSBuYW1lIG9mIHRoZSBldmVudCB3aG9zZSBsaXN0ZW5lclxuXHQgKiAgICAgICAgaXMgdG8gYmUgcmVtb3ZlZC4gSWYgbm90IHN1cHBsaWVkLCB0aGUgbGlzdGVuZXIgaXNcblx0ICogICAgICAgIHRyZWF0ZWQgYXMgYW4gJ2FueScgbGlzdGVuZXJcblx0ICogQHBhcmFtIGxpc3RlbmVyIChvcHRpb25hbCkgdGhlIGxpc3RlbmVyIHRvIHJlbW92ZS4gSWYgbm90XG5cdCAqICAgICAgICBzdXBwbGllZCwgYWxsIGxpc3RlbmVycyBhcmUgcmVtb3ZlZC5cblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwIHx8IChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGV2ZW50KSAmJiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGxpc3RlbmVyKSkpIHtcblx0XHRcdHRoaXMuYW55ID0gW107XG5cdFx0XHR0aGlzLmV2ZW50cyA9IHt9O1xuXHRcdFx0dGhpcy5hbnlPbmNlID0gW107XG5cdFx0XHR0aGlzLmV2ZW50c09uY2UgPSB7fTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRpZih0eXBlb2YoZXZlbnQpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Lyogd2UgdGFrZSB0aGlzIHRvIGJlIHRoZSBsaXN0ZW5lciBhbmQgdHJlYXQgdGhlIGV2ZW50IGFzIFwiYW55XCIgLi4gKi9cblx0XHRcdFx0bGlzdGVuZXIgPSBldmVudDtcblx0XHRcdFx0ZXZlbnQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0LyogLi4uIG9yIHdlIHRha2UgZXZlbnQgdG8gYmUgdGhlIGFjdHVhbCBldmVudCBuYW1lIGFuZCBsaXN0ZW5lciB0byBiZSBhbGwgKi9cblx0XHR9XG5cblx0XHRpZihsaXN0ZW5lciAmJiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGV2ZW50KSkge1xuXHRcdFx0cmVtb3ZlTGlzdGVuZXIoW3RoaXMuYW55LCB0aGlzLmV2ZW50cywgdGhpcy5hbnlPbmNlLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShldmVudCkpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goZXZlbnQsIGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdHNlbGYub2ZmKGV2LCBsaXN0ZW5lcik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKiBcIm5vcm1hbFwiIGNhc2Ugd2hlcmUgZXZlbnQgaXMgYW4gYWN0dWFsIGV2ZW50ICovXG5cdFx0aWYobGlzdGVuZXIpIHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKFt0aGlzLmV2ZW50cywgdGhpcy5ldmVudHNPbmNlXSwgbGlzdGVuZXIsIGV2ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIHRoaXMuZXZlbnRzW2V2ZW50XTtcblx0XHRcdGRlbGV0ZSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gZXZlbnQ7IGV4Y2x1ZGVzIG9uY2UgZXZlbnRzXG5cdCAqIEBwYXJhbSBldmVudCAob3B0aW9uYWwpIHRoZSBuYW1lIG9mIHRoZSBldmVudCwgb3Igbm9uZSBmb3IgJ2FueSdcblx0ICogQHJldHVybiBhcnJheSBvZiBldmVudHMsIG9yIG51bGwgaWYgbm9uZVxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmKGV2ZW50KSB7XG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gKHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXSk7XG5cdFx0XHRpZih0aGlzLmV2ZW50c09uY2VbZXZlbnRdKVxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuZXZlbnRzT25jZVtldmVudF0pO1xuXHRcdFx0cmV0dXJuIGxpc3RlbmVycy5sZW5ndGggPyBsaXN0ZW5lcnMgOiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5hbnkubGVuZ3RoID8gdGhpcy5hbnkgOiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbWl0IGFuIGV2ZW50XG5cdCAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0gYXJncyB0aGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGxpc3RlbmVyXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCAgLyogLCBhcmdzLi4uICovKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdHZhciBldmVudFRoaXMgPSB7ZXZlbnQ6ZXZlbnR9O1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuXHRcdGlmKHRoaXMuYW55T25jZS5sZW5ndGgpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnlPbmNlKTtcblx0XHRcdHRoaXMuYW55T25jZSA9IFtdO1xuXHRcdH1cblx0XHRpZih0aGlzLmFueS5sZW5ndGgpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgdGhpcy5hbnkpO1xuXHRcdH1cblx0XHR2YXIgZXZlbnRzT25jZUxpc3RlbmVycyA9IHRoaXMuZXZlbnRzT25jZVtldmVudF07XG5cdFx0aWYoZXZlbnRzT25jZUxpc3RlbmVycykge1xuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCBldmVudHNPbmNlTGlzdGVuZXJzKTtcblx0XHRcdGRlbGV0ZSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuXHRcdH1cblx0XHR2YXIgZXZlbnRzTGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xuXHRcdGlmKGV2ZW50c0xpc3RlbmVycykge1xuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCBldmVudHNMaXN0ZW5lcnMpO1xuXHRcdH1cblxuXHRcdF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lcikge1xuXHRcdFx0Y2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaXN0ZW4gZm9yIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYW4gZXZlbnRcblx0ICogQHBhcmFtIGV2ZW50IHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9cblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBiZSBjYWxsZWRcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsIHNlbGYgPSB0aGlzO1xuXHRcdGlmKChhcmdDb3VudCA9PT0gMCB8fCAoYXJnQ291bnQgPT09IDEgJiYgdHlwZW9mIGV2ZW50ICE9PSAnZnVuY3Rpb24nKSkgJiYgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5Qcm9taXNlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG5cdFx0XHRcdHNlbGYub25jZShldmVudCwgcmVzb2x2ZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIHR5cGVvZihldmVudCkgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5hbnlPbmNlLnB1c2goZXZlbnQpO1xuXHRcdH0gZWxzZSBpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGV2ZW50KSkge1xuXHRcdFx0dGhpcy5hbnlPbmNlLnB1c2gobGlzdGVuZXIpO1xuXHRcdH0gZWxzZSBpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGV2ZW50KSl7XG5cdFx0XHR0aHJvdyhcIkFycmF5cyBvZiBldmVudHMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIG9uKCksIG5vdCBvbmNlKClcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSAodGhpcy5ldmVudHNPbmNlW2V2ZW50XSB8fCAodGhpcy5ldmVudHNPbmNlW2V2ZW50XSA9IFtdKSk7XG5cdFx0XHRsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcml2YXRlIEFQSVxuXHQgKlxuXHQgKiBMaXN0ZW4gZm9yIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYSBzdGF0ZSBldmVudCBhbmQgZmlyZSBpbW1lZGlhdGVseSBpZiBjdXJyZW50U3RhdGUgbWF0Y2hlcyB0YXJnZXRTdGF0ZVxuXHQgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIGV2ZW50IHRvIGxpc3RlbiB0b1xuXHQgKiBAcGFyYW0gY3VycmVudFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgb2JqZWN0XG5cdCAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gYmUgY2FsbGVkXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLndoZW5TdGF0ZSA9IGZ1bmN0aW9uKHRhcmdldFN0YXRlLCBjdXJyZW50U3RhdGUsIGxpc3RlbmVyIC8qIC4uLmxpc3RlbmVyQXJncyAqLykge1xuXHRcdHZhciBldmVudFRoaXMgPSB7ZXZlbnQ6dGFyZ2V0U3RhdGV9LFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRsaXN0ZW5lckFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG5cdFx0aWYoKHR5cGVvZih0YXJnZXRTdGF0ZSkgIT09ICdzdHJpbmcnKSB8fCAodHlwZW9mKGN1cnJlbnRTdGF0ZSkgIT09ICdzdHJpbmcnKSkge1xuXHRcdFx0dGhyb3coXCJ3aGVuU3RhdGUgcmVxdWlyZXMgYSB2YWxpZCBldmVudCBTdHJpbmcgYXJndW1lbnRcIik7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJyAmJiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlByb21pc2UpIHtcblx0XHRcdHJldHVybiBuZXcgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0XHRcdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS53aGVuU3RhdGUuYXBwbHkoc2VsZiwgW3RhcmdldFN0YXRlLCBjdXJyZW50U3RhdGUsIHJlc29sdmVdLmNvbmNhdChsaXN0ZW5lckFyZ3MpKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZih0YXJnZXRTdGF0ZSA9PT0gY3VycmVudFN0YXRlKSB7XG5cdFx0XHRjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgbGlzdGVuZXJBcmdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vbmNlKHRhcmdldFN0YXRlLCBsaXN0ZW5lcik7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRXZlbnRFbWl0dGVyKTtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJlc2VuY2VtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXG5cblxuXG52YXIgUHJvdG9jb2xNZXNzYWdlID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIFByb3RvY29sTWVzc2FnZSgpIHtcblx0XHR0aGlzLmFjdGlvbiA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmZsYWdzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb3VudCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jaGFubmVsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2hhbm5lbFNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm1zZ1NlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm1lc3NhZ2VzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucHJlc2VuY2UgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5hdXRoID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucGFyYW1zID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0dmFyIGFjdGlvbnMgPSBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uID0ge1xuXHRcdCdIRUFSVEJFQVQnIDogMCxcblx0XHQnQUNLJyA6IDEsXG5cdFx0J05BQ0snIDogMixcblx0XHQnQ09OTkVDVCcgOiAzLFxuXHRcdCdDT05ORUNURUQnIDogNCxcblx0XHQnRElTQ09OTkVDVCcgOiA1LFxuXHRcdCdESVNDT05ORUNURUQnIDogNixcblx0XHQnQ0xPU0UnIDogNyxcblx0XHQnQ0xPU0VEJyA6IDgsXG5cdFx0J0VSUk9SJyA6IDksXG5cdFx0J0FUVEFDSCcgOiAxMCxcblx0XHQnQVRUQUNIRUQnIDogMTEsXG5cdFx0J0RFVEFDSCcgOiAxMixcblx0XHQnREVUQUNIRUQnIDogMTMsXG5cdFx0J1BSRVNFTkNFJyA6IDE0LFxuXHRcdCdNRVNTQUdFJyA6IDE1LFxuXHRcdCdTWU5DJyA6IDE2LFxuXHRcdCdBVVRIJyA6IDE3XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLmNoYW5uZWxNb2RlcyA9IFsgJ1BSRVNFTkNFJywgJ1BVQkxJU0gnLCAnU1VCU0NSSUJFJywgJ1BSRVNFTkNFX1NVQlNDUklCRScgXTtcblxuXHRQcm90b2NvbE1lc3NhZ2UuQWN0aW9uTmFtZSA9IFtdO1xuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5rZXlzQXJyYXkoUHJvdG9jb2xNZXNzYWdlLkFjdGlvbiwgdHJ1ZSksIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRQcm90b2NvbE1lc3NhZ2UuQWN0aW9uTmFtZVthY3Rpb25zW25hbWVdXSA9IG5hbWU7XG5cdH0pO1xuXG5cdHZhciBmbGFncyA9IHtcblx0XHQvKiBDaGFubmVsIGF0dGFjaCBzdGF0ZSBmbGFncyAqL1xuXHRcdCdIQVNfUFJFU0VOQ0UnOiAgICAgICAxIDw8IDAsXG5cdFx0J0hBU19CQUNLTE9HJzogICAgICAgIDEgPDwgMSxcblx0XHQnUkVTVU1FRCc6ICAgICAgICAgICAgMSA8PCAyLFxuXHRcdCdUUkFOU0lFTlQnOiAgICAgICAgICAxIDw8IDQsXG5cdFx0J0FUVEFDSF9SRVNVTUUnOiAgICAgIDEgPDwgNSxcblx0XHQvKiBDaGFubmVsIG1vZGUgZmxhZ3MgKi9cblx0XHQnUFJFU0VOQ0UnOiAgICAgICAgICAgMSA8PCAxNixcblx0XHQnUFVCTElTSCc6ICAgICAgICAgICAgMSA8PCAxNyxcblx0XHQnU1VCU0NSSUJFJzogICAgICAgICAgMSA8PCAxOCxcblx0XHQnUFJFU0VOQ0VfU1VCU0NSSUJFJzogMSA8PCAxOVxuXHR9O1xuXHR2YXIgZmxhZ05hbWVzID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5rZXlzQXJyYXkoZmxhZ3MpO1xuXHRmbGFncy5NT0RFX0FMTCA9IGZsYWdzLlBSRVNFTkNFIHwgZmxhZ3MuUFVCTElTSCB8IGZsYWdzLlNVQlNDUklCRSB8IGZsYWdzLlBSRVNFTkNFX1NVQlNDUklCRTtcblxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmhhc0ZsYWcgPSBmdW5jdGlvbihmbGFnKSB7XG5cdFx0cmV0dXJuICgodGhpcy5mbGFncyAmIGZsYWdzW2ZsYWddKSA+IDApO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuc2V0RmxhZyA9IGZ1bmN0aW9uKGZsYWcpIHtcblx0XHRyZXR1cm4gdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBmbGFnc1tmbGFnXTtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5mbGFncyAmJiAodGhpcy5mbGFncyAmIGZsYWdzLk1PREVfQUxMKTtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZU1vZGVzVG9GbGFncyA9IGZ1bmN0aW9uKG1vZGVzKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChtb2RlcywgZnVuY3Rpb24obW9kZSkge1xuXHRcdFx0c2VsZi5zZXRGbGFnKG1vZGUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZGVjb2RlTW9kZXNGcm9tRmxhZ3MgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbW9kZXMgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChQcm90b2NvbE1lc3NhZ2UuY2hhbm5lbE1vZGVzLCBmdW5jdGlvbihtb2RlKSB7XG5cdFx0XHRpZihzZWxmLmhhc0ZsYWcobW9kZSkpIHtcblx0XHRcdFx0bW9kZXMucHVzaChtb2RlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gbW9kZXMubGVuZ3RoID4gMCA/IG1vZGVzIDogdW5kZWZpbmVkO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5zZXJpYWxpemUgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmVuY29kZUJvZHk7XG5cblx0UHJvdG9jb2xNZXNzYWdlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24oc2VyaWFsaXplZCwgZm9ybWF0KSB7XG5cdFx0dmFyIGRlc2VyaWFsaXplZCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVjb2RlQm9keShzZXJpYWxpemVkLCBmb3JtYXQpO1xuXHRcdHJldHVybiBQcm90b2NvbE1lc3NhZ2UuZnJvbURlc2VyaWFsaXplZChkZXNlcmlhbGl6ZWQpO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5mcm9tRGVzZXJpYWxpemVkID0gZnVuY3Rpb24oZGVzZXJpYWxpemVkKSB7XG5cdFx0dmFyIGVycm9yID0gZGVzZXJpYWxpemVkLmVycm9yO1xuXHRcdGlmKGVycm9yKSBkZXNlcmlhbGl6ZWQuZXJyb3IgPSBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyhlcnJvcik7XG5cdFx0dmFyIG1lc3NhZ2VzID0gZGVzZXJpYWxpemVkLm1lc3NhZ2VzO1xuXHRcdGlmKG1lc3NhZ2VzKSBmb3IodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIG1lc3NhZ2VzW2ldID0gX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKG1lc3NhZ2VzW2ldKTtcblx0XHR2YXIgcHJlc2VuY2UgPSBkZXNlcmlhbGl6ZWQucHJlc2VuY2U7XG5cdFx0aWYocHJlc2VuY2UpIGZvcih2YXIgaSA9IDA7IGkgPCBwcmVzZW5jZS5sZW5ndGg7IGkrKykgcHJlc2VuY2VbaV0gPSBfcHJlc2VuY2VtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyhwcmVzZW5jZVtpXSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4obmV3IFByb3RvY29sTWVzc2FnZSgpLCBkZXNlcmlhbGl6ZWQpO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4obmV3IFByb3RvY29sTWVzc2FnZSgpLCB2YWx1ZXMpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHRvU3RyaW5nQXJyYXkoYXJyYXkpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0aWYgKGFycmF5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGFycmF5W2ldLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gJ1sgJyArIHJlc3VsdC5qb2luKCcsICcpICsgJyBdJztcblx0fVxuXG5cdHZhciBzaW1wbGVBdHRyaWJ1dGVzID0gJ2lkIGNoYW5uZWwgY2hhbm5lbFNlcmlhbCBjb25uZWN0aW9uSWQgY29ubmVjdGlvbktleSBjb25uZWN0aW9uU2VyaWFsIGNvdW50IG1zZ1NlcmlhbCB0aW1lc3RhbXAnLnNwbGl0KCcgJyk7XG5cblx0UHJvdG9jb2xNZXNzYWdlLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG1zZykge1xuXHRcdHZhciByZXN1bHQgPSAnW1Byb3RvY29sTWVzc2FnZSc7XG5cdFx0aWYobXNnLmFjdGlvbiAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGFjdGlvbj0nICsgUHJvdG9jb2xNZXNzYWdlLkFjdGlvbk5hbWVbbXNnLmFjdGlvbl0gfHwgZmFsc2U7XG5cblx0XHR2YXIgYXR0cmlidXRlO1xuXHRcdGZvciAodmFyIGF0dHJpYkluZGV4ID0gMDsgYXR0cmliSW5kZXggPCBzaW1wbGVBdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cmliSW5kZXgrKykge1xuXHRcdFx0YXR0cmlidXRlID0gc2ltcGxlQXR0cmlidXRlc1thdHRyaWJJbmRleF07XG5cdFx0XHRpZihtc2dbYXR0cmlidXRlXSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgJyArIGF0dHJpYnV0ZSArICc9JyArIG1zZ1thdHRyaWJ1dGVdO1xuXHRcdH1cblxuXHRcdGlmKG1zZy5tZXNzYWdlcylcblx0XHRcdHJlc3VsdCArPSAnOyBtZXNzYWdlcz0nICsgdG9TdHJpbmdBcnJheShfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXNBcnJheShtc2cubWVzc2FnZXMpKTtcblx0XHRpZihtc2cucHJlc2VuY2UpXG5cdFx0XHRyZXN1bHQgKz0gJzsgcHJlc2VuY2U9JyArIHRvU3RyaW5nQXJyYXkoX3ByZXNlbmNlbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXNBcnJheShtc2cucHJlc2VuY2UpKTtcblx0XHRpZihtc2cuZXJyb3IpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZXJyb3I9JyArIF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKG1zZy5lcnJvcikudG9TdHJpbmcoKTtcblx0XHRpZihtc2cuYXV0aCAmJiBtc2cuYXV0aC5hY2Nlc3NUb2tlbilcblx0XHRcdHJlc3VsdCArPSAnOyB0b2tlbj0nICsgbXNnLmF1dGguYWNjZXNzVG9rZW47XG5cdFx0aWYobXNnLmZsYWdzKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGZsYWdzPScgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZpbHRlcihmbGFnTmFtZXMsIGZ1bmN0aW9uKGZsYWcpIHtcblx0XHRcdFx0cmV0dXJuIG1zZy5oYXNGbGFnKGZsYWcpO1xuXHRcdFx0fSkuam9pbignLCcpO1xuXHRcdGlmKG1zZy5wYXJhbXMpIHtcblx0XHRcdHZhciBzdHJpbmdpZmllZFBhcmFtcyA9ICcnO1xuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mb3JJbk93bk5vbk51bGxQcm9wcyhtc2cucGFyYW1zLCBmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHRcdGlmIChzdHJpbmdpZmllZFBhcmFtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0c3RyaW5naWZpZWRQYXJhbXMgKz0gJzsgJztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHJpbmdpZmllZFBhcmFtcyArPSBwcm9wICsgJz0nICsgbXNnLnBhcmFtc1twcm9wXTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0cmVzdWx0ICs9ICc7IHBhcmFtcz1bJyArIHN0cmluZ2lmaWVkUGFyYW1zICsgJ10nO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXN1bHQgKz0gJ10nO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyogT25seSB2YWxpZCBmb3IgY2hhbm5lbCBtZXNzYWdlcyAqL1xuXHRQcm90b2NvbE1lc3NhZ2UuaXNEdXBsaWNhdGUgPSBmdW5jdGlvbihhLCBiKSB7XG5cdFx0aWYgKGEgJiYgYikge1xuXHRcdFx0aWYgKChhLmFjdGlvbiA9PT0gYWN0aW9ucy5NRVNTQUdFIHx8IGEuYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFKSAmJlxuXHRcdFx0XHQoYS5hY3Rpb24gPT09IGIuYWN0aW9uKSAmJlxuXHRcdFx0XHQoYS5jaGFubmVsID09PSBiLmNoYW5uZWwpICYmXG5cdFx0XHRcdChhLmlkID09PSBiLmlkKSkge1xuXHRcdFx0XHRpZiAoYS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChhLm1lc3NhZ2VzLmxlbmd0aCA9PT0gYi5tZXNzYWdlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGEubWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBhTWVzc2FnZSA9IGEubWVzc2FnZXNbaV07XG5cdFx0XHRcdFx0XHR2YXIgYk1lc3NhZ2UgPSBiLm1lc3NhZ2VzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKChhTWVzc2FnZS5leHRyYXMgJiYgYU1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGFNZXNzYWdlLmV4dHJhcy5kZWx0YS5mb3JtYXQpICE9PVxuXHRcdFx0XHRcdFx0XHQoYk1lc3NhZ2UuZXh0cmFzICYmIGJNZXNzYWdlLmV4dHJhcy5kZWx0YSAmJiBiTWVzc2FnZS5leHRyYXMuZGVsdGEuZm9ybWF0KSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0cmV0dXJuIFByb3RvY29sTWVzc2FnZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUHJvdG9jb2xNZXNzYWdlKTtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2NyeXB0b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG5cblxuXG5cbnZhciBNZXNzYWdlID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIE1lc3NhZ2UoKSB7XG5cdFx0dGhpcy5uYW1lID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25LZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5kYXRhID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5leHRyYXMgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5zaXplID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRNZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0ge1xuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0aWQ6IHRoaXMuaWQsXG5cdFx0XHRjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcblx0XHRcdGNvbm5lY3Rpb25JZDogdGhpcy5jb25uZWN0aW9uSWQsXG5cdFx0XHRjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG5cdFx0XHRlbmNvZGluZzogdGhpcy5lbmNvZGluZyxcblx0XHRcdGV4dHJhczogdGhpcy5leHRyYXNcblx0XHR9O1xuXG5cdFx0LyogZW5jb2RlIGRhdGEgdG8gYmFzZTY0IGlmIHByZXNlbnQgYW5kIHdlJ3JlIHJldHVybmluZyByZWFsIEpTT047XG5cdFx0ICogYWx0aG91Z2ggbXNncGFjayBjYWxscyB0b0pTT04oKSwgd2Uga25vdyBpdCBpcyBhIHN0cmluZ2lmeSgpXG5cdFx0ICogY2FsbCBpZiBpdCBoYXMgYSBub24tZW1wdHkgYXJndW1lbnRzIGxpc3QgKi9cblx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblx0XHRpZihkYXRhICYmIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkpIHtcblx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8qIHN0cmluZ2lmeSBjYWxsICovXG5cdFx0XHRcdHZhciBlbmNvZGluZyA9IHRoaXMuZW5jb2Rpbmc7XG5cdFx0XHRcdHJlc3VsdC5lbmNvZGluZyA9IGVuY29kaW5nID8gKGVuY29kaW5nICsgJy9iYXNlNjQnKSA6ICdiYXNlNjQnO1xuXHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRFbmNvZGUoZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBDYWxsZWQgYnkgbXNncGFjay4gdG9CdWZmZXIgcmV0dXJucyBhIGRhdGF0eXBlIHVuZGVyc3RhbmRhYmxlIGJ5XG5cdFx0XHRcdCAqIHRoYXQgcGxhdGZvcm0ncyBtc2dwYWNrIGltcGxlbWVudGF0aW9uIChCdWZmZXIgaW4gbm9kZSwgVWludDhBcnJheVxuXHRcdFx0XHQgKiBpbiBicm93c2VycykgKi9cblx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9CdWZmZXIoZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc3VsdC5kYXRhID0gZGF0YTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdE1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbTWVzc2FnZSc7XG5cdFx0aWYodGhpcy5uYW1lKVxuXHRcdFx0cmVzdWx0ICs9ICc7IG5hbWU9JyArIHRoaXMubmFtZTtcblx0XHRpZih0aGlzLmlkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuXHRcdGlmKHRoaXMudGltZXN0YW1wKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHRpbWVzdGFtcD0nICsgdGhpcy50aW1lc3RhbXA7XG5cdFx0aWYodGhpcy5jbGllbnRJZClcblx0XHRcdHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcblx0XHRpZih0aGlzLmNvbm5lY3Rpb25JZClcblx0XHRcdHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xuXHRcdGlmKHRoaXMuZW5jb2RpbmcpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZW5jb2Rpbmc9JyArIHRoaXMuZW5jb2Rpbmc7XG5cdFx0aWYodGhpcy5leHRyYXMpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZXh0cmFzID0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xuXHRcdGlmKHRoaXMuZGF0YSkge1xuXHRcdFx0aWYgKHR5cGVvZih0aGlzLmRhdGEpID09ICdzdHJpbmcnKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YT0nICsgdGhpcy5kYXRhO1xuXHRcdFx0ZWxzZSBpZiAocGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcih0aGlzLmRhdGEpKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoYnVmZmVyKT0nICsgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRFbmNvZGUodGhpcy5kYXRhKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGEgKGpzb24pPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuXHRcdH1cblx0XHRpZih0aGlzLmV4dHJhcylcblx0XHRcdHJlc3VsdCArPSAnOyBleHRyYXM9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcblx0XHRyZXN1bHQgKz0gJ10nO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0TWVzc2FnZS5lbmNyeXB0ID0gZnVuY3Rpb24obXNnLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHZhciBkYXRhID0gbXNnLmRhdGEsXG5cdFx0XHRlbmNvZGluZyA9IG1zZy5lbmNvZGluZyxcblx0XHRcdGNpcGhlciA9IG9wdGlvbnMuY2hhbm5lbENpcGhlcjtcblxuXHRcdGVuY29kaW5nID0gZW5jb2RpbmcgPyAoZW5jb2RpbmcgKyAnLycpIDogJyc7XG5cdFx0aWYoIXBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkpIHtcblx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnV0ZjhFbmNvZGUoU3RyaW5nKGRhdGEpKTtcblx0XHRcdGVuY29kaW5nID0gZW5jb2RpbmcgKyAndXRmLTgvJztcblx0XHR9XG5cdFx0Y2lwaGVyLmVuY3J5cHQoZGF0YSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG1zZy5kYXRhID0gZGF0YTtcblx0XHRcdG1zZy5lbmNvZGluZyA9IGVuY29kaW5nICsgJ2NpcGhlcisnICsgY2lwaGVyLmFsZ29yaXRobTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIG1zZyk7XG5cdFx0fSk7XG5cdH07XG5cblx0TWVzc2FnZS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGRhdGEgPSBtc2cuZGF0YSwgZW5jb2RpbmcsXG5cdFx0XHRuYXRpdmVEYXRhVHlwZSA9IHR5cGVvZihkYXRhKSA9PSAnc3RyaW5nJyB8fCBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGRhdGEpIHx8IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCFuYXRpdmVEYXRhVHlwZSkge1xuXHRcdFx0aWYgKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNPYmplY3QoZGF0YSkgfHwgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdG1zZy5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG5cdFx0XHRcdG1zZy5lbmNvZGluZyA9IChlbmNvZGluZyA9IG1zZy5lbmNvZGluZykgPyAoZW5jb2RpbmcgKyAnL2pzb24nKSA6ICdqc29uJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0RhdGEgdHlwZSBpcyB1bnN1cHBvcnRlZCcsIDQwMDEzLCA0MDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmNpcGhlcikge1xuXHRcdFx0TWVzc2FnZS5lbmNyeXB0KG1zZywgb3B0aW9ucywgY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBtc2cpO1xuXHRcdH1cblx0fTtcblxuXHRNZXNzYWdlLmVuY29kZUFycmF5ID0gZnVuY3Rpb24obWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHByb2Nlc3NlZCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0TWVzc2FnZS5lbmNvZGUobWVzc2FnZXNbaV0sIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgbXNnKSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9jZXNzZWQrKztcblx0XHRcdFx0aWYgKHByb2Nlc3NlZCA9PSBtZXNzYWdlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCBtZXNzYWdlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRNZXNzYWdlLnNlcmlhbGl6ZSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZW5jb2RlQm9keTtcblxuXHRNZXNzYWdlLmRlY29kZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvbnRleHQpIHtcblx0XHQvKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGNvdWxkIGJlIGVpdGhlciBFbmNvZGluZ0RlY29kaW5nQ29udGV4dCB0aGF0IGNvbnRhaW5zIENoYW5uZWxPcHRpb25zIG9yIENoYW5uZWxPcHRpb25zICovXG5cdFx0aWYoIWNvbnRleHQgfHwgIWNvbnRleHQuY2hhbm5lbE9wdGlvbnMpIHtcblx0XHRcdHZhciBjaGFubmVsT3B0aW9ucyA9IGNvbnRleHQ7XG5cdFx0XHRjb250ZXh0ID0ge1xuXHRcdFx0XHRjaGFubmVsT3B0aW9uczogY2hhbm5lbE9wdGlvbnMsXG5cdFx0XHRcdHBsdWdpbnM6IHsgfSxcblx0XHRcdFx0YmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHVuZGVmaW5lZFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR2YXIgbGFzdFBheWxvYWQgPSBtZXNzYWdlLmRhdGE7XG5cdFx0dmFyIGVuY29kaW5nID0gbWVzc2FnZS5lbmNvZGluZztcblx0XHRpZihlbmNvZGluZykge1xuXHRcdFx0dmFyIHhmb3JtcyA9IGVuY29kaW5nLnNwbGl0KCcvJyksXG5cdFx0XHRcdGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4LCBlbmNvZGluZ3NUb1Byb2Nlc3MgPSB4Zm9ybXMubGVuZ3RoLFxuXHRcdFx0XHRkYXRhID0gbWVzc2FnZS5kYXRhO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3aGlsZSgobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPSBlbmNvZGluZ3NUb1Byb2Nlc3MpID4gMCkge1xuXHRcdFx0XHRcdHZhciBtYXRjaCA9IHhmb3Jtc1stLWVuY29kaW5nc1RvUHJvY2Vzc10ubWF0Y2goLyhbXFwtXFx3XSspKFxcKyhbXFx3XFwtXSspKT8vKTtcblx0XHRcdFx0XHRpZighbWF0Y2gpIGJyZWFrO1xuXHRcdFx0XHRcdHZhciB4Zm9ybSA9IG1hdGNoWzFdO1xuXHRcdFx0XHRcdHN3aXRjaCh4Zm9ybSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnYmFzZTY0Jzpcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RGVjb2RlKFN0cmluZyhkYXRhKSk7XG5cdFx0XHRcdFx0XHRcdGlmKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID09IHhmb3Jtcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRsYXN0UGF5bG9hZCA9IGRhdGE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRjYXNlICd1dGYtOCc6XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnV0ZjhEZWNvZGUoZGF0YSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0Y2FzZSAnanNvbic6XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdGNhc2UgJ2NpcGhlcic6XG5cdFx0XHRcdFx0XHRcdGlmKGNvbnRleHQuY2hhbm5lbE9wdGlvbnMgIT0gbnVsbCAmJiBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNpcGhlcikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB4Zm9ybUFsZ29yaXRobSA9IG1hdGNoWzNdLCBjaXBoZXIgPSBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXI7XG5cdFx0XHRcdFx0XHRcdFx0LyogZG9uJ3QgYXR0ZW1wdCB0byBkZWNyeXB0IHVubGVzcyB0aGUgY2lwaGVyIHBhcmFtcyBhcmUgY29tcGF0aWJsZSAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmKHhmb3JtQWxnb3JpdGhtICE9IGNpcGhlci5hbGdvcml0aG0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZSB3aXRoIGdpdmVuIGNpcGhlcjsgaW5jb21wYXRpYmxlIGNpcGhlciBwYXJhbXMnKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IGNpcGhlci5kZWNyeXB0KGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZTsgbm90IGFuIGVuY3J5cHRlZCBjaGFubmVsJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhc2UgJ3ZjZGlmZic6XG5cdFx0XHRcdFx0XHRcdGlmKCFjb250ZXh0LnBsdWdpbnMgfHwgIWNvbnRleHQucGx1Z2lucy52Y2RpZmYpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdNaXNzaW5nIFZjZGlmZiBkZWNvZGVyIChodHRwczovL2dpdGh1Yi5jb20vYWJseS1mb3Jrcy92Y2RpZmYtZGVjb2RlciknLCA0MDAxOSwgNDAwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdEZWx0YSBkZWNvZGluZyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlciAobmVlZCBBcnJheUJ1ZmZlciAmIFVpbnQ4QXJyYXkpJywgNDAwMjAsIDQwMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZGVsdGFCYXNlID0gY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDtcblx0XHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgZGVsdGFCYXNlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVsdGFCYXNlID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51dGY4RW5jb2RlKGRlbHRhQmFzZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogdmNkaWZmIGV4cGVjdHMgVWludDhBcnJheXMsIGNhbid0IGNvcHkgd2l0aCBBcnJheUJ1ZmZlcnMuIChhbHNvLCBpZiB3ZVxuXHRcdFx0XHRcdFx0XHRcdCAqIGRvbid0IGhhdmUgYSBUZXh0RGVjb2RlciwgZGVsdGFCYXNlIG1pZ2h0IGJlIGEgV29yZEFycmF5IGhlcmUsIHNvIG5lZWRcblx0XHRcdFx0XHRcdFx0XHQgKiB0byBwcm9jZXNzIGl0IGludG8gYSBidWZmZXIgYW55d2F5KSAqL1xuXHRcdFx0XHRcdFx0XHRcdGRlbHRhQmFzZSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9CdWZmZXIoZGVsdGFCYXNlKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b0J1ZmZlcihkYXRhKTtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnR5cGVkQXJyYXlUb0J1ZmZlcihjb250ZXh0LnBsdWdpbnMudmNkaWZmLmRlY29kZShkYXRhLCBkZWx0YUJhc2UpKTtcblx0XHRcdFx0XHRcdFx0XHRsYXN0UGF5bG9hZCA9IGRhdGE7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1ZjZGlmZiBkZWx0YSBkZWNvZGUgZmFpbGVkIHdpdGggJyArIGUsIDQwMDE4LCA0MDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZ1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdFcnJvciBwcm9jZXNzaW5nIHRoZSAnICsgeGZvcm0gKyAnIGVuY29kaW5nLCBkZWNvZGVyIHJldHVybmVkIOKAmCcgKyBlLm1lc3NhZ2UgKyAn4oCZJywgZS5jb2RlIHx8IDQwMDEzLCA0MDApO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0bWVzc2FnZS5lbmNvZGluZyA9IChsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA8PSAwKSA/IG51bGwgOiB4Zm9ybXMuc2xpY2UoMCwgbGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXgpLmpvaW4oJy8nKTtcblx0XHRcdFx0bWVzc2FnZS5kYXRhID0gZGF0YTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZCA9IGxhc3RQYXlsb2FkO1xuXHR9O1xuXG5cdE1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKGJvZHksIG9wdGlvbnMsIGZvcm1hdCkge1xuXHRcdGlmKGZvcm1hdCkge1xuXHRcdFx0Ym9keSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuXHRcdH1cblxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbXNnID0gYm9keVtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyhib2R5W2ldKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdE1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBib2R5O1xuXHR9O1xuXG5cdE1lc3NhZ2UuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKG5ldyBNZXNzYWdlKCksIHZhbHVlcyk7XG5cdH07XG5cblx0TWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHR2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSByZXN1bHRbaV0gPSBNZXNzYWdlLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMob3B0aW9ucykge1xuXHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5jaXBoZXIgJiYgIW9wdGlvbnMuY2lwaGVyLmNoYW5uZWxDaXBoZXIpIHtcblx0XHRcdGlmKCFwbGF0Zm9ybV9jcnlwdG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWQnKTtcblx0XHRcdHZhciBjaXBoZXIgPSBwbGF0Zm9ybV9jcnlwdG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRDaXBoZXIob3B0aW9ucy5jaXBoZXIpO1xuXHRcdFx0b3B0aW9ucy5jaXBoZXIgPSBjaXBoZXIuY2lwaGVyUGFyYW1zO1xuXHRcdFx0b3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gY2lwaGVyLmNpcGhlcjtcblx0XHR9XG5cdH1cblxuXHRNZXNzYWdlLmZyb21FbmNvZGVkID0gZnVuY3Rpb24oZW5jb2RlZCwgb3B0aW9ucykge1xuXHRcdHZhciBtc2cgPSBNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XG5cdFx0bm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhvcHRpb25zKTtcblx0XHQvKiBpZiBkZWNvZGluZyBmYWlscyBhdCBhbnkgcG9pbnQsIGNhdGNoIGFuZCByZXR1cm4gdGhlIG1lc3NhZ2UgZGVjb2RlZCB0b1xuXHRcdCAqIHRoZSBmdWxsZXN0IGV4dGVudCBwb3NzaWJsZSAqL1xuXHRcdHRyeSB7XG5cdFx0XHRNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ01lc3NhZ2UuZnJvbUVuY29kZWQoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0fVxuXHRcdHJldHVybiBtc2c7XG5cdH07XG5cblx0TWVzc2FnZS5mcm9tRW5jb2RlZEFycmF5ID0gZnVuY3Rpb24oZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG5cdFx0bm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhvcHRpb25zKTtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJNYXAoZW5jb2RlZEFycmF5LCBmdW5jdGlvbihlbmNvZGVkKSB7XG5cdFx0XHRyZXR1cm4gTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBnZXRNZXNzYWdlU2l6ZShtc2cpIHtcblx0XHR2YXIgc2l6ZSA9IDA7XG5cdFx0aWYobXNnLm5hbWUpIHtcblx0XHRcdHNpemUgKz0gbXNnLm5hbWUubGVuZ3RoO1xuXHRcdH1cblx0XHRpZihtc2cuY2xpZW50SWQpIHtcblx0XHRcdHNpemUgKz0gbXNnLmNsaWVudElkLmxlbmd0aDtcblx0XHR9XG5cdFx0aWYobXNnLmV4dHJhcykge1xuXHRcdFx0c2l6ZSArPSBKU09OLnN0cmluZ2lmeShtc2cuZXh0cmFzKS5sZW5ndGg7XG5cdFx0fVxuXHRcdGlmKG1zZy5kYXRhKSB7XG5cdFx0XHRzaXplICs9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGF0YVNpemVCeXRlcyhtc2cuZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBzaXplO1xuXHR9O1xuXG5cdC8qIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBvbiBlbmNvZGUoKWQgKGFuZCBlbmNyeXB0KClkKSBNZXNzYWdlcyAoYXMgaXRcblx0ICogYXNzdW1lcyB0aGUgZGF0YSBpcyBhIHN0cmluZyBvciBidWZmZXIpICovXG5cdE1lc3NhZ2UuZ2V0TWVzc2FnZXNTaXplID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcblx0XHR2YXIgbXNnLCB0b3RhbCA9IDA7XG5cdFx0Zm9yKHZhciBpPTA7IGk8bWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1zZyA9IG1lc3NhZ2VzW2ldO1xuXHRcdFx0dG90YWwgKz0gKG1zZy5zaXplIHx8IChtc2cuc2l6ZSA9IGdldE1lc3NhZ2VTaXplKG1zZykpKVxuXHRcdH1cblx0XHRyZXR1cm4gdG90YWw7XG5cdH07XG5cblx0cmV0dXJuIE1lc3NhZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKE1lc3NhZ2UpO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gQ2hlY2sgaWYgdHlwZWQgYXJyYXlzIGFyZSBzdXBwb3J0ZWRcblx0ICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXG5cdCAgICAvLyBSZWZlcmVuY2Ugb3JpZ2luYWwgaW5pdFxuXHQgICAgdmFyIHN1cGVySW5pdCA9IFdvcmRBcnJheS5pbml0O1xuXG5cdCAgICAvLyBBdWdtZW50IFdvcmRBcnJheS5pbml0IHRvIGhhbmRsZSB0eXBlZCBhcnJheXNcblx0ICAgIHZhciBzdWJJbml0ID0gV29yZEFycmF5LmluaXQgPSBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHQgICAgICAgIC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbnZlcnQgb3RoZXIgYXJyYXkgdmlld3MgdG8gdWludDhcblx0ICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcblx0ICAgICAgICAgICAgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG5cdCAgICAgICAgKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEhhbmRsZSBVaW50OEFycmF5XG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB0eXBlZEFycmF5Qnl0ZUxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBFeHRyYWN0IGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkQXJyYXlCeXRlTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IHR5cGVkQXJyYXlbaV0gPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGlzIHdvcmQgYXJyYXlcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmNhbGwodGhpcywgd29yZHMsIHR5cGVkQXJyYXlCeXRlTGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgc3ViSW5pdC5wcm90b3R5cGUgPSBXb3JkQXJyYXk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheTtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG5cblxuXG5cbnZhciBQcmVzZW5jZU1lc3NhZ2UgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBtc2dwYWNrID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5tc2dwYWNrO1xuXG5cdGZ1bmN0aW9uIHRvQWN0aW9uVmFsdWUoYWN0aW9uU3RyaW5nKSB7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZihQcmVzZW5jZU1lc3NhZ2UuQWN0aW9ucywgYWN0aW9uU3RyaW5nKVxuXHR9XG5cblx0ZnVuY3Rpb24gUHJlc2VuY2VNZXNzYWdlKCkge1xuXHRcdHRoaXMuYWN0aW9uID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5lbmNvZGluZyA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnNpemUgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRQcmVzZW5jZU1lc3NhZ2UuQWN0aW9ucyA9IFtcblx0XHQnYWJzZW50Jyxcblx0XHQncHJlc2VudCcsXG5cdFx0J2VudGVyJyxcblx0XHQnbGVhdmUnLFxuXHRcdCd1cGRhdGUnXG5cdF07XG5cblx0LyogUmV0dXJucyB3aGV0aGVyIHRoaXMgcHJlc2VuY2VNZXNzYWdlIGlzIHN5bnRoZXNpemVkLCBpLmUuIHdhcyBub3QgYWN0dWFsbHlcblx0ICogc2VudCBieSB0aGUgY29ubmVjdGlvbiAodXN1YWxseSBtZWFucyBhIGxlYXZlIGV2ZW50IHNlbnQgMTVzIGFmdGVyIGFcblx0ICogZGlzY29ubmVjdGlvbikuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2Ugc3ludGhlc2l6ZWQgbWVzc2FnZXMgY2Fubm90IGJlXG5cdCAqIGNvbXBhcmVkIGZvciBuZXduZXNzIGJ5IGlkIGxleGljb2dyYXBoaWNhbGx5IC0gUlRQMmIxXG5cdCAqL1xuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLmlzU3ludGhlc2l6ZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcodGhpcy5jb25uZWN0aW9uSWQubGVuZ3RoLCAwKSAhPT0gdGhpcy5jb25uZWN0aW9uSWQ7XG5cdH07XG5cblx0LyogUlRQMmIyICovXG5cdFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUucGFyc2VJZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuaWQuc3BsaXQoJzonKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y29ubmVjdGlvbklkOiBwYXJ0c1swXSxcblx0XHRcdG1zZ1NlcmlhbDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcblx0XHRcdGluZGV4OiBwYXJzZUludChwYXJ0c1syXSwgMTApXG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuXHRcdFx0LyogQ29udmVydCBwcmVzZW5jZSBhY3Rpb24gYmFjayB0byBhbiBpbnQgZm9yIHNlbmRpbmcgdG8gQWJseSAqL1xuXHRcdFx0YWN0aW9uOiB0b0FjdGlvblZhbHVlKHRoaXMuYWN0aW9uKSxcblx0XHRcdGVuY29kaW5nOiB0aGlzLmVuY29kaW5nXG5cdFx0fTtcblxuXHRcdC8qIGVuY29kZSBkYXRhIHRvIGJhc2U2NCBpZiBwcmVzZW50IGFuZCB3ZSdyZSByZXR1cm5pbmcgcmVhbCBKU09OO1xuXHRcdCAqIGFsdGhvdWdoIG1zZ3BhY2sgY2FsbHMgdG9KU09OKCksIHdlIGtub3cgaXQgaXMgYSBzdHJpbmdpZnkoKVxuXHRcdCAqIGNhbGwgaWYgaXQgaGFzIGEgbm9uLWVtcHR5IGFyZ3VtZW50cyBsaXN0ICovXG5cdFx0dmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cdFx0aWYoZGF0YSAmJiBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGRhdGEpKSB7XG5cdFx0XHRpZihhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvKiBzdHJpbmdpZnkgY2FsbCAqL1xuXHRcdFx0XHR2YXIgZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xuXHRcdFx0XHRyZXN1bHQuZW5jb2RpbmcgPSBlbmNvZGluZyA/IChlbmNvZGluZyArICcvYmFzZTY0JykgOiAnYmFzZTY0Jztcblx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RW5jb2RlKGRhdGEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogQ2FsbGVkIGJ5IG1zZ3BhY2suIHRvQnVmZmVyIHJldHVybnMgYSBkYXRhdHlwZSB1bmRlcnN0YW5kYWJsZSBieVxuXHRcdFx0XHQgKiB0aGF0IHBsYXRmb3JtJ3MgbXNncGFjayBpbXBsZW1lbnRhdGlvbiAoQnVmZmVyIGluIG5vZGUsIFVpbnQ4QXJyYXlcblx0XHRcdFx0ICogaW4gYnJvd3NlcnMpICovXG5cdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvQnVmZmVyKGRhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXN1bHQuZGF0YSA9IGRhdGE7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbUHJlc2VuY2VNZXNzYWdlJztcblx0XHRyZXN1bHQgKz0gJzsgYWN0aW9uPScgKyB0aGlzLmFjdGlvbjtcblx0XHRpZih0aGlzLmlkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuXHRcdGlmKHRoaXMudGltZXN0YW1wKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHRpbWVzdGFtcD0nICsgdGhpcy50aW1lc3RhbXA7XG5cdFx0aWYodGhpcy5jbGllbnRJZClcblx0XHRcdHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcblx0XHRpZih0aGlzLmNvbm5lY3Rpb25JZClcblx0XHRcdHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xuXHRcdGlmKHRoaXMuZW5jb2RpbmcpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZW5jb2Rpbmc9JyArIHRoaXMuZW5jb2Rpbmc7XG5cdFx0aWYodGhpcy5kYXRhKSB7XG5cdFx0XHRpZiAodHlwZW9mKHRoaXMuZGF0YSkgPT0gJ3N0cmluZycpXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhPScgKyB0aGlzLmRhdGE7XG5cdFx0XHRlbHNlIGlmIChwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKHRoaXMuZGF0YSkpXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhIChidWZmZXIpPScgKyBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NEVuY29kZSh0aGlzLmRhdGEpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoanNvbik9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSk7XG5cdFx0fVxuXHRcdHJlc3VsdCArPSAnXSc7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblx0UHJlc2VuY2VNZXNzYWdlLmVuY29kZSA9IF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZW5jb2RlO1xuXHRQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlID0gX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWNvZGU7XG5cblx0UHJlc2VuY2VNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbihib2R5LCBvcHRpb25zLCBmb3JtYXQpIHtcblx0XHRpZihmb3JtYXQpIHtcblx0XHRcdGJvZHkgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcblx0XHR9XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG1zZyA9IGJvZHlbaV0gPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhib2R5W2ldLCB0cnVlKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdFByZXNlbmNlTWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1ByZXNlbmNlTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYm9keTtcblx0fTtcblxuXHQvKiBDcmVhdGVzIGEgUHJlc2VuY2VNZXNzYWdlIGZyb20gc3BlY2lmaWVkIHZhbHVlcywgd2l0aCBhIHN0cmluZyBwcmVzZW5jZSBhY3Rpb24gKi9cblx0UHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMsIHN0cmluZ2lmeUFjdGlvbikge1xuXHRcdGlmKHN0cmluZ2lmeUFjdGlvbikge1xuXHRcdFx0dmFsdWVzLmFjdGlvbiA9IFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zW3ZhbHVlcy5hY3Rpb25dXG5cdFx0fVxuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKG5ldyBQcmVzZW5jZU1lc3NhZ2UoKSwgdmFsdWVzKTtcblx0fTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0dmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgcmVzdWx0W2ldID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZCA9IGZ1bmN0aW9uKGVuY29kZWQsIG9wdGlvbnMpIHtcblx0XHR2YXIgbXNnID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCwgdHJ1ZSk7XG5cdFx0LyogaWYgZGVjb2RpbmcgZmFpbHMgYXQgYW55IHBvaW50LCBjYXRjaCBhbmQgcmV0dXJuIHRoZSBtZXNzYWdlIGRlY29kZWQgdG9cblx0XHQgKiB0aGUgZnVsbGVzdCBleHRlbnQgcG9zc2libGUgKi9cblx0XHR0cnkge1xuXHRcdFx0UHJlc2VuY2VNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1ByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZCgpJywgZS50b1N0cmluZygpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1zZztcblx0fTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWRBcnJheSA9IGZ1bmN0aW9uKGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyck1hcChlbmNvZGVkQXJyYXksIGZ1bmN0aW9uKGVuY29kZWQpIHtcblx0XHRcdHJldHVybiBQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQoZW5jb2RlZCwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH07XG5cblx0UHJlc2VuY2VNZXNzYWdlLmdldE1lc3NhZ2VzU2l6ZSA9IF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0TWVzc2FnZXNTaXplO1xuXG5cdHJldHVybiBQcmVzZW5jZU1lc3NhZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFByZXNlbmNlTWVzc2FnZSk7XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7OyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8qZ2xvYmFscyB3aW5kb3csIGdsb2JhbCwgcmVxdWlyZSovXG5cblx0LyoqXG5cdCAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG5cblx0ICAgIHZhciBjcnlwdG87XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSB3aW5kb3cgKEJyb3dzZXIpXG5cdCAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSAoZXhwZXJpbWVudGFsIElFIDExKSBjcnlwdG8gZnJvbSB3aW5kb3cgKEJyb3dzZXIpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubXNDcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSB3aW5kb3cubXNDcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSBnbG9iYWwgKE5vZGVKUylcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGltcG9ydCB2aWEgcmVxdWlyZSAoTm9kZUpTKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgXCJmdW5jdGlvblwiID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cdCAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgfVxuXG5cdCAgICAvKlxuXHQgICAgICogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5cdCAgICAgKlxuXHQgICAgICogQXMgTWF0aC5yYW5kb20oKSBpcyBjcnlwdG9ncmFwaGljYWxseSBub3Qgc2FmZSB0byB1c2Vcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyeXB0b1NlY3VyZVJhbmRvbUludCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoY3J5cHRvKSB7XG5cdCAgICAgICAgICAgIC8vIFVzZSBnZXRSYW5kb21WYWx1ZXMgbWV0aG9kIChCcm93c2VyKVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFVzZSByYW5kb21CeXRlcyBtZXRob2QgKE5vZGVKUylcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyg0KS5yZWFkSW50MzJMRSgpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgY3J5cHRvIG1vZHVsZSBjb3VsZCBub3QgYmUgdXNlZCB0byBnZXQgc2VjdXJlIHJhbmRvbSBudW1iZXIuJyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKlxuXHQgICAgICogTG9jYWwgcG9seWZpbGwgb2YgT2JqZWN0LmNyZWF0ZVxuXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRigpIHt9XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSlcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGlicmFyeSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2xpYiA9IEMubGliID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XG5cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTcGF3blxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBjcmVhdGUodGhpcyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSB8fCB0aGlzLmluaXQgPT09IHN1YnR5cGUuaW5pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuXHQgICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29uY2F0XG5cdCAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcFxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5CeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKGNyeXB0b1NlY3VyZVJhbmRvbUludCgpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcblx0ICAgICAqL1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG5cdCAgICAgICAgICAgIGlmIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuXHQgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGJsb2Nrc1xuXHQgICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IG5Xb3Jkc1JlYWR5OyBvZmZzZXQgKz0gYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgICAgIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuXG5cdCAgICByZXR1cm4gQztcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSkpXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG52YXIgQ29ubmVjdGlvbkVycm9yID0ge1xuXHRkaXNjb25uZWN0ZWQ6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0Y29kZTogODAwMDMsXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gdG8gc2VydmVyIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlJ1xuXHR9KSxcblx0c3VzcGVuZGVkOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNDAwLFxuXHRcdGNvZGU6IDgwMDAyLFxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIHRvIHNlcnZlciB1bmF2YWlsYWJsZSdcblx0fSksXG5cdGZhaWxlZDogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRjb2RlOiA4MDAwMCxcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiBmYWlsZWQgb3IgZGlzY29ubmVjdGVkIGJ5IHNlcnZlcidcblx0fSksXG5cdGNsb3Npbmc6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0Y29kZTogODAwMTcsXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gY2xvc2luZydcblx0fSksXG5cdGNsb3NlZDogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRjb2RlOiA4MDAxNyxcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiBjbG9zZWQnXG5cdH0pLFxuXHR1bmtub3duQ29ubmVjdGlvbkVycjogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDUwMCxcblx0XHRjb2RlOiA1MDAwMixcblx0XHRtZXNzYWdlOiAnSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvcidcblx0fSksXG5cdHVua25vd25DaGFubmVsRXJyOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNTAwLFxuXHRcdGNvZGU6IDUwMDAxLFxuXHRcdG1lc3NhZ2U6ICdJbnRlcm5hbCBjaGFubmVsIGVycm9yJ1xuXHR9KVxufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb25uZWN0aW9uRXJyb3IpO1xuXG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbG9nZ2VyLmpzXG52YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvZnJhZ21lbnRzL3BsYXRmb3JtLWJyb3dzZXIuanNcbnZhciBwbGF0Zm9ybV9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC91dGlscy5qc1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvaHR0cC5qc1xudmFyIGh0dHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL211bHRpY2FzdGVyLmpzXG52YXIgbXVsdGljYXN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvYnVmZmVydXRpbHMuanNcbnZhciBidWZmZXJ1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL2Vycm9yaW5mby5qc1xudmFyIGVycm9yaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9iYXNlNjQuanNcbi8qXG4gQ29weXJpZ2h0IChjKSAyMDA4IEZyZWQgUGFsbWVyIGZyZWQucGFsbWVyX2F0X2dtYWlsLmNvbVxuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiBjb25kaXRpb25zOlxuXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbnZhciBCYXNlNjQgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIFN0cmluZ0J1ZmZlcigpXG5cdHtcblx0XHR0aGlzLmJ1ZmZlciA9IFtdO1xuXHR9XG5cblx0U3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoc3RyaW5nKVxuXHR7XG5cdFx0dGhpcy5idWZmZXIucHVzaChzdHJpbmcpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdFN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5idWZmZXIuam9pbihcIlwiKTtcblx0fTtcblxuXHR2YXIgQmFzZTY0ID1cblx0e1xuXHRcdGNvZGV4IDogXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLFxuXG5cdFx0ZW5jb2RlIDogZnVuY3Rpb24gKGlucHV0KVxuXHRcdHtcblx0XHRcdHZhciBvdXRwdXQgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG5cdFx0XHR2YXIgY29kZXggPSBCYXNlNjQuY29kZXg7XG5cblx0XHRcdHZhciBlbnVtZXJhdG9yID0gbmV3IFV0ZjhFbmNvZGVFbnVtZXJhdG9yKGlucHV0KTtcblx0XHRcdHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjaHIxID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdGVudW1lcmF0b3IubW92ZU5leHQoKTtcblx0XHRcdFx0dmFyIGNocjIgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xuXHRcdFx0XHR2YXIgY2hyMyA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHR2YXIgZW5jMSA9IGNocjEgPj4gMjtcblx0XHRcdFx0dmFyIGVuYzIgPSAoKGNocjEgJiAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xuXHRcdFx0XHR2YXIgZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpO1xuXHRcdFx0XHR2YXIgZW5jNCA9IGNocjMgJiA2MztcblxuXHRcdFx0XHRpZiAoaXNOYU4oY2hyMikpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbmMzID0gZW5jNCA9IDY0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGlzTmFOKGNocjMpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW5jNCA9IDY0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0b3V0cHV0LmFwcGVuZChjb2RleC5jaGFyQXQoZW5jMSkgKyBjb2RleC5jaGFyQXQoZW5jMikgKyBjb2RleC5jaGFyQXQoZW5jMykgKyBjb2RleC5jaGFyQXQoZW5jNCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0cHV0LnRvU3RyaW5nKCk7XG5cdFx0fSxcblxuXHRcdGRlY29kZSA6IGZ1bmN0aW9uIChpbnB1dClcblx0XHR7XG5cdFx0XHR2YXIgb3V0cHV0ID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuXG5cdFx0XHR2YXIgZW51bWVyYXRvciA9IG5ldyBCYXNlNjREZWNvZGVFbnVtZXJhdG9yKGlucHV0KTtcblx0XHRcdHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjaGFyQ29kZSA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRpZiAoY2hhckNvZGUgPCAxMjgpXG5cdFx0XHRcdFx0b3V0cHV0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSk7XG5cdFx0XHRcdGVsc2UgaWYgKChjaGFyQ29kZSA+IDE5MSkgJiYgKGNoYXJDb2RlIDwgMjI0KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVudW1lcmF0b3IubW92ZU5leHQoKTtcblx0XHRcdFx0XHR2YXIgY2hhckNvZGUyID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdFx0b3V0cHV0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY2hhckNvZGUgJiAzMSkgPDwgNikgfCAoY2hhckNvZGUyICYgNjMpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xuXHRcdFx0XHRcdHZhciBjaGFyQ29kZTIgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0XHRlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XG5cdFx0XHRcdFx0dmFyIGNoYXJDb2RlMyA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRcdG91dHB1dC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgoKGNoYXJDb2RlICYgMTUpIDw8IDEyKSB8ICgoY2hhckNvZGUyICYgNjMpIDw8IDYpIHwgKGNoYXJDb2RlMyAmIDYzKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRwdXQudG9TdHJpbmcoKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gVXRmOEVuY29kZUVudW1lcmF0b3IoaW5wdXQpXG5cdHtcblx0XHR0aGlzLl9pbnB1dCA9IGlucHV0O1xuXHRcdHRoaXMuX2luZGV4ID0gLTE7XG5cdFx0dGhpcy5fYnVmZmVyID0gW107XG5cdH1cblxuXHRVdGY4RW5jb2RlRW51bWVyYXRvci5wcm90b3R5cGUgPVxuXHR7XG5cdFx0Y3VycmVudDogTnVtYmVyLk5hTixcblxuXHRcdG1vdmVOZXh0OiBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2J1ZmZlci5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSB0aGlzLl9idWZmZXIuc2hpZnQoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLl9pbmRleCA+PSAodGhpcy5faW5wdXQubGVuZ3RoIC0gMSkpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IE51bWJlci5OYU47XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dmFyIGNoYXJDb2RlID0gdGhpcy5faW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuX2luZGV4KTtcblxuXHRcdFx0XHQvLyBcIlxcclxcblwiIC0+IFwiXFxuXCJcblx0XHRcdFx0Ly9cblx0XHRcdFx0aWYgKChjaGFyQ29kZSA9PSAxMykgJiYgKHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5faW5kZXggKyAxKSA9PSAxMCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjaGFyQ29kZSA9IDEwO1xuXHRcdFx0XHRcdHRoaXMuX2luZGV4ICs9IDI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY2hhckNvZGUgPCAxMjgpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnQgPSBjaGFyQ29kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICgoY2hhckNvZGUgPiAxMjcpICYmIChjaGFyQ29kZSA8IDIwNDgpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gKGNoYXJDb2RlID4+IDYpIHwgMTkyO1xuXHRcdFx0XHRcdHRoaXMuX2J1ZmZlci5wdXNoKChjaGFyQ29kZSAmIDYzKSB8IDEyOCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gKGNoYXJDb2RlID4+IDEyKSB8IDIyNDtcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaCgoKGNoYXJDb2RlID4+IDYpICYgNjMpIHwgMTI4KTtcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaCgoY2hhckNvZGUgJiA2MykgfCAxMjgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIEJhc2U2NERlY29kZUVudW1lcmF0b3IoaW5wdXQpXG5cdHtcblx0XHR0aGlzLl9pbnB1dCA9IGlucHV0O1xuXHRcdHRoaXMuX2luZGV4ID0gLTE7XG5cdFx0dGhpcy5fYnVmZmVyID0gW107XG5cdH1cblxuXHRCYXNlNjREZWNvZGVFbnVtZXJhdG9yLnByb3RvdHlwZSA9XG5cdHtcblx0XHRjdXJyZW50OiA2NCxcblxuXHRcdG1vdmVOZXh0OiBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2J1ZmZlci5sZW5ndGggPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSB0aGlzLl9idWZmZXIuc2hpZnQoKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLl9pbmRleCA+PSAodGhpcy5faW5wdXQubGVuZ3RoIC0gMSkpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IDY0O1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBlbmMxID0gQmFzZTY0LmNvZGV4LmluZGV4T2YodGhpcy5faW5wdXQuY2hhckF0KCsrdGhpcy5faW5kZXgpKTtcblx0XHRcdFx0dmFyIGVuYzIgPSBCYXNlNjQuY29kZXguaW5kZXhPZih0aGlzLl9pbnB1dC5jaGFyQXQoKyt0aGlzLl9pbmRleCkpO1xuXHRcdFx0XHR2YXIgZW5jMyA9IEJhc2U2NC5jb2RleC5pbmRleE9mKHRoaXMuX2lucHV0LmNoYXJBdCgrK3RoaXMuX2luZGV4KSk7XG5cdFx0XHRcdHZhciBlbmM0ID0gQmFzZTY0LmNvZGV4LmluZGV4T2YodGhpcy5faW5wdXQuY2hhckF0KCsrdGhpcy5faW5kZXgpKTtcblxuXHRcdFx0XHR2YXIgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG5cdFx0XHRcdHZhciBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG5cdFx0XHRcdHZhciBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0O1xuXG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IGNocjE7XG5cblx0XHRcdFx0aWYgKGVuYzMgIT0gNjQpXG5cdFx0XHRcdFx0dGhpcy5fYnVmZmVyLnB1c2goY2hyMik7XG5cblx0XHRcdFx0aWYgKGVuYzQgIT0gNjQpXG5cdFx0XHRcdFx0dGhpcy5fYnVmZmVyLnB1c2goY2hyMyk7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBCYXNlNjQ7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBiYXNlNjQgPSAoQmFzZTY0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvYnVpbGQvaG1hYy1zaGEyNTYuanNcbnZhciBobWFjX3NoYTI1NiA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIGhtYWNfc2hhMjU2X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGhtYWNfc2hhMjU2KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9jcnlwdG8tanMvYnVpbGQvZW5jLWJhc2U2NC5qc1xudmFyIGVuY19iYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9hdXRoLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGF1dGhfQXV0aCA9IChmdW5jdGlvbigpIHtcblx0dmFyIE1BWF9UT0tFTl9MRU5HVEggPSBNYXRoLnBvdygyLCAxNyk7XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXHRmdW5jdGlvbiByYW5kb20oKSB7IHJldHVybiAoJzAwMDAwMCcgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxRTE2KSkuc2xpY2UoLTE2KTsgfVxuXHRmdW5jdGlvbiBub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpIHtcblx0XHQvKiBBIGNsaWVudCBhdXRoIGNhbGxiYWNrIG1heSBnaXZlIGVycm9ycyBpbiBhbnkgbnVtYmVyIG9mIGZvcm1hdHM7IG5vcm1hbGlzZSB0byBhbiBlcnJvcmluZm8gKi9cblx0XHRpZighdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNFcnJvckluZm8oZXJyKSkge1xuXHRcdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10odXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVyciksIGVyci5jb2RlIHx8IDQwMTcwLCBlcnIuc3RhdHVzQ29kZSB8fCA0MDEpO1xuXHRcdH1cblx0XHQvKiBuZXR3b3JrIGVycm9ycyB3aWxsIG5vdCBoYXZlIGFuIGluaGVyZW50IGVycm9yIGNvZGUgKi9cblx0XHRpZighZXJyLmNvZGUpIHtcblx0XHRcdGlmKGVyci5zdGF0dXNDb2RlID09PSA0MDMpIHtcblx0XHRcdFx0ZXJyLmNvZGUgPSA0MDMwMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVyci5jb2RlID0gNDAxNzA7XG5cdFx0XHRcdC8qIG5vcm1hbGlzZSBzdGF0dXNDb2RlIHRvIDQwMSBwZXIgUlNBNGUgKi9cblx0XHRcdFx0ZXJyLnN0YXR1c0NvZGUgPSA0MDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBlcnI7XG5cdH1cblxuXHR2YXIgaG1hYywgdG9CYXNlNjQ7XG5cdGlmKHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY3JlYXRlSG1hYykge1xuXHRcdHRvQmFzZTY0ID0gZnVuY3Rpb24oc3RyKSB7IHJldHVybiAoQnVmZmVyLmZyb20oc3RyLCAnYXNjaWknKSkudG9TdHJpbmcoJ2Jhc2U2NCcpOyB9O1xuXHRcdGhtYWMgPSBmdW5jdGlvbih0ZXh0LCBrZXkpIHtcblx0XHRcdHZhciBpbnN0ID0gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5jcmVhdGVIbWFjKCdTSEEyNTYnLCBrZXkpO1xuXHRcdFx0aW5zdC51cGRhdGUodGV4dCk7XG5cdFx0XHRyZXR1cm4gaW5zdC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0dG9CYXNlNjQgPSBiYXNlNjQuZW5jb2RlO1xuXHRcdGhtYWMgPSBmdW5jdGlvbih0ZXh0LCBrZXkpIHtcblx0XHRcdHJldHVybiBPYmplY3QoZW5jX2Jhc2U2NFtcInN0cmluZ2lmeVwiXSkoaG1hY19zaGEyNTZfZGVmYXVsdCgpKHRleHQsIGtleSkpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBjMTRuKGNhcGFiaWxpdHkpIHtcblx0XHRpZighY2FwYWJpbGl0eSlcblx0XHRcdHJldHVybiAnJztcblxuXHRcdGlmKHR5cGVvZihjYXBhYmlsaXR5KSA9PSAnc3RyaW5nJylcblx0XHRcdGNhcGFiaWxpdHkgPSBKU09OLnBhcnNlKGNhcGFiaWxpdHkpO1xuXG5cdFx0dmFyIGMxNG5DYXBhYmlsaXR5ID0ge307XG5cdFx0dmFyIGtleXMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5rZXlzQXJyYXkoY2FwYWJpbGl0eSwgdHJ1ZSk7XG5cdFx0aWYoIWtleXMpXG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0a2V5cy5zb3J0KCk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGMxNG5DYXBhYmlsaXR5W2tleXNbaV1dID0gY2FwYWJpbGl0eVtrZXlzW2ldXS5zb3J0KCk7XG5cdFx0fVxuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShjMTRuQ2FwYWJpbGl0eSk7XG5cdH1cblxuXHRmdW5jdGlvbiBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZChhdXRoT3B0aW9ucykge1xuXHRcdGlmKGF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2snKTtcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsJyk7XG5cdFx0fSBlbHNlIGlmKGF1dGhPcHRpb25zLmtleSkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nJyk7XG5cdFx0fSBlbHNlIGlmKGF1dGhPcHRpb25zLnRva2VuRGV0YWlscykge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBzdXBwbGllZCB0b2tlbiBvbmx5Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBtc2cgPSAnYXV0aE9wdGlvbnMgbXVzdCBpbmNsdWRlIHZhbGlkIGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnMnO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSB7XG5cdFx0cmV0dXJuICd1c2VUb2tlbkF1dGgnIGluIG9wdGlvbnMgJiYgIW9wdGlvbnMudXNlVG9rZW5BdXRoO1xuXHR9XG5cblx0LyogUlNBNCAqL1xuXHRmdW5jdGlvbiB1c2VUb2tlbkF1dGgob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zLnVzZVRva2VuQXV0aCB8fFxuXHRcdFx0KCFiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykgJiZcblx0XHRcdCAob3B0aW9ucy5hdXRoQ2FsbGJhY2sgfHxcblx0XHRcdCAgb3B0aW9ucy5hdXRoVXJsICAgICAgfHxcblx0XHRcdCAgb3B0aW9ucy50b2tlbiAgICAgICAgfHxcblx0XHRcdCAgb3B0aW9ucy50b2tlbkRldGFpbHMpKVxuXHR9XG5cblx0LyogUlNBNGEgKi9cblx0ZnVuY3Rpb24gbm9XYXlUb1JlbmV3KG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gIW9wdGlvbnMua2V5ICYmXG5cdFx0XHQhb3B0aW9ucy5hdXRoQ2FsbGJhY2sgJiZcblx0XHRcdCFvcHRpb25zLmF1dGhVcmw7XG5cdH1cblxuXHR2YXIgdHJJZCA9IDA7XG5cdGZ1bmN0aW9uIGdldFRva2VuUmVxdWVzdElkKCkge1xuXHRcdHJldHVybiB0cklkKys7XG5cdH1cblxuXHRmdW5jdGlvbiBBdXRoKGNsaWVudCwgb3B0aW9ucykge1xuXHRcdHRoaXMuY2xpZW50ID0gY2xpZW50O1xuXHRcdHRoaXMudG9rZW5QYXJhbXMgPSBvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcyB8fCB7fTtcblx0XHQvKiBUaGUgaWQgb2YgdGhlIGN1cnJlbnQgdG9rZW4gcmVxdWVzdCBpZiBvbmUgaXMgaW4gcHJvZ3Jlc3MsIGVsc2UgbnVsbCAqL1xuXHRcdHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcblx0XHR0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuXG5cdFx0aWYodXNlVG9rZW5BdXRoKG9wdGlvbnMpKSB7XG5cdFx0XHQvKiBUb2tlbiBhdXRoICovXG5cdFx0XHRpZihvcHRpb25zLmtleSAmJiAhaG1hYykge1xuXHRcdFx0XHR2YXIgbXNnID0gJ2NsaWVudC1zaWRlIHRva2VuIHJlcXVlc3Qgc2lnbmluZyBub3Qgc3VwcG9ydGVkJztcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0XHR9XG5cdFx0XHRpZihub1dheVRvUmVuZXcob3B0aW9ucykpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgJ1dhcm5pbmc6IGxpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zYXZlVG9rZW5PcHRpb25zKG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zLCBvcHRpb25zKTtcblx0XHRcdGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBCYXNpYyBhdXRoICovXG5cdFx0XHRpZighb3B0aW9ucy5rZXkpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdObyBhdXRoZW50aWNhdGlvbiBvcHRpb25zIHByb3ZpZGVkOyBuZWVkIG9uZSBvZjoga2V5LCBhdXRoVXJsLCBvciBhdXRoQ2FsbGJhY2sgKG9yIGZvciB0ZXN0aW5nIG9ubHksIHRva2VuIG9yIHRva2VuRGV0YWlscyknO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuXHRcdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNjAsIDQwMSk7XG5cdFx0XHR9XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoKCknLCAnYW5vbnltb3VzLCB1c2luZyBiYXNpYyBhdXRoJyk7XG5cdFx0XHR0aGlzLl9zYXZlQmFzaWNPcHRpb25zKG9wdGlvbnMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnN0cnVjdHMgdGhlIGxpYnJhcnkgdG8gZ2V0IGEgdG9rZW4gaW1tZWRpYXRlbHkgYW5kIGVuc3VyZXMgVG9rZW4gQXV0aFxuXHQgKiBpcyB1c2VkIGZvciBhbGwgZnV0dXJlIHJlcXVlc3RzLCBzdG9yaW5nIHRoZSB0b2tlblBhcmFtcyBhbmQgYXV0aE9wdGlvbnNcblx0ICogZ2l2ZW4gYXMgdGhlIG5ldyBkZWZhdWx0cyBmb3Igc3Vic2VxdWVudCB1c2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB0b2tlblBhcmFtc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RlZCB0b2tlbjpcblx0ICpcblx0ICogLSB0dGw6ICAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiBhbnkgbmV3IHRva2VuIGluIG1zLiBJZiBub25lXG5cdCAqICAgICAgICAgICAgICAgaXMgc3BlY2lmaWVkIGEgZGVmYXVsdCBvZiAxIGhvdXIgaXMgcHJvdmlkZWQuIFRoZSBtYXhpbXVtIGxpZmV0aW1lXG5cdCAqICAgICAgICAgICAgICAgaXMgMjRob3VyczsgYW55IHJlcXVlc3QgZXhjZWVlZGluZyB0aGF0IGxpZmV0aW1lIHdpbGwgYmUgcmVqZWN0ZWRcblx0ICogICAgICAgICAgICAgICB3aXRoIGFuIGVycm9yLlxuXHQgKlxuXHQgKiAtIGNhcGFiaWxpdHk6IChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cblx0ICogICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcblx0ICogICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG5cdCAqXG5cdCAqIC0gY2xpZW50SWQ6ICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJZCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW5cblx0ICpcblx0ICogLSB0aW1lc3RhbXA6ICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG5cdCAqICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG5cdCAqXG5cdCAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyBhdXRoIG9wdGlvbnMgcmVsZXZhbnQgdG8gdG9rZW4gYXV0aDpcblx0ICpcblx0ICogLSBxdWVyeVRpbWUgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBBYmx5IHN5c3RlbSBzaG91bGQgYmVcblx0ICogICAgICAgICAgICAgICBxdWVyaWVkIGZvciB0aGUgY3VycmVudCB0aW1lIHdoZW4gbm9uZSBpcyBzcGVjaWZpZWQgZXhwbGljaXRseS5cblx0ICpcblx0ICogLSB0b2tlbkRldGFpbHM6IChvcHRpb25hbCkgb2JqZWN0OiBBbiBhdXRoZW50aWNhdGVkIFRva2VuRGV0YWlscyBvYmplY3QuXG5cdCAqXG5cdCAqIC0gdG9rZW46ICAgICAgICAob3B0aW9uYWwpIHN0cmluZzogdGhlIGB0b2tlbmAgcHJvcGVydHkgb2YgYSB0b2tlbkRldGFpbHMgb2JqZWN0XG5cdCAqXG5cdCAqIC0gYXV0aENhbGxiYWNrOiAgKG9wdGlvbmFsKSBhIEphdmFTY3JpcHQgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHRvIGdldCBhdXRoIGluZm9ybWF0aW9uLlxuXHQgKiAgICAgICAgICAgICAgICAgIGF1dGhDYWxsYmFjayBzaG91bGQgYmUgYSBmdW5jdGlvbiBvZiAodG9rZW5QYXJhbXMsIGNhbGxiYWNrKSB0aGF0IGNhbGxzXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIGNhbGxiYWNrIHdpdGggKGVyciwgcmVzdWx0KSwgd2hlcmUgcmVzdWx0IGlzIGFueSBvZjpcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW5SZXF1ZXN0IG9iamVjdCAoaWUgdGhlIHJlc3VsdCBvZiBhIHJlc3QuYXV0aC5jcmVhdGVUb2tlblJlcXVlc3QgY2FsbCksXG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuRGV0YWlscyBvYmplY3QgKGllIHRoZSByZXN1bHQgb2YgYSByZXN0LmF1dGgucmVxdWVzdFRva2VuIGNhbGwpLFxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlbiBzdHJpbmdcblx0ICpcblx0ICogLSBhdXRoVXJsOiAgICAgICAob3B0aW9uYWwpIGEgVVJMIHRvIGJlIHVzZWQgdG8gR0VUIG9yIFBPU1QgYSBzZXQgb2YgdG9rZW4gcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIHBhcmFtcywgdG8gb2J0YWluIGEgc2lnbmVkIHRva2VuIHJlcXVlc3QuXG5cdCAqXG5cdCAqIC0gYXV0aEhlYWRlcnM6ICAgKG9wdGlvbmFsKSBhIHNldCBvZiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBoZWFkZXJzIHRvIGJlIGFkZGVkIHRvIGFueSByZXF1ZXN0XG5cdCAqICAgICAgICAgICAgICAgICAgbWFkZSB0byB0aGUgYXV0aFVybC5cblx0ICpcblx0ICogLSBhdXRoUGFyYW1zOiAgICAob3B0aW9uYWwpIGEgc2V0IG9mIGFwcGxpY2F0aW9uLXNwZWNpZmljIHF1ZXJ5IHBhcmFtcyB0byBiZSBhZGRlZCB0byBhbnlcblx0ICogICAgICAgICAgICAgICAgICByZXF1ZXN0IG1hZGUgdG8gdGhlIGF1dGhVcmwuXG5cdCAqXG5cdCAqXG5cdCAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3Rcblx0ICpcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHRva2VuRGV0YWlscylcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmF1dGhvcml6ZSA9IGZ1bmN0aW9uKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHQvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xuXHRcdGlmKHR5cGVvZih0b2tlblBhcmFtcykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcblx0XHR9IGVsc2UgaWYodHlwZW9mKGF1dGhPcHRpb25zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcblx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZih0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2F1dGhvcml6ZScsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdC8qIFJTQTEwYTogYXV0aG9yaXplKCkgY2FsbCBpbXBsaWVzIHRva2VuIGF1dGguIElmIGEga2V5IGlzIHBhc3NlZCBpdCwgd2Vcblx0XHQgKiBqdXN0IGNoZWNrIGlmIGl0IGRvZXNuJ3QgY2xhc2ggYW5kIGFzc3VtZSB3ZSdyZSBnZW5lcmF0aW5nIGEgdG9rZW4gZnJvbSBpdCAqL1xuXHRcdGlmKGF1dGhPcHRpb25zICYmIGF1dGhPcHRpb25zLmtleSAmJiAodGhpcy5hdXRoT3B0aW9ucy5rZXkgIT09IGF1dGhPcHRpb25zLmtleSkpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byB1cGRhdGUgYXV0aCBvcHRpb25zIHdpdGggaW5jb21wYXRpYmxlIGtleScsIDQwMTAyLCA0MDEpO1xuXHRcdH1cblxuXHRcdGlmKGF1dGhPcHRpb25zICYmICgnZm9yY2UnIGluIGF1dGhPcHRpb25zKSkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5hdXRob3JpemUnLCAnRGVwcmVjYXRpb24gd2FybmluZzogc3BlY2lmeWluZyB7Zm9yY2U6IHRydWV9IGluIGF1dGhPcHRpb25zIGlzIG5vIGxvbmdlciBuZWNlc3NhcnksIGF1dGhvcml6ZSgpIG5vdyBhbHdheXMgZ2V0cyBhIG5ldyB0b2tlbi4gUGxlYXNlIHJlbW92ZSB0aGlzLCBhcyBpbiB2ZXJzaW9uIDEuMCBhbmQgbGF0ZXIsIGhhdmluZyBhIG5vbi1udWxsIGF1dGhPcHRpb25zIHdpbGwgb3ZlcndyaXRlIHN0b3JlZCBsaWJyYXJ5IGF1dGhPcHRpb25zLCB3aGljaCBtYXkgbm90IGJlIHdoYXQgeW91IHdhbnQnKTtcblx0XHRcdC8qIEVtdWxhdGUgdGhlIG9sZCBiZWhhdmlvdXI6IGlmICdmb3JjZScgd2FzIHRoZSBvbmx5IG1lbWJlciBvZiBhdXRoT3B0aW9ucyxcblx0XHRcdCAqIHNldCBpdCB0byBudWxsIHNvIGl0IGRvZXNuJ3Qgb3ZlcndyaXRlIHN0b3JlZC4gVE9ETzogcmVtb3ZlIGluIHZlcnNpb24gMS4wICovXG5cdFx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc09ubHlQcm9wSW4oYXV0aE9wdGlvbnMsICdmb3JjZScpKSB7XG5cdFx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9mb3JjZU5ld1Rva2VuKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgZnVuY3Rpb24oZXJyLCB0b2tlbkRldGFpbHMpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRpZihzZWxmLmNsaWVudC5jb25uZWN0aW9uKSB7XG5cdFx0XHRcdFx0LyogV2UgaW50ZXJwcmV0IFJTQTRkIGFzIGluY2x1ZGluZyByZXF1ZXN0cyBtYWRlIGJ5IGEgY2xpZW50IGxpYiB0b1xuXHRcdFx0XHRcdCAqIGF1dGhlbnRpY2F0ZSB0cmlnZ2VyZWQgYnkgYW4gZXhwbGljaXQgYXV0aG9yaXplKCkgb3IgYW4gQVVUSCByZWNlaXZlZCBmcm9tXG5cdFx0XHRcdFx0ICogYWJseSwgbm90IGp1c3QgY29ubmVjdC1zZXF1ZW5jZS10cmlnZ2VyZWQgdG9rZW4gZmV0Y2hlcyAqL1xuXHRcdFx0XHRcdHNlbGYuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIFJUQzhcblx0XHRcdCAqIC0gV2hlbiBhdXRob3JpemUgY2FsbGVkIGJ5IGFuIGVuZCB1c2VyIGFuZCBoYXZlIGEgcmVhbHRpbWUgY29ubmVjdGlvbixcblx0XHRcdCAqIGRvbid0IGNhbGwgYmFjayB0aWxsIG5ldyB0b2tlbiBoYXMgdGFrZW4gZWZmZWN0LlxuXHRcdFx0ICogLSBVc2Ugc2VsZi5jbGllbnQuY29ubmVjdGlvbiBhcyBhIHByb3h5IGZvciAoc2VsZi5jbGllbnQgaW5zdGFuY2VvZiBSZWFsdGltZSksXG5cdFx0XHQgKiB3aGljaCBkb2Vzbid0IHdvcmsgaW4gbm9kZSBhcyBSZWFsdGltZSBpc24ndCBwYXJ0IG9mIHRoZSB2bSBjb250ZXh0IGZvciBSZXN0IGNsaWVudHMgKi9cblx0XHRcdGlmKHNlbGYuY2xpZW50LmNvbm5lY3Rpb24pIHtcblx0XHRcdFx0c2VsZi5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscywgY2FsbGJhY2spO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcblx0XHRcdH1cblx0XHR9KVxuXHR9O1xuXG5cdEF1dGgucHJvdG90eXBlLmF1dGhvcmlzZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdBdXRoLmF1dGhvcmlzZScsICdBdXRoLmF1dGhvcml6ZScpO1xuXHRcdHRoaXMuYXV0aG9yaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0LyogRm9yIGludGVybmFsIHVzZSwgZWcgYnkgY29ubmVjdGlvbk1hbmFnZXIgLSB1c2VmdWwgd2hlbiB3YW50IHRvIGNhbGwgYmFja1xuXHQgKiBhcyBzb29uIGFzIHdlIGhhdmUgdGhlIG5ldyB0b2tlbiwgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgaXQgdG8gdGFrZVxuXHQgKiBlZmZlY3Qgb24gdGhlIGNvbm5lY3Rpb24gYXMgI2F1dGhvcml6ZSBkb2VzICovXG5cdEF1dGgucHJvdG90eXBlLl9mb3JjZU5ld1Rva2VuID0gZnVuY3Rpb24odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdC8qIGdldCByaWQgb2YgY3VycmVudCB0b2tlbiBldmVuIGlmIHN0aWxsIHZhbGlkICovXG5cdFx0dGhpcy50b2tlbkRldGFpbHMgPSBudWxsO1xuXG5cdFx0LyogX3NhdmUgbm9ybWFsaXNlcyB0aGUgdG9rZW5QYXJhbXMgYW5kIGF1dGhPcHRpb25zIGFuZCB1cGRhdGVzIHRoZSBhdXRoXG5cdFx0ICogb2JqZWN0LiBBbGwgc3Vic2VxdWVudCBvcGVyYXRpb25zIHNob3VsZCB1c2UgdGhlIHZhbHVlcyBvbiBgdGhpc2AsXG5cdFx0ICogbm90IHRoZSBwYXNzZWQgaW4gb25lcy4gKi9cblx0XHR0aGlzLl9zYXZlVG9rZW5PcHRpb25zKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucyk7XG5cblx0XHRsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zKTtcblxuXHRcdHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKHRydWUsIGZ1bmN0aW9uKGVyciwgdG9rZW5EZXRhaWxzKSB7XG5cdFx0XHQvKiBSU0ExMGcgKi9cblx0XHRcdGRlbGV0ZSBzZWxmLnRva2VuUGFyYW1zLnRpbWVzdGFtcDtcblx0XHRcdGRlbGV0ZSBzZWxmLmF1dGhPcHRpb25zLnF1ZXJ5VGltZTtcblx0XHRcdGNhbGxiYWNrKGVyciwgdG9rZW5EZXRhaWxzKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0IGFuIGFjY2VzcyB0b2tlblxuXHQgKiBAcGFyYW0gYXV0aE9wdGlvbnNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3Qgb3B0aW9uczpcblx0ICogLSBrZXk6ICAgICAgICAgICB0aGUga2V5IHRvIHVzZS5cblx0ICpcblx0ICogLSBhdXRoQ2FsbGJhY2s6ICAob3B0aW9uYWwpIGEgSmF2YVNjcmlwdCBjYWxsYmFjayB0byBiZSBjYWxsZWQgdG8gZ2V0IGF1dGggaW5mb3JtYXRpb24uXG5cdCAqICAgICAgICAgICAgICAgICAgYXV0aENhbGxiYWNrIHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9mICh0b2tlblBhcmFtcywgY2FsbGJhY2spIHRoYXQgY2FsbHNcblx0ICogICAgICAgICAgICAgICAgICB0aGUgY2FsbGJhY2sgd2l0aCAoZXJyLCByZXN1bHQpLCB3aGVyZSByZXN1bHQgaXMgYW55IG9mOlxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlblJlcXVlc3Qgb2JqZWN0IChpZSB0aGUgcmVzdWx0IG9mIGEgcmVzdC5hdXRoLmNyZWF0ZVRva2VuUmVxdWVzdCBjYWxsKSxcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW5EZXRhaWxzIG9iamVjdCAoaWUgdGhlIHJlc3VsdCBvZiBhIHJlc3QuYXV0aC5yZXF1ZXN0VG9rZW4gY2FsbCksXG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuIHN0cmluZ1xuXHQgKlxuXHQgKiAtIGF1dGhVcmw6ICAgICAgIChvcHRpb25hbCkgYSBVUkwgdG8gYmUgdXNlZCB0byBHRVQgb3IgUE9TVCBhIHNldCBvZiB0b2tlbiByZXF1ZXN0XG5cdCAqICAgICAgICAgICAgICAgICAgcGFyYW1zLCB0byBvYnRhaW4gYSBzaWduZWQgdG9rZW4gcmVxdWVzdC5cblx0ICpcblx0ICogLSBhdXRoSGVhZGVyczogICAob3B0aW9uYWwpIGEgc2V0IG9mIGFwcGxpY2F0aW9uLXNwZWNpZmljIGhlYWRlcnMgdG8gYmUgYWRkZWQgdG8gYW55IHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBtYWRlIHRvIHRoZSBhdXRoVXJsLlxuXHQgKlxuXHQgKiAtIGF1dGhQYXJhbXM6ICAgIChvcHRpb25hbCkgYSBzZXQgb2YgYXBwbGljYXRpb24tc3BlY2lmaWMgcXVlcnkgcGFyYW1zIHRvIGJlIGFkZGVkIHRvIGFueVxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3QgbWFkZSB0byB0aGUgYXV0aFVybC5cblx0ICpcblx0ICogLSBxdWVyeVRpbWUgICAgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBhYmx5IHN5c3RlbSBzaG91bGQgYmVcblx0ICogICAgICAgICAgICAgICAgICBxdWVyaWVkIGZvciB0aGUgY3VycmVudCB0aW1lIHdoZW4gbm9uZSBpcyBzcGVjaWZpZWQgZXhwbGljaXRseVxuXHQgKlxuXHQgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbiByZXF1ZXN0XG5cdCAqXG5cdCAqIEBwYXJhbSB0b2tlblBhcmFtc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RlZCB0b2tlbjpcblx0ICogLSB0dGw6ICAgICAgICAgIChvcHRpb25hbCkgdGhlIHJlcXVlc3RlZCBsaWZlIG9mIHRoZSB0b2tlbiBpbiBtaWxsaXNlY29uZHMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXG5cdCAqICAgICAgICAgICAgICAgICAgYSBkZWZhdWx0IG9mIDEgaG91ciBpcyBwcm92aWRlZC4gVGhlIG1heGltdW0gbGlmZXRpbWUgaXMgMjRob3VyczsgYW55IHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBleGNlZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuXHQgKlxuXHQgKiAtIGNhcGFiaWxpdHk6ICAgIChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cblx0ICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcblx0ICogICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG5cdCAqXG5cdCAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJZCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxuXHQgKiAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgYSBjbGllbnRJZCBwYXNzZWQgaW4gY29uc3RydWN0aW5nIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcblx0ICpcblx0ICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG5cdCAqXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCB0b2tlbkRldGFpbHMpXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5yZXF1ZXN0VG9rZW4gPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0Lyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cblx0XHRpZih0eXBlb2YodG9rZW5QYXJhbXMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZW9mKGF1dGhPcHRpb25zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcblx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0aWYoIWNhbGxiYWNrICYmIHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlcXVlc3RUb2tlbicsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0LyogUlNBOGU6IGlmIGF1dGhPcHRpb25zIHBhc3NlZCBpbiwgdGhleSdyZSB1c2VkIGluc3RlYWQgb2Ygc3RvcmVkLCBkb24ndCBtZXJnZSB0aGVtICovXG5cdFx0YXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuXHRcdHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uY29weSh0aGlzLnRva2VuUGFyYW1zKTtcblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cblx0XHQvKiBmaXJzdCBzZXQgdXAgd2hhdGV2ZXIgY2FsbGJhY2sgd2lsbCBiZSB1c2VkIHRvIGdldCBzaWduZWRcblx0XHQgKiB0b2tlbiByZXF1ZXN0cyAqL1xuXHRcdHZhciB0b2tlblJlcXVlc3RDYWxsYmFjaywgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG5cblx0XHRpZihhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFjaycpO1xuXHRcdFx0dG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSBhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2s7XG5cdFx0fSBlbHNlIGlmKGF1dGhPcHRpb25zLmF1dGhVcmwpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmwnKTtcblx0XHRcdHRva2VuUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24ocGFyYW1zLCBjYikge1xuXHRcdFx0XHR2YXIgYXV0aEhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbih7YWNjZXB0OiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbid9LCBhdXRoT3B0aW9ucy5hdXRoSGVhZGVycyksXG5cdFx0XHRcdFx0dXNlUG9zdCA9IGF1dGhPcHRpb25zLmF1dGhNZXRob2QgJiYgYXV0aE9wdGlvbnMuYXV0aE1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSAncG9zdCc7XG5cdFx0XHRcdGlmKCF1c2VQb3N0KSB7XG5cdFx0XHRcdFx0LyogQ29tYmluZSBhdXRoUGFyYW1zIHdpdGggYW55IHFzIHBhcmFtcyBnaXZlbiBpbiB0aGUgYXV0aFVybCAqL1xuXHRcdFx0XHRcdHZhciBxdWVyeUlkeCA9IGF1dGhPcHRpb25zLmF1dGhVcmwuaW5kZXhPZignPycpO1xuXHRcdFx0XHRcdGlmKHF1ZXJ5SWR4ID4gLTEpIHtcblx0XHRcdFx0XHRcdHZhciBwcm92aWRlZFFzUGFyYW1zID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucGFyc2VRdWVyeVN0cmluZyhhdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKHF1ZXJ5SWR4KSk7XG5cdFx0XHRcdFx0XHRhdXRoT3B0aW9ucy5hdXRoVXJsID0gYXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZSgwLCBxdWVyeUlkeCk7XG5cdFx0XHRcdFx0XHQvKiBJbiBjYXNlIG9mIGNvbmZsaWN0LCBhdXRoUGFyYW1zIHRha2UgcHJlY2VkZW5jZSBvdmVyIHFzIHBhcmFtcyBpbiB0aGUgYXV0aFVybCAqL1xuXHRcdFx0XHRcdFx0YXV0aE9wdGlvbnMuYXV0aFBhcmFtcyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHByb3ZpZGVkUXNQYXJhbXMsIGF1dGhPcHRpb25zLmF1dGhQYXJhbXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvKiBSU0E4YzIgKi9cblx0XHRcdFx0dmFyIGF1dGhQYXJhbXMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbih7fSwgYXV0aE9wdGlvbnMuYXV0aFBhcmFtcyB8fCB7fSwgcGFyYW1zKTtcblx0XHRcdFx0dmFyIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRcdFx0dmFyIGNvbnRlbnRUeXBlO1xuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVjZWl2ZWQgRXJyb3I6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlID0gaGVhZGVyc1snY29udGVudC10eXBlJ107XG5cdFx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrJywgJ1JlY2VpdmVkOyBjb250ZW50LXR5cGU6ICcgKyBjb250ZW50VHlwZSArICc7IGJvZHk6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0Qm9keShib2R5KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGVyciB8fCB1bnBhY2tlZCkgcmV0dXJuIGNiKGVyciwgYm9keSk7XG5cdFx0XHRcdFx0aWYoYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNCdWZmZXIoYm9keSkpIGJvZHkgPSBib2R5LnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0aWYoIWNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdFx0XHRjYihuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdhdXRoVXJsIHJlc3BvbnNlIGlzIG1pc3NpbmcgYSBjb250ZW50LXR5cGUgaGVhZGVyJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIganNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xLFxuXHRcdFx0XHRcdFx0dGV4dCA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2p3dCcpID4gLTE7XG5cdFx0XHRcdFx0aWYoIWpzb24gJiYgIXRleHQpIHtcblx0XHRcdFx0XHRcdGNiKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2F1dGhVcmwgcmVzcG9uZGVkIHdpdGggdW5hY2NlcHRhYmxlIGNvbnRlbnQtdHlwZSAnICsgY29udGVudFR5cGUgKyAnLCBzaG91bGQgYmUgZWl0aGVyIHRleHQvcGxhaW4sIGFwcGxpY2F0aW9uL2p3dCBvciBhcHBsaWNhdGlvbi9qc29uJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihqc29uKSB7XG5cdFx0XHRcdFx0XHRpZihib2R5Lmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcblx0XHRcdFx0XHRcdFx0Y2IobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnYXV0aFVybCByZXNwb25zZSBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCcsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Ym9keSA9IEpTT04ucGFyc2UoYm9keSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRcdFx0Y2IobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5leHBlY3RlZCBlcnJvciBwcm9jZXNzaW5nIGF1dGhVUkwgcmVzcG9uc2U7IGVyciA9ICcgKyBlLm1lc3NhZ2UsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYihudWxsLCBib2R5LCBjb250ZW50VHlwZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVxdWVzdGluZyB0b2tlbiBmcm9tICcgKyBhdXRoT3B0aW9ucy5hdXRoVXJsICsgJzsgUGFyYW1zOiAnICsgSlNPTi5zdHJpbmdpZnkoYXV0aFBhcmFtcykgKyAnOyBtZXRob2Q6ICcgKyAodXNlUG9zdCA/ICdQT1NUJyA6ICdHRVQnKSk7XG5cdFx0XHRcdGlmKHVzZVBvc3QpIHtcblx0XHRcdFx0XHQvKiBzZW5kIGJvZHkgZm9ybS1lbmNvZGVkICovXG5cdFx0XHRcdFx0dmFyIGhlYWRlcnMgPSBhdXRoSGVhZGVycyB8fCB7fTtcblx0XHRcdFx0XHRoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuXHRcdFx0XHRcdHZhciBib2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10udG9RdWVyeVN0cmluZyhhdXRoUGFyYW1zKS5zbGljZSgxKTsgLyogc2xpY2UgaXMgdG8gcmVtb3ZlIHRoZSBpbml0aWFsICc/JyAqL1xuXHRcdFx0XHRcdGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ucG9zdFVyaShjbGllbnQsIGF1dGhPcHRpb25zLmF1dGhVcmwsIGhlYWRlcnMsIGJvZHksIHt9LCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldFVyaShjbGllbnQsIGF1dGhPcHRpb25zLmF1dGhVcmwsIGF1dGhIZWFkZXJzIHx8IHt9LCBhdXRoUGFyYW1zLCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMua2V5KSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nJyk7XG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHsgc2VsZi5jcmVhdGVUb2tlblJlcXVlc3QocGFyYW1zLCBhdXRoT3B0aW9ucywgY2IpOyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbXNnID0gXCJOZWVkIGEgbmV3IHRva2VuLCBidXQgYXV0aE9wdGlvbnMgZG9lcyBub3QgaW5jbHVkZSBhbnkgd2F5IHRvIHJlcXVlc3Qgb25lIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSlcIjtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgoKScsICdsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscCcpO1xuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMTcxLCA0MDMpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBub3JtYWxpc2UgdG9rZW4gcGFyYW1zICovXG5cdFx0aWYoJ2NhcGFiaWxpdHknIGluIHRva2VuUGFyYW1zKVxuXHRcdFx0dG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XG5cblx0XHR2YXIgdG9rZW5SZXF1ZXN0ID0gZnVuY3Rpb24oc2lnbmVkVG9rZW5QYXJhbXMsIHRva2VuQ2IpIHtcblx0XHRcdHZhciBrZXlOYW1lID0gc2lnbmVkVG9rZW5QYXJhbXMua2V5TmFtZSxcblx0XHRcdFx0cGF0aCA9ICcva2V5cy8nICsga2V5TmFtZSArICcvcmVxdWVzdFRva2VuJyxcblx0XHRcdFx0dG9rZW5VcmkgPSBmdW5jdGlvbihob3N0KSB7IHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7IH07XG5cblx0XHRcdHZhciByZXF1ZXN0SGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycygpO1xuXHRcdFx0aWYoYXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHJlcXVlc3RIZWFkZXJzLCBhdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyk7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnJlcXVlc3RUb2tlbicsICdTZW5kaW5nIFBPU1QgdG8gJyArIHBhdGggKyAnOyBUb2tlbiBwYXJhbXM6ICcgKyBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcykpO1xuXHRcdFx0c2lnbmVkVG9rZW5QYXJhbXMgPSBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcyk7XG5cdFx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnBvc3QoY2xpZW50LCB0b2tlblVyaSwgcmVxdWVzdEhlYWRlcnMsIHNpZ25lZFRva2VuUGFyYW1zLCBudWxsLCB0b2tlbkNiKTtcblx0XHR9O1xuXG5cdFx0dmFyIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSBmYWxzZSxcblx0XHRcdHRpbWVvdXRMZW5ndGggPSB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcblx0XHRcdFx0dmFyIG1zZyA9ICdUb2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRpbWVkIG91dCBhZnRlciAnICsgKHRpbWVvdXRMZW5ndGggLyAxMDAwKSArICcgc2Vjb25kcyc7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCBtc2cpO1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0fSwgdGltZW91dExlbmd0aCk7XG5cblx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayh0b2tlblBhcmFtcywgZnVuY3Rpb24oZXJyLCB0b2tlblJlcXVlc3RPckRldGFpbHMsIGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRpZih0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkKSByZXR1cm47XG5cdFx0XHRjbGVhclRpbWVvdXQodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0KTtcblxuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndG9rZW4gcmVxdWVzdCBzaWduaW5nIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdGNhbGxiYWNrKG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgY2FsbGJhY2sgbWlnaHQgYmUgYSB0b2tlbiBzdHJpbmcsIGEgc2lnbmVkIHJlcXVlc3Qgb3IgYSB0b2tlbiBkZXRhaWxzICovXG5cdFx0XHRpZih0eXBlb2YodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHN0cmluZyBpcyBlbXB0eScsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0fSBlbHNlIGlmKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVG9rZW4gc3RyaW5nIGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgbGVuZ3RoICh3YXMgJyArIHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggKyAnIGJ5dGVzKScsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0fSBlbHNlIGlmKHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcgfHwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSAnbnVsbCcpIHtcblx0XHRcdFx0XHQvKiBjb21tb24gZmFpbHVyZSBtb2RlIHdpdGggcG9vcmx5LWltcGxlbWVudGVkIGF1dGhDYWxsYmFja3MgKi9cblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUb2tlbiBzdHJpbmcgd2FzIGxpdGVyYWwgbnVsbC91bmRlZmluZWQnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdH0gZWxzZSBpZigodG9rZW5SZXF1ZXN0T3JEZXRhaWxzWzBdID09PSAneycpICYmICEoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vand0JykgPiAtMSkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUb2tlbiB3YXMgZG91YmxlLWVuY29kZWQ7IG1ha2Ugc3VyZSB5b3VcXCdyZSBub3QgSlNPTi1lbmNvZGluZyBhbiBhbHJlYWR5IGVuY29kZWQgdG9rZW4gcmVxdWVzdCBvciBkZXRhaWxzJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHt0b2tlbjogdG9rZW5SZXF1ZXN0T3JEZXRhaWxzfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mKHRva2VuUmVxdWVzdE9yRGV0YWlscykgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZyBvciB0b2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0LCBidXQgZ290IGEgJyArIHR5cGVvZih0b2tlblJlcXVlc3RPckRldGFpbHMpO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9iamVjdFNpemUgPSBKU09OLnN0cmluZ2lmeSh0b2tlblJlcXVlc3RPckRldGFpbHMpLmxlbmd0aDtcblx0XHRcdGlmKG9iamVjdFNpemUgPiBNQVhfVE9LRU5fTEVOR1RIICYmICFhdXRoT3B0aW9ucy5zdXBwcmVzc01heExlbmd0aENoZWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBzdHJpbmdpZmllZCBzaXplICh3YXMgJyArIG9iamVjdFNpemUgKyAnIGJ5dGVzKScsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoJ2lzc3VlZCcgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSB7XG5cdFx0XHRcdC8qIGEgdG9rZW5EZXRhaWxzIG9iamVjdCAqL1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlblJlcXVlc3RPckRldGFpbHMpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZighKCdrZXlOYW1lJyBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZywgdG9rZW4gcmVxdWVzdCBvYmplY3QsIG9yIHRva2VuIGRldGFpbHMgb2JqZWN0Jztcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsIG1zZyk7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIGl0J3MgYSB0b2tlbiByZXF1ZXN0LCBzbyBtYWtlIHRoZSByZXF1ZXN0ICovXG5cdFx0XHR0b2tlblJlcXVlc3QodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBmdW5jdGlvbihlcnIsIHRva2VuUmVzcG9uc2UsIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndG9rZW4gcmVxdWVzdCBBUEkgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdFx0XHRjYWxsYmFjayhub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXVucGFja2VkKSB0b2tlblJlc3BvbnNlID0gSlNPTi5wYXJzZSh0b2tlblJlc3BvbnNlKTtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ3Rva2VuIHJlY2VpdmVkJyk7XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuUmVzcG9uc2UpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgc2lnbiBhIHRva2VuIHJlcXVlc3QgYmFzZWQgb24gdGhlIGdpdmVuIG9wdGlvbnMuXG5cdCAqIE5PVEUgdGhpcyBjYW4gb25seSBiZSB1c2VkIHdoZW4gdGhlIGtleSB2YWx1ZSBpcyBhdmFpbGFibGUgbG9jYWxseS5cblx0ICogT3RoZXJ3aXNlLCBzaWduZWQgdG9rZW4gcmVxdWVzdHMgbXVzdCBiZSBvYnRhaW5lZCBmcm9tIHRoZSBrZXlcblx0ICogb3duZXIgKGVpdGhlciB1c2luZyB0aGUgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayBvciB1cmwpLlxuXHQgKlxuXHQgKiBAcGFyYW0gYXV0aE9wdGlvbnNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3Qgb3B0aW9uczpcblx0ICogLSBrZXk6ICAgICAgICAgICB0aGUga2V5IHRvIHVzZS4gSWYgbm90IHNwZWNpZmllZCwgYSBrZXkgcGFzc2VkIGluIGNvbnN0cnVjdGluZ1xuXHQgKiAgICAgICAgICAgICAgICAgIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcblx0ICpcblx0ICogLSBxdWVyeVRpbWUgICAgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBhYmx5IHN5c3RlbSBzaG91bGQgYmVcblx0ICogICAgICAgICAgICAgICAgICBxdWVyaWVkIGZvciB0aGUgY3VycmVudCB0aW1lIHdoZW4gbm9uZSBpcyBzcGVjaWZpZWQgZXhwbGljaXRseVxuXHQgKlxuXHQgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbiByZXF1ZXN0XG5cdCAqXG5cdCAqIEBwYXJhbSB0b2tlblBhcmFtc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RlZCB0b2tlbjpcblx0ICogLSB0dGw6ICAgICAgIChvcHRpb25hbCkgdGhlIHJlcXVlc3RlZCBsaWZlIG9mIHRoZSB0b2tlbiBpbiBtcy4gSWYgbm9uZSBpcyBzcGVjaWZpZWRcblx0ICogICAgICAgICAgICAgICAgICBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZSBpcyAyNGhvdXJzOyBhbnkgcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIGV4Y2VlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXG5cdCAqXG5cdCAqIC0gY2FwYWJpbGl0eTogICAgKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxuXHQgKiAgICAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cblx0ICpcblx0ICogLSBjbGllbnRJZDogICAgICAob3B0aW9uYWwpIGEgY2xpZW50IElkIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlbjsgaWYgbm90XG5cdCAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuXHQgKlxuXHQgKiAtIHRpbWVzdGFtcDogICAgIChvcHRpb25hbCkgdGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGVwb2NoLiBJZiBub25lIGlzIHNwZWNpZmllZCxcblx0ICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cblx0ICpcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmNyZWF0ZVRva2VuUmVxdWVzdCA9IGZ1bmN0aW9uKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHQvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xuXHRcdGlmKHR5cGVvZih0b2tlblBhcmFtcykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcblx0XHR9IGVsc2UgaWYodHlwZW9mKGF1dGhPcHRpb25zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcblx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0aWYoIWNhbGxiYWNrICYmIHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2NyZWF0ZVRva2VuUmVxdWVzdCcsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0LyogUlNBOWg6IGlmIGF1dGhPcHRpb25zIHBhc3NlZCBpbiwgdGhleSdyZSB1c2VkIGluc3RlYWQgb2Ygc3RvcmVkLCBkb24ndCBtZXJnZSB0aGVtICovXG5cdFx0YXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuXHRcdHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uY29weSh0aGlzLnRva2VuUGFyYW1zKTtcblxuXHRcdHZhciBrZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG5cdFx0aWYoIWtleSkge1xuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnTm8ga2V5IHNwZWNpZmllZCcsIDQwMTAxLCA0MDMpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGtleVBhcnRzID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0XHRrZXlOYW1lID0ga2V5UGFydHNbMF0sXG5cdFx0XHRrZXlTZWNyZXQgPSBrZXlQYXJ0c1sxXTtcblxuXHRcdGlmKCFrZXlTZWNyZXQpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0ludmFsaWQga2V5IHNwZWNpZmllZCcsIDQwMTAxLCA0MDMpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZih0b2tlblBhcmFtcy5jbGllbnRJZCA9PT0gJycpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIGNhbuKAmXQgYmUgYW4gZW1wdHkgc3RyaW5nJywgNDAwMTIsIDQwMCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCdjYXBhYmlsaXR5JyBpbiB0b2tlblBhcmFtcykge1xuXHRcdFx0dG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlcXVlc3QgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbih7IGtleU5hbWU6IGtleU5hbWUgfSwgdG9rZW5QYXJhbXMpLFxuXHRcdFx0Y2xpZW50SWQgPSB0b2tlblBhcmFtcy5jbGllbnRJZCB8fCAnJyxcblx0XHRcdHR0bCA9IHRva2VuUGFyYW1zLnR0bCB8fCAnJyxcblx0XHRcdGNhcGFiaWxpdHkgPSB0b2tlblBhcmFtcy5jYXBhYmlsaXR5IHx8ICcnLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHQoZnVuY3Rpb24oYXV0aG9yaXNlQ2IpIHtcblx0XHRcdGlmKHJlcXVlc3QudGltZXN0YW1wKSB7XG5cdFx0XHRcdGF1dGhvcmlzZUNiKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH07XG5cdFx0XHRzZWxmLmdldFRpbWVzdGFtcChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5xdWVyeVRpbWUsIGZ1bmN0aW9uKGVyciwgdGltZSkge1xuXHRcdFx0XHRpZihlcnIpIHtjYWxsYmFjayhlcnIpOyByZXR1cm47fVxuXHRcdFx0XHRyZXF1ZXN0LnRpbWVzdGFtcCA9IHRpbWU7XG5cdFx0XHRcdGF1dGhvcmlzZUNiKCk7XG5cdFx0XHR9KTtcblx0XHR9KShmdW5jdGlvbigpIHtcblx0XHRcdC8qIG5vbmNlICovXG5cdFx0XHQvKiBOT1RFOiB0aGVyZSBpcyBubyBleHBlY3RhdGlvbiB0aGF0IHRoZSBjbGllbnRcblx0XHRcdCAqIHNwZWNpZmllcyB0aGUgbm9uY2U7IHRoaXMgaXMgZG9uZSBieSB0aGUgbGlicmFyeVxuXHRcdFx0ICogSG93ZXZlciwgdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgY2xpZW50XG5cdFx0XHQgKiBzaW1wbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuICovXG5cdFx0XHR2YXIgbm9uY2UgPSByZXF1ZXN0Lm5vbmNlIHx8IChyZXF1ZXN0Lm5vbmNlID0gcmFuZG9tKCkpLFxuXHRcdFx0XHR0aW1lc3RhbXAgPSByZXF1ZXN0LnRpbWVzdGFtcDtcblxuXHRcdFx0dmFyIHNpZ25UZXh0XG5cdFx0XHQ9XHRyZXF1ZXN0LmtleU5hbWUgKyAnXFxuJ1xuXHRcdFx0K1x0dHRsICsgJ1xcbidcblx0XHRcdCtcdGNhcGFiaWxpdHkgKyAnXFxuJ1xuXHRcdFx0K1x0Y2xpZW50SWQgKyAnXFxuJ1xuXHRcdFx0K1x0dGltZXN0YW1wICsgJ1xcbidcblx0XHRcdCtcdG5vbmNlICsgJ1xcbic7XG5cblx0XHRcdC8qIG1hYyAqL1xuXHRcdFx0LyogTk9URTogdGhlcmUgaXMgbm8gZXhwZWN0YXRpb24gdGhhdCB0aGUgY2xpZW50XG5cdFx0XHQgKiBzcGVjaWZpZXMgdGhlIG1hYzsgdGhpcyBpcyBkb25lIGJ5IHRoZSBsaWJyYXJ5XG5cdFx0XHQgKiBIb3dldmVyLCB0aGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjbGllbnRcblx0XHRcdCAqIHNpbXBseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gKi9cblx0XHRcdHJlcXVlc3QubWFjID0gcmVxdWVzdC5tYWMgfHwgaG1hYyhzaWduVGV4dCwga2V5U2VjcmV0KTtcblxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlblJlcXVlc3QoKScsICdnZW5lcmF0ZWQgc2lnbmVkIHJlcXVlc3QnKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHJlcXVlc3QpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGF1dGggcXVlcnkgcGFyYW1zIHRvIHVzZSBmb3IgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbixcblx0ICogYmFzZWQgb24gdGhlIGN1cnJlbnQgYXV0aCBwYXJhbWV0ZXJzXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5nZXRBdXRoUGFyYW1zID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRpZih0aGlzLm1ldGhvZCA9PSAnYmFzaWMnKVxuXHRcdFx0Y2FsbGJhY2sobnVsbCwge2tleTogdGhpcy5rZXl9KTtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSwgZnVuY3Rpb24oZXJyLCB0b2tlbkRldGFpbHMpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwge2FjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VufSk7XG5cdFx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBhdXRob3JpemF0aW9uIGhlYWRlciB0byB1c2UgZm9yIGEgUkVTVCBvciBjb21ldCByZXF1ZXN0LFxuXHQgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmdldEF1dGhIZWFkZXJzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRpZih0aGlzLm1ldGhvZCA9PSAnYmFzaWMnKSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB7YXV0aG9yaXphdGlvbjogJ0Jhc2ljICcgKyB0aGlzLmJhc2ljS2V5fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlLCBmdW5jdGlvbihlcnIsIHRva2VuRGV0YWlscykge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB7YXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgdG9CYXNlNjQodG9rZW5EZXRhaWxzLnRva2VuKX0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgdGltZSBiYXNlZCBvbiB0aGUgbG9jYWwgY2xvY2ssXG5cdCAqIG9yIGlmIHRoZSBvcHRpb24gcXVlcnlUaW1lIGlzIHRydWUsIHJldHVybiB0aGUgc2VydmVyIHRpbWUuXG5cdCAqIFRoZSBzZXJ2ZXIgdGltZSBvZmZzZXQgZnJvbSB0aGUgbG9jYWwgdGltZSBpcyBzdG9yZWQgc28gdGhhdFxuXHQgKiBvbmx5IG9uZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IHRoZSB0aW1lIGlzIGV2ZXIgbmVlZGVkXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5nZXRUaW1lc3RhbXAgPSBmdW5jdGlvbihxdWVyeVRpbWUsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpICYmIChxdWVyeVRpbWUgfHwgdGhpcy5hdXRoT3B0aW9ucy5xdWVyeVRpbWUpKSB7XG5cdFx0XHR0aGlzLmNsaWVudC50aW1lKGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpKTtcblx0XHR9XG5cdH07XG5cblx0QXV0aC5wcm90b3R5cGUuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubm93KCkgKyAodGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCB8fCAwKTtcblx0fTtcblxuXHRBdXRoLnByb3RvdHlwZS5pc1RpbWVPZmZzZXRTZXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCAhPT0gbnVsbDtcblx0fTtcblxuXHRBdXRoLnByb3RvdHlwZS5fc2F2ZUJhc2ljT3B0aW9ucyA9IGZ1bmN0aW9uKGF1dGhPcHRpb25zKSB7XG5cdFx0dGhpcy5tZXRob2QgPSAnYmFzaWMnO1xuXHRcdHRoaXMua2V5ID0gYXV0aE9wdGlvbnMua2V5O1xuXHRcdHRoaXMuYmFzaWNLZXkgPSB0b0Jhc2U2NChhdXRoT3B0aW9ucy5rZXkpO1xuXHRcdHRoaXMuYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB7fTtcblx0XHRpZignY2xpZW50SWQnIGluIGF1dGhPcHRpb25zKSB7XG5cdFx0XHR0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuXHRcdH1cblx0fVxuXG5cdEF1dGgucHJvdG90eXBlLl9zYXZlVG9rZW5PcHRpb25zID0gZnVuY3Rpb24odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG5cdFx0dGhpcy5tZXRob2QgPSAndG9rZW4nO1xuXG5cdFx0aWYodG9rZW5QYXJhbXMpIHtcblx0XHRcdC8qIFdlIHRlbXBvcmFyaWx5IHBlcnNpc3QgdG9rZW5QYXJhbXMudGltZXN0YW1wIGluIGNhc2UgYSBuZXcgdG9rZW4gbmVlZHNcblx0XHRcdCAqIHRvIGJlIHJlcXVlc3RlZCwgdGhlbiBudWxsIGl0IG91dCBpbiB0aGUgY2FsbGJhY2sgb2Zcblx0XHRcdCAqIF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyBmb3IgUlNBMTBnIGNvbXBsaWFuY2UgKi9cblx0XHRcdHRoaXMudG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcztcblx0XHR9XG5cblx0XHRpZihhdXRoT3B0aW9ucykge1xuXHRcdFx0Lyogbm9ybWFsaXNlICovXG5cdFx0XHRpZihhdXRoT3B0aW9ucy50b2tlbikge1xuXHRcdFx0XHQvKiBvcHRpb25zLnRva2VuIG1heSBjb250YWluIGEgdG9rZW4gc3RyaW5nIG9yLCBmb3IgY29udmVuaWVuY2UsIGEgVG9rZW5EZXRhaWxzICovXG5cdFx0XHRcdGF1dGhPcHRpb25zLnRva2VuRGV0YWlscyA9ICh0eXBlb2YoYXV0aE9wdGlvbnMudG9rZW4pID09PSAnc3RyaW5nJykgPyB7dG9rZW46IGF1dGhPcHRpb25zLnRva2VufSA6IGF1dGhPcHRpb25zLnRva2VuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcblx0XHRcdFx0dGhpcy50b2tlbkRldGFpbHMgPSBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCdjbGllbnRJZCcgaW4gYXV0aE9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fdXNlclNldENsaWVudElkKGF1dGhPcHRpb25zLmNsaWVudElkKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zO1xuXHRcdH1cblx0fTtcblxuXHQvKiBAcGFyYW0gZm9yY2VTdXBlcnNlZGU6IGZvcmNlIGEgbmV3IHRva2VuIHJlcXVlc3QgZXZlbiBpZiB0aGVyZSdzIG9uZSBpblxuXHQgKiBwcm9ncmVzcywgbWFraW5nIGFsbCBwZW5kaW5nIGNhbGxiYWNrcyB3YWl0IGZvciB0aGUgbmV3IG9uZSAqL1xuXHRBdXRoLnByb3RvdHlwZS5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbihmb3JjZVN1cGVyc2VkZSwgY2FsbGJhY2spIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHR0b2tlbiA9IHRoaXMudG9rZW5EZXRhaWxzO1xuXG5cdFx0aWYodG9rZW4pIHtcblx0XHRcdGlmKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbi5jbGllbnRJZCkpIHtcblx0XHRcdFx0LyogNDAzIHRvIHRyaWdnZXIgYSBwZXJtYW5lbnRseSBmYWlsZWQgY2xpZW50IC0gUlNBMTVjICovXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ01pc21hdGNoIGJldHdlZW4gY2xpZW50SWQgaW4gdG9rZW4gKCcgKyB0b2tlbi5jbGllbnRJZCArICcpIGFuZCBjdXJyZW50IGNsaWVudElkICgnICsgdGhpcy5jbGllbnRJZCArICcpJywgNDAxMDIsIDQwMykpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiBSU0E0YjEgLS0gaWYgd2UgaGF2ZSBhIHNlcnZlciB0aW1lIG9mZnNldCBzZXQgYWxyZWFkeSwgd2UgY2FuXG5cdFx0XHQgKiBhdXRvcmVtb3ZlIGV4cGlyZWQgdG9rZW5zLiBFbHNlIGp1c3QgdXNlIHRoZSBjYWNoZWQgdG9rZW4uIElmIGl0IGlzXG5cdFx0XHQgKiBleHBpcmVkIEFibHkgd2lsbCB0ZWxsIHVzIGFuZCB3ZSdsbCBkaXNjYXJkIGl0IHRoZW4uICovXG5cdFx0XHRpZighdGhpcy5pc1RpbWVPZmZzZXRTZXQoKSB8fCAhdG9rZW4uZXhwaXJlcyB8fCAodG9rZW4uZXhwaXJlcyA+PSB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW4oKScsICd1c2luZyBjYWNoZWQgdG9rZW47IGV4cGlyZXMgPSAnICsgdG9rZW4uZXhwaXJlcyk7XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogZXhwaXJlZCwgc28gcmVtb3ZlIGFuZCBmYWxsdGhyb3VnaCB0byBnZXR0aW5nIGEgbmV3IG9uZSAqL1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ2RlbGV0aW5nIGV4cGlyZWQgdG9rZW4nKTtcblx0XHRcdHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcblx0XHR9XG5cblx0XHQodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8ICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBPYmplY3QobXVsdGljYXN0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKCkpKS5wdXNoKGNhbGxiYWNrKTtcblx0XHRpZih0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCAhPT0gbnVsbCAmJiAhZm9yY2VTdXBlcnNlZGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBSZXF1ZXN0IGEgbmV3IHRva2VuICovXG5cdFx0dmFyIHRva2VuUmVxdWVzdElkID0gdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBnZXRUb2tlblJlcXVlc3RJZCgpO1xuXHRcdHRoaXMucmVxdWVzdFRva2VuKHRoaXMudG9rZW5QYXJhbXMsIHRoaXMuYXV0aE9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgdG9rZW5SZXNwb25zZSkge1xuXHRcdFx0aWYoc2VsZi5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPiB0b2tlblJlcXVlc3RJZCkge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscygpJywgJ0Rpc2NhcmRpbmcgdG9rZW4gcmVxdWVzdCByZXNwb25zZTsgb3ZlcnRha2VuIGJ5IG5ld2VyIG9uZScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG5cdFx0XHR2YXIgY2FsbGJhY2tzID0gc2VsZi53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8IG5vb3A7XG5cdFx0XHRzZWxmLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrcyhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFja3MobnVsbCwgKHNlbGYudG9rZW5EZXRhaWxzID0gdG9rZW5SZXNwb25zZSkpO1xuXHRcdH0pO1xuXHR9O1xuXG5cblx0LyogVXNlci1zZXQ6IGNoZWNrIHR5cGVzLCAnKicgaXMgZGlzYWxsb3dlZCwgdGhyb3cgYW55IGVycm9ycyAqL1xuXHRBdXRoLnByb3RvdHlwZS5fdXNlclNldENsaWVudElkID0gZnVuY3Rpb24oY2xpZW50SWQpIHtcblx0XHRpZighKHR5cGVvZihjbGllbnRJZCkgPT09ICdzdHJpbmcnIHx8IGNsaWVudElkID09PSBudWxsKSkge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbCcsIDQwMDEyLCA0MDApO1xuXHRcdH0gZWxzZSBpZihjbGllbnRJZCA9PT0gJyonKSB7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDYW7igJl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCBpbnN0YW50aWF0ZSB0aGUgbGlicmFyeSB3aXRoIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSksIG9yIGlmIGNhbGxpbmcgYXV0aG9yaXplKCksIHBhc3MgaXQgaW4gYXMgYSB0b2tlblBhcmFtOiBhdXRob3JpemUoe2NsaWVudElkOiBcIipcIn0sIGF1dGhPcHRpb25zKScsIDQwMDEyLCA0MDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZXJyID0gdGhpcy5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuXHRcdFx0aWYoZXJyKSB0aHJvdyBlcnI7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIEFibHktc2V0OiBubyB0eXBlY2hlY2tpbmcsICcqJyBpcyBhbGxvd2VkIGJ1dCBub3Qgc2V0IG9uIHRoaXMuY2xpZW50SWQpLCByZXR1cm4gZXJyb3JzIHRvIHRoZSBjYWxsZXIgKi9cblx0QXV0aC5wcm90b3R5cGUuX3VuY2hlY2tlZFNldENsaWVudElkID0gZnVuY3Rpb24oY2xpZW50SWQpIHtcblx0XHRpZih0aGlzLl90b2tlbkNsaWVudElkTWlzbWF0Y2goY2xpZW50SWQpKSB7XG5cdFx0XHQvKiBTaG91bGQgbmV2ZXIgaGFwcGVuIGluIG5vcm1hbCBjaXJjdW1zdGFuY2VzIGFzIHJlYWx0aW1lIHNob3VsZFxuXHRcdFx0ICogcmVjb2duaXNlIG1pc21hdGNoIGFuZCByZXR1cm4gYW4gZXJyb3IgKi9cblx0XHRcdHZhciBtc2cgPSAnVW5leHBlY3RlZCBjbGllbnRJZCBtaXNtYXRjaDogY2xpZW50IGhhcyAnICsgdGhpcy5jbGllbnRJZCArICcsIHJlcXVlc3RlZCAnICsgY2xpZW50SWQ7XG5cdFx0XHR2YXIgZXJyID0gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMTAyLCA0MDEpO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoKScsIG1zZyk7XG5cdFx0XHRyZXR1cm4gZXJyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBSU0E3YTQ6IGlmIG9wdGlvbnMuY2xpZW50SWQgaXMgcHJvdmlkZWQgYW5kIGlzIG5vdFxuXHRcdFx0ICogbnVsbCwgaXQgb3ZlcnJpZGVzIGRlZmF1bHRUb2tlblBhcmFtcy5jbGllbnRJZCAqL1xuXHRcdFx0dGhpcy5jbGllbnRJZCA9IHRoaXMudG9rZW5QYXJhbXMuY2xpZW50SWQgPSBjbGllbnRJZDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRBdXRoLnByb3RvdHlwZS5fdG9rZW5DbGllbnRJZE1pc21hdGNoID0gZnVuY3Rpb24odG9rZW5DbGllbnRJZCkge1xuXHRcdHJldHVybiB0aGlzLmNsaWVudElkICYmXG5cdFx0XHQodGhpcy5jbGllbnRJZCAhPT0gJyonKSAmJlxuXHRcdFx0dG9rZW5DbGllbnRJZCAmJlxuXHRcdFx0KHRva2VuQ2xpZW50SWQgIT09ICcqJykgJiZcblx0XHRcdCh0aGlzLmNsaWVudElkICE9PSB0b2tlbkNsaWVudElkKTtcblx0fTtcblxuXHRBdXRoLmlzVG9rZW5FcnIgPSBmdW5jdGlvbihlcnJvcikge1xuXHRcdHJldHVybiBlcnJvci5jb2RlICYmIChlcnJvci5jb2RlID49IDQwMTQwKSAmJiAoZXJyb3IuY29kZSA8IDQwMTUwKTtcblx0fTtcblxuXHRyZXR1cm4gQXV0aDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGF1dGggPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChhdXRoX0F1dGgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNwb3J0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG5cblxuXG5cblxuXG5cbnZhciBDb21ldFRyYW5zcG9ydCA9IChmdW5jdGlvbigpIHtcblxuXHR2YXIgUkVRX1NFTkQgPSAwLFxuXHRcdFJFUV9SRUNWID0gMSxcblx0XHRSRVFfUkVDVl9QT0xMID0gMixcblx0XHRSRVFfUkVDVl9TVFJFQU0gPSAzO1xuXG5cdC8qIFRPRE86IGNhbiByZW1vdmUgb25jZSByZWFsdGltZSBzZW5kcyBwcm90b2NvbCBtZXNzYWdlIHJlc3BvbnNlcyBmb3IgY29tZXQgZXJyb3JzICovXG5cdGZ1bmN0aW9uIHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSB7XG5cdFx0dmFyIFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUyA9IFs4MDAxNSwgODAwMTcsIDgwMDMwXTtcblx0XHRpZihlcnIuY29kZSkge1xuXHRcdFx0aWYoX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycihlcnIpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRpZihfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluKFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUywgZXJyLmNvZGUpKSByZXR1cm4gdHJ1ZTtcblx0XHRcdHJldHVybiAoZXJyLmNvZGUgPj0gNDAwMDAgJiYgZXJyLmNvZGUgPCA1MDAwMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIExpa2VseSBhIG5ldHdvcmsgb3IgdHJhbnNwb3J0IGVycm9yIG9mIHNvbWUga2luZC4gQ2VydGFpbmx5IG5vdCBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpIHtcblx0XHQvKiBlcnIgd2lsbCBiZSBlaXRoZXIgYSBsZWdhY3kgKG5vbi1wcm90b2NvbG1lc3NhZ2UpIGNvbWV0IGVycm9yIHJlc3BvbnNlXG5cdFx0ICogKHdoaWNoIHdpbGwgaGF2ZSBhbiBlcnIuY29kZSksIG9yIGEgeGhyL25ldHdvcmsgZXJyb3IgKHdoaWNoIHdvbid0KS4gKi9cblx0XHRpZihzaG91bGRCZUVycm9yQWN0aW9uKGVycikpIHtcblx0XHRcdHJldHVybiBbX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe2FjdGlvbjogX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbi5FUlJPUiwgZXJyb3I6IGVycn0pXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFtfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7YWN0aW9uOiBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uLkRJU0NPTk5FQ1RFRCwgZXJyb3I6IGVycn0pXTtcblx0XHR9XG5cdH1cblxuXHQvKlxuXHQgKiBBIGJhc2UgY29tZXQgdHJhbnNwb3J0IGNsYXNzXG5cdCAqL1xuXHRmdW5jdGlvbiBDb21ldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0LyogYmluYXJ5IG5vdCBzdXBwb3J0ZWQgZm9yIGNvbWV0LCBzbyBqdXN0IGZhbGwgYmFjayB0byBkZWZhdWx0ICovXG5cdFx0cGFyYW1zLmZvcm1hdCA9IHVuZGVmaW5lZDtcblx0XHRwYXJhbXMuaGVhcnRiZWF0cyA9IHRydWU7XG5cdFx0X3RyYW5zcG9ydF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdC8qIHN0cmVhbWluZyBkZWZhdWx0cyB0byB0cnVlICovXG5cdFx0dGhpcy5zdHJlYW0gPSAoJ3N0cmVhbScgaW4gcGFyYW1zKSA/IHBhcmFtcy5zdHJlYW0gOiB0cnVlO1xuXHRcdHRoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuXHRcdHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuXHRcdHRoaXMucGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcblx0XHR0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG5cdH1cblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhDb21ldFRyYW5zcG9ydCwgX3RyYW5zcG9ydF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0Q29tZXRUcmFuc3BvcnQuUkVRX1NFTkQgPSBSRVFfU0VORDtcblx0Q29tZXRUcmFuc3BvcnQuUkVRX1JFQ1YgPSBSRVFfUkVDVjtcblx0Q29tZXRUcmFuc3BvcnQuUkVRX1JFQ1ZfUE9MTCA9IFJFUV9SRUNWX1BPTEw7XG5cdENvbWV0VHJhbnNwb3J0LlJFUV9SRUNWX1NUUkVBTSA9IFJFUV9SRUNWX1NUUkVBTTtcblxuXHQvKiBwdWJsaWMgaW5zdGFuY2UgbWV0aG9kcyAqL1xuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnc3RhcnRpbmcnKTtcblx0XHRfdHJhbnNwb3J0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBwYXJhbXMgPSB0aGlzLnBhcmFtcywgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuXHRcdHZhciBob3N0ID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRIb3N0KG9wdGlvbnMsIHBhcmFtcy5ob3N0KTtcblx0XHR2YXIgcG9ydCA9IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UG9ydChvcHRpb25zKTtcblx0XHR2YXIgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG5cblx0XHR0aGlzLmJhc2VVcmkgPSBjb21ldFNjaGVtZSArIGhvc3QgKyAnOicgKyBwb3J0ICsgJy9jb21ldC8nO1xuXHRcdHZhciBjb25uZWN0VXJpID0gdGhpcy5iYXNlVXJpICsgJ2Nvbm5lY3QnO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAndXJpOiAnICsgY29ubmVjdFVyaSk7XG5cdFx0dGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24oZXJyLCBhdXRoUGFyYW1zKSB7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKHNlbGYuaXNEaXNwb3NlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmF1dGhQYXJhbXMgPSBhdXRoUGFyYW1zO1xuXHRcdFx0dmFyIGNvbm5lY3RQYXJhbXMgPSBzZWxmLnBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuXHRcdFx0aWYoJ3N0cmVhbScgaW4gY29ubmVjdFBhcmFtcykgc2VsZi5zdHJlYW0gPSBjb25uZWN0UGFyYW1zLnN0cmVhbTtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnY29ubmVjdFBhcmFtczonICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1F1ZXJ5U3RyaW5nKGNvbm5lY3RQYXJhbXMpKTtcblxuXHRcdFx0LyogdGhpcyB3aWxsIGJlIHRoZSAncmVjdlJlcXVlc3QnIHNvIHRoaXMgY29ubmVjdGlvbiBjYW4gc3RyZWFtIG1lc3NhZ2VzICovXG5cdFx0XHR2YXIgcHJlY29ubmVjdGVkID0gZmFsc2UsXG5cdFx0XHRcdGNvbm5lY3RSZXF1ZXN0ID0gc2VsZi5yZWN2UmVxdWVzdCA9IHNlbGYuY3JlYXRlUmVxdWVzdChjb25uZWN0VXJpLCBudWxsLCBjb25uZWN0UGFyYW1zLCBudWxsLCAoc2VsZi5zdHJlYW0gPyBSRVFfUkVDVl9TVFJFQU0gOiBSRVFfUkVDVikpO1xuXG5cdFx0XHRjb25uZWN0UmVxdWVzdC5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0aWYoIXNlbGYucmVjdlJlcXVlc3QpIHtcblx0XHRcdFx0XHQvKiB0aGUgdHJhbnNwb3J0IHdhcyBkaXNwb3NlZCBiZWZvcmUgd2UgY29ubmVjdGVkICovXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFwcmVjb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRwcmVjb25uZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYuZW1pdCgncHJlY29ubmVjdCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYub25EYXRhKGRhdGEpO1xuXHRcdFx0fSk7XG5cdFx0XHRjb25uZWN0UmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihlcnIsIF9ib2R5LCBoZWFkZXJzKSB7XG5cdFx0XHRcdGlmKCFzZWxmLnJlY3ZSZXF1ZXN0KSB7XG5cdFx0XHRcdFx0LyogdGhlIHRyYW5zcG9ydCB3YXMgZGlzcG9zZWQgYmVmb3JlIHdlIGNvbm5lY3RlZCAqL1xuXHRcdFx0XHRcdGVyciA9IGVyciB8fCBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdSZXF1ZXN0IGNhbmNlbGxlZCcsIDgwMDAzLCA0MDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucmVjdlJlcXVlc3QgPSBudWxsO1xuXHRcdFx0XHQvKiBDb25uZWN0IHJlcXVlc3QgbWF5IGNvbXBsZXRlIHdpdGhvdXQgYSBlbWl0dGluZyAnZGF0YScgZXZlbnQgc2luY2UgdGhhdCBpcyBub3Rcblx0XHRcdFx0ICogZW1pdHRlZCBmb3IgZS5nLiBhIG5vbi1zdHJlYW1lZCBlcnJvciByZXNwb25zZS4gU3RpbGwgaW1wbGllcyBwcmVjb25uZWN0LiAqL1xuXHRcdFx0XHRpZighcHJlY29ubmVjdGVkICYmICFlcnIpIHtcblx0XHRcdFx0XHRwcmVjb25uZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYuZW1pdCgncHJlY29ubmVjdCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYub25BY3Rpdml0eSgpO1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRpZihlcnIuY29kZSkge1xuXHRcdFx0XHRcdFx0LyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG5cdFx0XHRcdFx0XHQgKiBjb25zaXN0ZW5kbHkgc2VuZHMgZXJyb3JzIHdyYXBwZWQgaW4gcHJvdG9jb2wgbWVzc2FnZXMsIHNob3VsZCBiZVxuXHRcdFx0XHRcdFx0ICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xuXHRcdFx0XHRcdFx0c2VsZi5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuXHRcdFx0XHRcdFx0ICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cblx0XHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLnJlY3YoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdGNvbm5lY3RSZXF1ZXN0LmV4ZWMoKTtcblx0XHR9KTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdENsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpJyk7XG5cdFx0dGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KHRydWUpO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0RGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpJyk7XG5cdFx0dGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KGZhbHNlKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdCA9IGZ1bmN0aW9uKGNsb3NpbmcpIHtcblx0XHR2YXIgY2xvc2VPckRpc2Nvbm5lY3RVcmkgPSBjbG9zaW5nID8gdGhpcy5jbG9zZVVyaSA6IHRoaXMuZGlzY29ubmVjdFVyaTtcblx0XHRpZihjbG9zZU9yRGlzY29ubmVjdFVyaSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRyZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KGNsb3NlT3JEaXNjb25uZWN0VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIFJFUV9TRU5EKTtcblxuXHRcdFx0cmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0JyArIChjbG9zaW5nID8gJ0Nsb3NlKCknIDogJ0Rpc2Nvbm5lY3QoKScpLCAncmVxdWVzdCByZXR1cm5lZCBlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0c2VsZi5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmVxdWVzdC5leGVjKCk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICcnKTtcblx0XHRpZighdGhpcy5pc0Rpc3Bvc2VkKSB7XG5cdFx0XHR0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuXHRcdFx0aWYodGhpcy5yZWN2UmVxdWVzdCkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJ2Fib3J0aW5nIHJlY3YgcmVxdWVzdCcpO1xuXHRcdFx0XHR0aGlzLnJlY3ZSZXF1ZXN0LmFib3J0KCk7XG5cdFx0XHRcdHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0LyogSW4gYWxtb3N0IGFsbCBjYXNlcyB0aGUgdHJhbnNwb3J0IHdpbGwgYmUgZmluaXNoZWQgYmVmb3JlIGl0J3Ncblx0XHRcdCAqIGRpc3Bvc2VkLiBGaW5pc2ggaGVyZSBqdXN0IHRvIG1ha2Ugc3VyZS4gKi9cblx0XHRcdHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGlzY29ubmVjdGVkKTtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZGlzcG9zZWQnKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdC8qIGlmIHRoaXMgdHJhbnNwb3J0IGhhcyBiZWVuIGRpc3Bvc2VkIHdoaWxzdCBhd2FpdGluZyBjb25uZWN0aW9uLCBkbyBub3RoaW5nICovXG5cdFx0aWYodGhpcy5pc0Rpc3Bvc2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogdGhlIGNvbm5lY3Rpb25LZXkgaW4gYSBjb21ldCBjb25uZWN0ZWQgcmVzcG9uc2UgaXMgcmVhbGx5XG5cdFx0ICogPGluc3RJZD4tPGNvbm5lY3Rpb25LZXk+ICovXG5cdFx0dmFyIGNvbm5lY3Rpb25TdHIgPSBtZXNzYWdlLmNvbm5lY3Rpb25LZXk7XG5cdFx0X3RyYW5zcG9ydF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5wcm90b3R5cGUub25Db25uZWN0LmNhbGwodGhpcywgbWVzc2FnZSk7XG5cblx0XHR2YXIgYmFzZUNvbm5lY3Rpb25VcmkgPSAgdGhpcy5iYXNlVXJpICsgY29ubmVjdGlvblN0cjtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29tZXRUcmFuc3BvcnQub25Db25uZWN0KCknLCAnYmFzZVVyaSA9ICcgKyBiYXNlQ29ubmVjdGlvblVyaSArICc7IGNvbm5lY3Rpb25LZXkgPSAnICsgbWVzc2FnZS5jb25uZWN0aW9uS2V5KTtcblx0XHR0aGlzLnNlbmRVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvc2VuZCc7XG5cdFx0dGhpcy5yZWN2VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL3JlY3YnO1xuXHRcdHRoaXMuY2xvc2VVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvY2xvc2UnO1xuXHRcdHRoaXMuZGlzY29ubmVjdFVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9kaXNjb25uZWN0Jztcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHRpZih0aGlzLnNlbmRSZXF1ZXN0KSB7XG5cdFx0XHQvKiB0aGVyZSBpcyBhIHBlbmRpbmcgc2VuZCwgc28gcXVldWUgdGhpcyBtZXNzYWdlICovXG5cdFx0XHR0aGlzLnBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuXHRcdFx0dGhpcy5wZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Lyogc2VuZCB0aGlzLCBwbHVzIGFueSBwZW5kaW5nLCBub3cgKi9cblx0XHR2YXIgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXMgfHwgW107XG5cdFx0cGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG5cdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuXG5cdFx0dGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZEFueVBlbmRpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXM7XG5cblx0XHRpZighcGVuZGluZ0l0ZW1zKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuXHRcdHRoaXMuc2VuZEl0ZW1zKHBlbmRpbmdJdGVtcyk7XG5cdH1cblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZEl0ZW1zID0gZnVuY3Rpb24oaXRlbXMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRzZW5kUmVxdWVzdCA9IHRoaXMuc2VuZFJlcXVlc3QgPSBzZWxmLmNyZWF0ZVJlcXVlc3Qoc2VsZi5zZW5kVXJpLCBudWxsLCBzZWxmLmF1dGhQYXJhbXMsIHRoaXMuZW5jb2RlUmVxdWVzdChpdGVtcyksIFJFUV9TRU5EKTtcblxuXHRcdHNlbmRSZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuXHRcdFx0aWYoZXJyKSBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQuc2VuZEl0ZW1zKCknLCAnb24gY29tcGxldGU6IGVyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdHNlbGYuc2VuZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0XHQvKiB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LCBldmVuIGlmIGEgbmFjaywgaXMgdXN1YWxseSBhIHByb3RvY29sIHJlc3BvbnNlXG5cdFx0XHQgKiBjb250YWluZWQgaW4gdGhlIGRhdGEuIEFuIGVyciBpcyBhbm9tb2xvdXMsIGFuZCBpbmRpY2F0ZXMgc29tZSBpc3N1ZSB3aXRoIHRoZVxuXHRcdFx0ICogbmV0d29yayx0cmFuc3BvcnQsIG9yIGNvbm5lY3Rpb24gKi9cblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRpZihlcnIuY29kZSkge1xuXHRcdFx0XHRcdC8qIEEgcHJvdG9jb2wgZXJyb3IgcmVjZWl2ZWQgZnJvbSByZWFsdGltZS4gVE9ETzogb25jZSByZWFsdGltZVxuXHRcdFx0XHRcdCAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG5cdFx0XHRcdFx0ICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xuXHRcdFx0XHRcdHNlbGYub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuXHRcdFx0XHRcdCAqIGp1c3QgZGlzY29ubmVjdCB0aGUgdHJhbnNwb3J0ICovXG5cdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihkYXRhKSB7XG5cdFx0XHRcdHNlbGYub25EYXRhKGRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihzZWxmLnBlbmRpbmdJdGVtcykge1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8qIElmIHRoZXJlJ3MgYSBuZXcgc2VuZCByZXF1ZXN0IGJ5IG5vdywgYW55IHBlbmRpbmcgaXRlbXMgd2lsbCBoYXZlXG5cdFx0XHRcdFx0ICogYmVlbiBwaWNrZWQgdXAgYnkgdGhhdDsgYW55IG5ldyBvbmVzIGFkZGVkIHNpbmNlIHRoZW4gd2lsbCBiZVxuXHRcdFx0XHRcdCAqIHBpY2tlZCB1cCBhZnRlciB0aGF0IG9uZSBjb21wbGV0ZXMgKi9cblx0XHRcdFx0XHRpZighc2VsZi5zZW5kUmVxdWVzdCkge1xuXHRcdFx0XHRcdFx0c2VsZi5zZW5kQW55UGVuZGluZygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0c2VuZFJlcXVlc3QuZXhlYygpO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZWN2ID0gZnVuY3Rpb24oKSB7XG5cdFx0LyogZG8gbm90aGluZyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgcmVxdWVzdCwgd2hpY2ggbWlnaHQgYmUgc3RyZWFtaW5nICovXG5cdFx0aWYodGhpcy5yZWN2UmVxdWVzdClcblx0XHRcdHJldHVybjtcblxuXHRcdC8qIElmIHdlJ3JlIG5vIGxvbmdlciBjb25uZWN0ZWQsIGRvIG5vdGhpbmcgKi9cblx0XHRpZighdGhpcy5pc0Nvbm5lY3RlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdHJlY3ZSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdCh0aGlzLnJlY3ZVcmksIG51bGwsIHRoaXMuYXV0aFBhcmFtcywgbnVsbCwgKHNlbGYuc3RyZWFtID8gUkVRX1JFQ1ZfU1RSRUFNIDogUkVRX1JFQ1ZfUE9MTCkpO1xuXG5cdFx0cmVjdlJlcXVlc3Qub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRzZWxmLm9uRGF0YShkYXRhKTtcblx0XHR9KTtcblx0XHRyZWN2UmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdHNlbGYucmVjdlJlcXVlc3QgPSBudWxsO1xuXHRcdFx0LyogQSByZXF1ZXN0IGNvbXBsZXRpbmcgbXVzdCBiZSBjb25zaWRlcmVkIGFjdGl2aXR5LCBhcyByZWFsdGltZSBzZW5kc1xuXHRcdFx0ICogaGVhcnRiZWF0cyBldmVyeSAxNXMgc2luY2UgYSByZXF1ZXN0IGJlZ2FuLCBub3QgZXZlcnkgMTVzIGFic29sdXRlbHkgKi9cblx0XHRcdHNlbGYub25BY3Rpdml0eSgpO1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGlmKGVyci5jb2RlKSB7XG5cdFx0XHRcdFx0LyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG5cdFx0XHRcdFx0ICogY29uc2lzdGVuZGx5IHNlbmRzIGVycm9ycyB3cmFwcGVkIGluIHByb3RvY29sIG1lc3NhZ2VzLCBzaG91bGQgYmVcblx0XHRcdFx0XHQgKiBhYmxlIHRvIHJlbW92ZSB0aGlzICovXG5cdFx0XHRcdFx0c2VsZi5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG5cdFx0XHRcdFx0ICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cblx0XHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnJlY3YoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHJlY3ZSZXF1ZXN0LmV4ZWMoKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24ocmVzcG9uc2VEYXRhKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBpdGVtcyA9IHRoaXMuZGVjb2RlUmVzcG9uc2UocmVzcG9uc2VEYXRhKTtcblx0XHRcdGlmKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aClcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21EZXNlcmlhbGl6ZWQoaXRlbXNbaV0pKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQub25EYXRhKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIGV2ZW50OiAnICsgZS5zdGFjayk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5lbmNvZGVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdEl0ZW1zKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RJdGVtcyk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmRlY29kZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2VEYXRhKSB7XG5cdFx0aWYodHlwZW9mKHJlc3BvbnNlRGF0YSkgPT0gJ3N0cmluZycpXG5cdFx0XHRyZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlRGF0YSk7XG5cdFx0cmV0dXJuIHJlc3BvbnNlRGF0YTtcblx0fTtcblxuXHQvKiBGb3IgY29tZXQsIHdlIGNvdWxkIGRvIHRoZSBhdXRoIHVwZGF0ZSBieSBhYm9ydGluZyB0aGUgY3VycmVudCByZWN2IGFuZFxuXHQgKiBzdGFydGluZyBhIG5ldyBvbmUgd2l0aCB0aGUgbmV3IHRva2VuLCB0aGF0J2QgYmUgc3VmZmljaWVudCBmb3IgcmVhbHRpbWUuXG5cdCAqIFByb2JsZW0gaXMgSlNPTlAgLSB5b3UgY2FuJ3QgY2FuY2VsIHRydWx5IGFib3J0IGEgcmVjdiBvbmNlIHN0YXJ0ZWQuIFNvXG5cdCAqIHdlIG5lZWQgdG8gc2VuZCBhbiBBVVRIIGZvciBqc29ucC4gSW4gd2hpY2ggY2FzZSBpdCdzIHNpbXBsZXIgdG8ga2VlcCBhbGxcblx0ICogY29tZXQgdHJhbnNwb3J0cyB0aGUgc2FtZSBhbmQgZG8gaXQgZm9yIGFsbCBvZiB0aGVtLiBTbyB3ZSBzZW5kIHRoZSBBVVRIXG5cdCAqIGluc3RlYWQsIGFuZCBkb24ndCBuZWVkIHRvIGFib3J0IHRoZSByZWN2ICovXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkF1dGhVcGRhdGVkID0gZnVuY3Rpb24odG9rZW5EZXRhaWxzKSB7XG5cdFx0dGhpcy5hdXRoUGFyYW1zID0ge2FjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VufTtcblx0fTtcblxuXHRyZXR1cm4gQ29tZXRUcmFuc3BvcnQ7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKENvbWV0VHJhbnNwb3J0KTtcblxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbnZhciBXZWJTdG9yYWdlID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgc2Vzc2lvblN1cHBvcnRlZCxcblx0XHRsb2NhbFN1cHBvcnRlZCxcblx0XHR0ZXN0ID0gJ2FibHlqcy1zdG9yYWdlLXRlc3QnO1xuXG5cdC8qIEV2ZW4ganVzdCBhY2Nlc3NpbmcgdGhlIHNlc3Npb24vbG9jYWxTdG9yYWdlIG9iamVjdCBjYW4gdGhyb3cgYVxuXHQgKiBzZWN1cml0eSBleGNlcHRpb24gaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdpdGggc29tZSBicm93c2Vycy4gSW5cblx0ICogb3RoZXJzLCBjYWxsaW5nIHNldEl0ZW0gd2lsbCB0aHJvdy4gU28gaGF2ZSB0byBjaGVjayBpbiB0aGlzXG5cdCAqIHNvbWV3aGF0IHJvdW5kYWJvdXQgd2F5LiAoSWYgdW5zdXBwb3J0ZWQgb3Igbm8gZ2xvYmFsIG9iamVjdCxcblx0ICogd2lsbCB0aHJvdyBvbiBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSBvZiB1bmRlZmluZWQpICovXG5cdHRyeSB7XG5cdFx0Z2xvYmFsLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0odGVzdCwgdGVzdCk7XG5cdFx0Z2xvYmFsLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odGVzdCk7XG5cdFx0c2Vzc2lvblN1cHBvcnRlZCA9IHRydWU7XG5cdH0gY2F0Y2goZSkge1xuXHRcdHNlc3Npb25TdXBwb3J0ZWQgPSBmYWxzZTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0Z2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuXHRcdGdsb2JhbC5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcblx0XHRsb2NhbFN1cHBvcnRlZCA9IHRydWU7XG5cdH0gY2F0Y2goZSkge1xuXHRcdGxvY2FsU3VwcG9ydGVkID0gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJTdG9yYWdlKCkge31cblxuXHRmdW5jdGlvbiBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pIHtcblx0XHRyZXR1cm4gc2Vzc2lvbiA/IGdsb2JhbC5zZXNzaW9uU3RvcmFnZSA6IGdsb2JhbC5sb2NhbFN0b3JhZ2U7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUsIHR0bCwgc2Vzc2lvbikge1xuXHRcdHZhciB3cmFwcGVkVmFsdWUgPSB7dmFsdWU6IHZhbHVlfTtcblx0XHRpZih0dGwpIHtcblx0XHRcdHdyYXBwZWRWYWx1ZS5leHBpcmVzID0gX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpICsgdHRsO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5zZXRJdGVtKG5hbWUsIEpTT04uc3RyaW5naWZ5KHdyYXBwZWRWYWx1ZSkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0KG5hbWUsIHNlc3Npb24pIHtcblx0XHR2YXIgcmF3SXRlbSA9IHN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikuZ2V0SXRlbShuYW1lKTtcblx0XHRpZighcmF3SXRlbSkgcmV0dXJuIG51bGw7XG5cdFx0dmFyIHdyYXBwZWRWYWx1ZSA9IEpTT04ucGFyc2UocmF3SXRlbSk7XG5cdFx0aWYod3JhcHBlZFZhbHVlLmV4cGlyZXMgJiYgKHdyYXBwZWRWYWx1ZS5leHBpcmVzIDwgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpKSkge1xuXHRcdFx0c3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5yZW1vdmVJdGVtKG5hbWUpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB3cmFwcGVkVmFsdWUudmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmUobmFtZSwgc2Vzc2lvbikge1xuXHRcdHJldHVybiBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG5cdH1cblxuXHRpZihsb2NhbFN1cHBvcnRlZCkge1xuXHRcdFdlYlN0b3JhZ2Uuc2V0ICAgID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHR0bCkgeyByZXR1cm4gc2V0KG5hbWUsIHZhbHVlLCB0dGwsIGZhbHNlKTsgfTtcblx0XHRXZWJTdG9yYWdlLmdldCAgICA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGdldChuYW1lLCBmYWxzZSk7IH07XG5cdFx0V2ViU3RvcmFnZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiByZW1vdmUobmFtZSwgZmFsc2UpOyB9O1xuXHR9XG5cblx0aWYoc2Vzc2lvblN1cHBvcnRlZCkge1xuXHRcdFdlYlN0b3JhZ2Uuc2V0U2Vzc2lvbiAgICA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCB0dGwpIHsgcmV0dXJuIHNldChuYW1lLCB2YWx1ZSwgdHRsLCB0cnVlKTsgfTtcblx0XHRXZWJTdG9yYWdlLmdldFNlc3Npb24gICAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBnZXQobmFtZSwgdHJ1ZSk7IH07XG5cdFx0V2ViU3RvcmFnZS5yZW1vdmVTZXNzaW9uID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gcmVtb3ZlKG5hbWUsIHRydWUpOyB9O1xuXHR9XG5cblx0cmV0dXJuIFdlYlN0b3JhZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFdlYlN0b3JhZ2UpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpKVxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXHQgICAgICAgICAgICB2YXIgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG5cblx0ICAgICAgICAgICAgaWYgKCFyZXZlcnNlTWFwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXAgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSWdub3JlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKTtcblxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkge1xuXHQgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpICUgNCkge1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiAoNiAtIChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0c0NvbWJpbmVkID0gYml0czEgfCBiaXRzMjtcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IGJpdHNDb21iaW5lZCA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cblxuXG5cblxuXG5cbnZhciBDcnlwdG8gPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBERUZBVUxUX0FMR09SSVRITSA9ICdhZXMnO1xuXHR2YXIgREVGQVVMVF9LRVlMRU5HVEggPSAyNTY7IC8vIGJpdHNcblx0dmFyIERFRkFVTFRfTU9ERSA9ICdjYmMnO1xuXHR2YXIgREVGQVVMVF9CTE9DS0xFTkdUSCA9IDE2OyAvLyBieXRlc1xuXHR2YXIgREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyA9IDQ7IC8vIDMyLWJpdCB3b3Jkc1xuXHR2YXIgVUlOVDMyX1NVUCA9IDB4MTAwMDAwMDAwO1xuXHR2YXIgSU5UMzJfU1VQID0gMHg4MDAwMDAwMDtcblxuXHQvKipcblx0ICogSW50ZXJuYWw6IGdlbmVyYXRlIGFuIGFycmF5IG9mIHNlY3VyZSByYW5kb20gd29yZHMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGVuZ3RoIG9mIGJ5dGVzXG5cdCAqIEBwYXJhbSBieXRlc1xuXHQgKiBAcGFyYW0gY2FsbGJhY2tcblx0ICovXG5cdHZhciBnZW5lcmF0ZVJhbmRvbTtcblx0aWYocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21Xb3JkQXJyYXkpIHtcblx0XHRnZW5lcmF0ZVJhbmRvbSA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tV29yZEFycmF5O1xuXHR9IGVsc2UgaWYodHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcykge1xuXHRcdHZhciBibG9ja1JhbmRvbUFycmF5ID0gbmV3IFVpbnQzMkFycmF5KERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMpO1xuXHRcdGdlbmVyYXRlUmFuZG9tID0gZnVuY3Rpb24oYnl0ZXMsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgd29yZHMgPSBieXRlcyAvIDQsIG5hdGl2ZUFycmF5ID0gKHdvcmRzID09IERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMpID8gYmxvY2tSYW5kb21BcnJheSA6IG5ldyBVaW50MzJBcnJheSh3b3Jkcyk7XG5cdFx0XHRwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcyhuYXRpdmVBcnJheSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShuYXRpdmVBcnJheSkpXG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGdlbmVyYXRlUmFuZG9tID0gZnVuY3Rpb24oYnl0ZXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NQUpPUiwgJ0FibHkuQ3J5cHRvLmdlbmVyYXRlUmFuZG9tKCknLCAnV2FybmluZzogdGhlIGJyb3dzZXIgeW91IGFyZSB1c2luZyBkb2VzIG5vdCBzdXBwb3J0IHNlY3VyZSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tbmVzcyBnZW5lcmF0aW9uOyBmYWxsaW5nIGJhY2sgdG8gaW5zZWN1cmUgTWF0aC5yYW5kb20oKScpO1xuXHRcdFx0dmFyIHdvcmRzID0gYnl0ZXMgLyA0LCBhcnJheSA9IG5ldyBBcnJheSh3b3Jkcyk7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgd29yZHM7IGkrKykge1xuXHRcdFx0XHQvKiBjcnlwdG9qcyB3b3JkYXJyYXlzIHVzZSBzaWduZWQgaW50cy4gV2hlbiBXb3JkQXJyYXkuY3JlYXRlIGlzIGZlZCBhXG5cdFx0XHRcdCogVWludDMyQXJyYXkgdW5zaWduZWQgYXJlIGNvbnZlcnRlZCB0byBzaWduZWQgYXV0b21hdGljYWxseSwgYnV0IHdoZW5cblx0XHRcdFx0KiBmZWQgYSBub3JtYWwgYXJyYXkgdGhleSBhcmVuJ3QsIHNvIG5lZWQgdG8gZG8gc28gb3Vyc2VsdmVzIGJ5XG5cdFx0XHRcdCogc3VidHJhY3RpbmcgSU5UMzJfU1VQICovXG5cdFx0XHRcdGFycmF5W2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogVUlOVDMyX1NVUCkgLSBJTlQzMl9TVVA7XG5cdFx0XHR9XG5cblx0XHRcdGNhbGxiYWNrKG51bGwsIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKGFycmF5KSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbDogY2FsY3VsYXRlIHRoZSBwYWRkZWQgbGVuZ3RoIG9mIGEgZ2l2ZW4gcGxhaW50ZXh0XG5cdCAqIHVzaW5nIFBLQ1M1LlxuXHQgKiBAcGFyYW0gcGxhaW50ZXh0TGVuZ3RoXG5cdCAqIEByZXR1cm5cblx0ICovXG5cdGZ1bmN0aW9uIGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpIHtcblx0XHRyZXR1cm4gKHBsYWludGV4dExlbmd0aCArIERFRkFVTFRfQkxPQ0tMRU5HVEgpICYgLURFRkFVTFRfQkxPQ0tMRU5HVEg7XG5cdH1cblxuXHQvKipcblx0ICogSW50ZXJuYWw6IGNoZWNrcyB0aGF0IHRoZSBjaXBoZXJQYXJhbXMgYXJlIGEgdmFsaWQgY29tYmluYXRpb24uIEN1cnJlbnRseVxuXHQgKiBqdXN0IGNoZWNrcyB0aGF0IHRoZSBjYWxjdWxhdGVkIGtleUxlbmd0aCBpcyBhIHZhbGlkIG9uZSBmb3IgYWVzLWNiY1xuXHQgKi9cblx0ZnVuY3Rpb24gdmFsaWRhdGVDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG5cdFx0aWYocGFyYW1zLmFsZ29yaXRobSA9PT0gJ2FlcycgJiYgcGFyYW1zLm1vZGUgPT09ICdjYmMnKSB7XG5cdFx0XHRpZihwYXJhbXMua2V5TGVuZ3RoID09PSAxMjggfHwgcGFyYW1zLmtleUxlbmd0aCA9PT0gMjU2KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2V5IGxlbmd0aCAnICsgcGFyYW1zLmtleUxlbmd0aCArICcgZm9yIGFlcy1jYmMgZW5jcnlwdGlvbi4gRW5jcnlwdGlvbiBrZXkgbXVzdCBiZSAxMjggb3IgMjU2IGJpdHMgKDE2IG9yIDMyIEFTQ0lJIGNoYXJhY3RlcnMpJyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbm9ybWFsaXNlQmFzZTY0KHN0cmluZykge1xuXHRcdC8qIHVybC1zYWZlIGJhc2U2NCBzdHJpbmdzIHVzZSBfIGFuZCAtIGluc3RyZWFkIG9mIC8gYW5kICsgKi9cblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoJ18nLCAnLycpLnJlcGxhY2UoJy0nLCAnKycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludGVybmFsOiBhIGJsb2NrIGNvbnRhaW5pbmcgemVyb3Ncblx0ICovXG5cdHZhciBlbXB0eUJsb2NrID0gY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzAsMCwwLDBdKTtcblxuXHQvKipcblx0ICogSW50ZXJuYWw6IG9idGFpbiB0aGUgcGtjczUgcGFkZGluZyBzdHJpbmcgZm9yIGEgZ2l2ZW4gcGFkZGVkIGxlbmd0aDtcblx0ICovXG5cdHZhciBwa2NzNVBhZGRpbmcgPSBbXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MTAxMDEwMTAsMHgxMDEwMTAxMCwweDEwMTAxMDEwLDB4MTAxMDEwMTBdLCAxNiksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDEwMDAwMDBdLCAxKSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwMjAyMDAwMF0sIDIpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDAzMDMwMzAwXSwgMyksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDQwNDA0MDRdLCA0KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNTA1MDUwNSwweDA1MDAwMDAwXSwgNSksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDYwNjA2MDYsMHgwNjA2MDAwMF0sIDYpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA3MDcwNzA3LDB4MDcwNzA3MDBdLCA3KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwODA4MDgwOCwweDA4MDgwODA4XSwgOCksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDkwOTA5MDksMHgwOTA5MDkwOSwweDA5MDAwMDAwXSwgOSksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGEwYTBhMGEsMHgwYTBhMGEwYSwweDBhMGEwMDAwXSwgMTApLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBiMGIwYjBiLDB4MGIwYjBiMGIsMHgwYjBiMGIwMF0sIDExKSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwYzBjMGMwYywweDBjMGMwYzBjLDB4MGMwYzBjMGNdLCAxMiksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGQwZDBkMGQsMHgwZDBkMGQwZCwweDBkMGQwZDBkLDB4MGQwMDAwMDBdLCAxMyksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGUwZTBlMGUsMHgwZTBlMGUwZSwweDBlMGUwZTBlLDB4MGUwZTAwMDBdLCAxNCksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGYwZjBmMGYsMHgwZjBmMGYwZiwweDBmMGYwZjBmLDB4MGYwZjBmMGZdLCAxNSksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MTAxMDEwMTAsMHgxMDEwMTAxMCwweDEwMTAxMDEwLDB4MTAxMDEwMTBdLCAxNilcblx0XTtcblxuXHQvKipcblx0ICogVXRpbGl0eSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIGZvciBtZXNzYWdlIHBheWxvYWQgZW5jcnlwdGlvbi5cblx0ICpcblx0ICogVGhpcyBjbGFzcyBzdXBwb3J0cyBBRVMvQ0JDL1BLQ1M1IHdpdGggYSBkZWZhdWx0IGtleWxlbmd0aCBvZiAxMjggYml0c1xuXHQgKiBidXQgc3VwcG9ydGluZyBvdGhlciBrZXlsZW5ndGhzLiBPdGhlciBhbGdvcml0aG1zIGFuZCBjaGFpbmluZyBtb2RlcyBhcmVcblx0ICogbm90IHN1cHBvcnRlZCBkaXJlY3RseSwgYnV0IHN1cHBvcnRhYmxlIGJ5IGV4dGVuZGluZy9pbXBsZW1lbnRpbmcgdGhlIGJhc2Vcblx0ICogY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyBoZXJlLlxuXHQgKlxuXHQgKiBTZWN1cmUgcmFuZG9tIGRhdGEgZm9yIGNyZWF0aW9uIG9mIEluaXRpYWxpemF0aW9uIFZlY3RvcnMgKElWcykgYW5kIGtleXNcblx0ICogaXMgb2J0YWluZWQgZnJvbSB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpZiBhdmFpbGFibGUsIG9yIGZyb21cblx0ICogTWF0aC5yYW5kb20oKSBpZiBub3QuIENsaWVudHMgd2hvIGRvIG5vdCB3YW50IHRvIGRlcGVuZCBvbiBNYXRoLnJhbmRvbSgpXG5cdCAqIHNob3VsZCBwb2x5ZmlsbCB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB3aXRoIGEgbGlicmFyeSB0aGF0IHNlZWRzXG5cdCAqIGEgUFJORyB3aXRoIHJlYWwgZW50cm9weS5cblx0ICpcblx0ICogRWFjaCBtZXNzYWdlIHBheWxvYWQgaXMgZW5jcnlwdGVkIHdpdGggYW4gSVYgaW4gQ0JDIG1vZGUsIGFuZCB0aGUgSVYgaXNcblx0ICogY29uY2F0ZW5hdGVkIHdpdGggdGhlIHJlc3VsdGluZyByYXcgY2lwaGVydGV4dCB0byBjb25zdHJ1Y3QgdGhlIFwiY2lwaGVydGV4dFwiXG5cdCAqIGRhdGEgcGFzc2VkIHRvIHRoZSByZWNpcGllbnQuXG5cdCAqL1xuXHRmdW5jdGlvbiBDcnlwdG8oKSB7fVxuXG5cdC8qKlxuXHQgKiBBIGNsYXNzIGVuY2Fwc3VsYXRpbmcgdGhlIGNsaWVudC1zcGVjaWZpYWJsZSBwYXJhbWV0ZXJzIGZvclxuXHQgKiB0aGUgY2lwaGVyLlxuXHQgKlxuXHQgKiBhbGdvcml0aG0gaXMgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobSBpbiB0aGUgZGVmYXVsdCBzeXN0ZW0gcHJvdmlkZXIsXG5cdCAqIG9yIHRoZSBsb3dlci1jYXNlZCB2ZXJzaW9uIG9mIGl0OyBlZyBcImFlc1wiIG9yIFwiQUVTXCIuXG5cdCAqXG5cdCAqIENsaWVudHMgYXJlIHJlY29tbWVuZGVkIHRvIG5vdCBjYWxsIHRoaXMgZGlyZWN0bHksIGJ1dCBpbnN0ZWFkIHRvIHVzZSB0aGVcblx0ICogQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMgaGVscGVyLCB3aGljaCB3aWxsIGZpbGwgaW4gYW55IGZpZWxkcyBub3Qgc3VwcGxpZWRcblx0ICogd2l0aCBkZWZhdWx0IHZhbHVlcyBhbmQgdmFsaWRhdGlvbiB0aGUgcmVzdWx0LlxuXHQgKi9cblx0ZnVuY3Rpb24gQ2lwaGVyUGFyYW1zKCkge1xuXHRcdHRoaXMuYWxnb3JpdGhtID0gbnVsbDtcblx0XHR0aGlzLmtleUxlbmd0aCA9IG51bGw7XG5cdFx0dGhpcy5tb2RlID0gbnVsbDtcblx0XHR0aGlzLmtleSA9IG51bGw7XG5cdH1cblx0Q3J5cHRvLkNpcGhlclBhcmFtcyA9IENpcGhlclBhcmFtcztcblxuXHQvKipcblx0ICogT2J0YWluIGEgY29tcGxldGUgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIGZyb20gdGhlIHByb3ZpZGVkIHBhcmFtcywgZmlsbGluZ1xuXHQgKiBpbiBhbnkgbm90IHByb3ZpZGVkIHdpdGggZGVmYXVsdCB2YWx1ZXMsIGNhbGN1bGF0aW5nIGEga2V5TGVuZ3RoIGZyb21cblx0ICogdGhlIHN1cHBsaWVkIGtleSwgYW5kIHZhbGlkYXRpbmcgdGhlIHJlc3VsdC5cblx0ICogQHBhcmFtIHBhcmFtcyBhbiBvYmplY3QgY29udGFpbmluZyBhdCBhIG1pbmltdW0gYSBga2V5YCBrZXkgd2l0aCB2YWx1ZSB0aGVcblx0ICoga2V5LCBhcyBlaXRoZXIgYSBiaW5hcnkgKEFycmF5QnVmZmVyLCBBcnJheSwgV29yZEFycmF5KSBvciBhXG5cdCAqIGJhc2U2NC1lbmNvZGVkIHN0cmluZy4gTWF5IG9wdGlvbmFsbHkgYWxzbyBjb250YWluOiBhbGdvcml0aG0gKGRlZmF1bHRzIHRvXG5cdCAqIEFFUyksIG1vZGUgKGRlZmF1bHRzIHRvICdjYmMnKVxuXHQgKi9cblx0Q3J5cHRvLmdldERlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHR2YXIga2V5O1xuXHRcdC8qIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgKi9cblx0XHRpZigodHlwZW9mKHBhcmFtcykgPT09ICdmdW5jdGlvbicpIHx8ICh0eXBlb2YocGFyYW1zKSA9PT0gJ3N0cmluZycpKSB7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlcHJlY2F0ZWQoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKGtleSwgY2FsbGJhY2spJywgJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pJyk7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRDcnlwdG8uZ2VuZXJhdGVSYW5kb21LZXkoZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdFx0cGFyYW1zKG51bGwsIENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pKTtcblx0XHRcdFx0fSlcblx0XHRcdH0gZWxzZSBpZih0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGFyZ3VtZW50c1sxXShudWxsLCBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7a2V5OiBwYXJhbXN9KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcycpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCFwYXJhbXMua2V5KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleSBpcyByZXF1aXJlZCcpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YocGFyYW1zLmtleSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRrZXkgPSBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInBhcnNlXCJdKShub3JtYWxpc2VCYXNlNjQocGFyYW1zLmtleSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRrZXkgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvV29yZEFycmF5KHBhcmFtcy5rZXkpOyAvLyBFeHBlY3Qga2V5IHRvIGJlIGFuIEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgV29yZEFycmF5IGF0IHRoaXMgcG9pbnRcblx0XHR9XG5cblx0XHR2YXIgY2lwaGVyUGFyYW1zID0gbmV3IENpcGhlclBhcmFtcygpO1xuXHRcdGNpcGhlclBhcmFtcy5rZXkgPSBrZXk7XG5cdFx0Y2lwaGVyUGFyYW1zLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gfHwgREVGQVVMVF9BTEdPUklUSE07XG5cdFx0Y2lwaGVyUGFyYW1zLmtleUxlbmd0aCA9IGtleS53b3Jkcy5sZW5ndGggKiAoNCAqIDgpO1xuXHRcdGNpcGhlclBhcmFtcy5tb2RlID0gcGFyYW1zLm1vZGUgfHwgREVGQVVMVF9NT0RFO1xuXG5cdFx0aWYocGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMua2V5TGVuZ3RoICE9PSBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleUxlbmd0aCBvZiAnICsgcGFyYW1zLmtleUxlbmd0aCArICcgd2FzIHNwZWNpZmllZCwgYnV0IHRoZSBrZXkgYWN0dWFsbHkgaGFzIGxlbmd0aCAnICsgY2lwaGVyUGFyYW1zLmtleUxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0dmFsaWRhdGVDaXBoZXJQYXJhbXMoY2lwaGVyUGFyYW1zKTtcblx0XHRyZXR1cm4gY2lwaGVyUGFyYW1zO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhIHJhbmRvbSBlbmNyeXB0aW9uIGtleSBmcm9tIHRoZSBzdXBwbGllZCBrZXlsZW5ndGggKG9yIHRoZVxuXHQgKiBkZWZhdWx0IGtleUxlbmd0aCBpZiBub25lIHN1cHBsaWVkKSBhcyBhIENyeXB0b0pTIFdvcmRBcnJheVxuXHQgKiBAcGFyYW0ga2V5TGVuZ3RoIChvcHRpb25hbCkgdGhlIHJlcXVpcmVkIGtleUxlbmd0aCBpbiBiaXRzXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCBrZXkpXG5cdCAqL1xuXHRDcnlwdG8uZ2VuZXJhdGVSYW5kb21LZXkgPSBmdW5jdGlvbihrZXlMZW5ndGgsIGNhbGxiYWNrKSB7XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIHR5cGVvZihrZXlMZW5ndGgpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNhbGxiYWNrID0ga2V5TGVuZ3RoO1xuXHRcdFx0a2V5TGVuZ3RoID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRnZW5lcmF0ZVJhbmRvbSgoa2V5TGVuZ3RoIHx8IERFRkFVTFRfS0VZTEVOR1RIKSAvIDgsIGNhbGxiYWNrKTtcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWw7IGdldCBhIENoYW5uZWxDaXBoZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGdpdmVuIGNpcGhlclBhcmFtc1xuXHQgKiBAcGFyYW0gcGFyYW1zIGVpdGhlciBhIENpcGhlclBhcmFtcyBpbnN0YW5jZSBvciBzb21lIHN1YnNldCBvZiBpdHNcblx0ICogZmllbGRzIHRoYXQgaW5jbHVkZXMgYSBrZXlcblx0ICovXG5cdENyeXB0by5nZXRDaXBoZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHR2YXIgY2lwaGVyUGFyYW1zID0gKHBhcmFtcyBpbnN0YW5jZW9mIENpcGhlclBhcmFtcykgP1xuXHRcdCAgICAgICAgICAgICAgICAgICBwYXJhbXMgOlxuXHRcdCAgICAgICAgICAgICAgICAgICBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpO1xuXG5cdFx0cmV0dXJuIHtjaXBoZXJQYXJhbXM6IGNpcGhlclBhcmFtcywgY2lwaGVyOiBuZXcgQ0JDQ2lwaGVyKGNpcGhlclBhcmFtcywgREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUywgcGFyYW1zLml2KX07XG5cdH07XG5cblx0ZnVuY3Rpb24gQ0JDQ2lwaGVyKHBhcmFtcywgYmxvY2tMZW5ndGhXb3JkcywgaXYpIHtcblx0XHR0aGlzLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gKyAnLScgKyBTdHJpbmcocGFyYW1zLmtleUxlbmd0aCkgKyAnLScgKyBwYXJhbXMubW9kZTtcblx0XHR0aGlzLmNqc0FsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0udG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tXFxkKyQvLCAnJyk7XG5cdFx0dGhpcy5rZXkgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvV29yZEFycmF5KHBhcmFtcy5rZXkpO1xuXHRcdGlmKGl2KSB7XG5cdFx0XHR0aGlzLml2ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShpdikuY2xvbmUoKTtcblx0XHR9XG5cdFx0dGhpcy5ibG9ja0xlbmd0aFdvcmRzID0gYmxvY2tMZW5ndGhXb3Jkcztcblx0fVxuXG5cdENCQ0NpcGhlci5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCwgY2FsbGJhY2spIHtcblx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5lbmNyeXB0KCknLCAnJyk7XG5cdFx0cGxhaW50ZXh0ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShwbGFpbnRleHQpO1xuXHRcdHZhciBwbGFpbnRleHRMZW5ndGggPSBwbGFpbnRleHQuc2lnQnl0ZXMsXG5cdFx0XHRwYWRkZWRMZW5ndGggPSBnZXRQYWRkZWRMZW5ndGgocGxhaW50ZXh0TGVuZ3RoKSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0dmFyIHRoZW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuZ2V0SXYoZnVuY3Rpb24oZXJyLCBpdikge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGNpcGhlck91dCA9IHNlbGYuZW5jcnlwdENpcGhlci5wcm9jZXNzKHBsYWludGV4dC5jb25jYXQocGtjczVQYWRkaW5nW3BhZGRlZExlbmd0aCAtIHBsYWludGV4dExlbmd0aF0pKTtcblx0XHRcdFx0dmFyIGNpcGhlcnRleHQgPSBpdi5jb25jYXQoY2lwaGVyT3V0KTtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgY2lwaGVydGV4dCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLmVuY3J5cHRDaXBoZXIpIHtcblx0XHRcdGlmKHRoaXMuaXYpIHtcblx0XHRcdFx0dGhpcy5lbmNyeXB0Q2lwaGVyID0gY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdC5hLmFsZ29bdGhpcy5janNBbGdvcml0aG1dLmNyZWF0ZUVuY3J5cHRvcih0aGlzLmtleSwgeyBpdjogdGhpcy5pdiB9KTtcblx0XHRcdFx0dGhlbigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2VuZXJhdGVSYW5kb20oREVGQVVMVF9CTE9DS0xFTkdUSCwgZnVuY3Rpb24oZXJyLCBpdikge1xuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuZW5jcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3NlbGYuY2pzQWxnb3JpdGhtXS5jcmVhdGVFbmNyeXB0b3Ioc2VsZi5rZXksIHsgaXY6IGl2IH0pO1xuXHRcdFx0XHRcdHNlbGYuaXYgPSBpdjtcblx0XHRcdFx0XHR0aGVuKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGVuKCk7XG5cdFx0fVxuXHR9O1xuXG5cdENCQ0NpcGhlci5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGNpcGhlcnRleHQpIHtcblx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5kZWNyeXB0KCknLCAnJyk7XG5cdFx0Y2lwaGVydGV4dCA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9Xb3JkQXJyYXkoY2lwaGVydGV4dCk7XG5cdFx0dmFyIGJsb2NrTGVuZ3RoV29yZHMgPSB0aGlzLmJsb2NrTGVuZ3RoV29yZHMsXG5cdFx0XHRjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzLFxuXHRcdFx0aXYgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMCwgYmxvY2tMZW5ndGhXb3JkcykpLFxuXHRcdFx0Y2lwaGVydGV4dEJvZHkgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoYmxvY2tMZW5ndGhXb3JkcykpO1xuXG5cdFx0dmFyIGRlY3J5cHRDaXBoZXIgPSBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0LmEuYWxnb1t0aGlzLmNqc0FsZ29yaXRobV0uY3JlYXRlRGVjcnlwdG9yKHRoaXMua2V5LCB7IGl2OiBpdiB9KTtcblx0XHR2YXIgcGxhaW50ZXh0ID0gZGVjcnlwdENpcGhlci5wcm9jZXNzKGNpcGhlcnRleHRCb2R5KTtcblx0XHR2YXIgZXBpbG9ndWUgPSBkZWNyeXB0Q2lwaGVyLmZpbmFsaXplKCk7XG5cdFx0ZGVjcnlwdENpcGhlci5yZXNldCgpO1xuXHRcdGlmKGVwaWxvZ3VlICYmIGVwaWxvZ3VlLnNpZ0J5dGVzKSBwbGFpbnRleHQuY29uY2F0KGVwaWxvZ3VlKTtcblx0XHRyZXR1cm4gcGxhaW50ZXh0O1xuXHR9O1xuXG5cdENCQ0NpcGhlci5wcm90b3R5cGUuZ2V0SXYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGlmKHRoaXMuaXYpIHtcblx0XHRcdHZhciBpdiA9IHRoaXMuaXY7XG5cdFx0XHR0aGlzLml2ID0gbnVsbDtcblx0XHRcdGNhbGxiYWNrKG51bGwsIGl2KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBTaW5jZSB0aGUgaXYgZm9yIGEgbmV3IGJsb2NrIGlzIHRoZSBjaXBoZXJ0ZXh0IG9mIHRoZSBsYXN0LCB0aGlzXG5cdFx0KiBzZXRzIGEgbmV3IGl2ICg9IGFlcyhyYW5kb21CbG9jayBYT1IgbGFzdENpcGhlclRleHQpKSBhcyB3ZWxsIGFzXG5cdFx0KiByZXR1cm5pbmcgaXQgKi9cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0Z2VuZXJhdGVSYW5kb20oREVGQVVMVF9CTE9DS0xFTkdUSCwgZnVuY3Rpb24oZXJyLCByYW5kb21CbG9jaykge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IFxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgc2VsZi5lbmNyeXB0Q2lwaGVyLnByb2Nlc3MocmFuZG9tQmxvY2spKTtcblx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4gQ3J5cHRvO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDcnlwdG8pO1xuXG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cblxuXG5cblxuXG52YXIgVHJhbnNwb3J0ID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgYWN0aW9ucyA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BY3Rpb247XG5cdHZhciBjbG9zZU1lc3NhZ2UgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7YWN0aW9uOiBhY3Rpb25zLkNMT1NFfSk7XG5cdHZhciBkaXNjb25uZWN0TWVzc2FnZSA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuRElTQ09OTkVDVH0pO1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0Lypcblx0ICogRXZlbnRFbWl0dGVyLCBnZW5lcmF0ZXMgdGhlIGZvbGxvd2luZyBldmVudHM6XG5cdCAqXG5cdCAqIGV2ZW50IG5hbWUgICAgICAgZGF0YVxuXHQgKiBjbG9zZWQgICAgICAgICAgIGVycm9yXG5cdCAqIGZhaWxlZCAgICAgICAgICAgZXJyb3Jcblx0ICogZGlzcG9zZWRcblx0ICogY29ubmVjdGVkICAgICAgICBudWxsIGVycm9yLCBjb25uZWN0aW9uU2VyaWFsLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzXG5cdCAqIHN5bmMgICAgICAgICAgICAgY29ubmVjdGlvblNlcmlhbCwgY29ubmVjdGlvbklkXG5cdCAqIGV2ZW50ICAgICAgICAgICAgY2hhbm5lbCBtZXNzYWdlIG9iamVjdFxuXHQgKi9cblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHRfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcblx0XHRjb25uZWN0aW9uTWFuYWdlci5yZWdpc3RlclByb3Bvc2VkVHJhbnNwb3J0KHRoaXMpO1xuXHRcdHRoaXMuYXV0aCA9IGF1dGg7XG5cdFx0dGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cdFx0dGhpcy50aW1lb3V0cyA9IHBhcmFtcy5vcHRpb25zLnRpbWVvdXRzO1xuXHRcdHRoaXMuZm9ybWF0ID0gcGFyYW1zLmZvcm1hdDtcblx0XHR0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5pc0ZpbmlzaGVkID0gZmFsc2U7XG5cdFx0dGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuXHRcdHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcblx0XHR0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG5cdH1cblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhUcmFuc3BvcnQsIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHt9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRpZih0aGlzLmlzQ29ubmVjdGVkKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RDbG9zZSgpO1xuXHRcdH1cblx0XHR0aGlzLmZpbmlzaCgnY2xvc2VkJywgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jbG9zZWQpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKGVycikge1xuXHRcdC8qIFVzZWQgZm9yIG5ldHdvcmsvdHJhbnNwb3J0IGlzc3VlcyB0aGF0IG5lZWQgdG8gcmVzdWx0IGluIHRoZSB0cmFuc3BvcnRcblx0XHQgKiBiZWluZyBkaXNjb25uZWN0ZWQsIGJ1dCBzaG91bGQgbm90IGFmZmVjdCB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdGlmKHRoaXMuaXNDb25uZWN0ZWQpIHtcblx0XHRcdHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcblx0XHR9XG5cdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVyciB8fCBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRpc2Nvbm5lY3RlZCk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0LyogVXNlZCBmb3IgY2xpZW50LXNpZGUtZGV0ZWN0ZWQgZmF0YWwgY29ubmVjdGlvbiBpc3N1ZXMgKi9cblx0XHRpZih0aGlzLmlzQ29ubmVjdGVkKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XG5cdFx0fVxuXHRcdHRoaXMuZmluaXNoKCdmYWlsZWQnLCBlcnIgfHwgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mYWlsZWQpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oZXZlbnQsIGVycikge1xuXHRcdGlmKHRoaXMuaXNGaW5pc2hlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG5cdFx0dGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuXHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZXIpO1xuXHRcdHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcblx0XHR0aGlzLmVtaXQoZXZlbnQsIGVycik7XG5cdFx0dGhpcy5kaXNwb3NlKCk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vblByb3RvY29sTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHRpZiAoX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2hvdWxkTG9nKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTykpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBvbiAnICsgdGhpcy5zaG9ydE5hbWUgKyAnOiAnICsgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN0cmluZ2lmeShtZXNzYWdlKSArICc7IGNvbm5lY3Rpb25JZCA9ICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCk7XG5cdFx0fVxuXHRcdHRoaXMub25BY3Rpdml0eSgpO1xuXG5cdFx0c3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XG5cdFx0Y2FzZSBhY3Rpb25zLkhFQVJUQkVBVDpcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsIHRoaXMuc2hvcnROYW1lICsgJyBoZWFydGJlYXQ7IGNvbm5lY3Rpb25JZCA9ICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCk7XG5cdFx0XHR0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcsIG1lc3NhZ2UuaWQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkNPTk5FQ1RFRDpcblx0XHRcdHRoaXMub25Db25uZWN0KG1lc3NhZ2UpO1xuXHRcdFx0dGhpcy5lbWl0KCdjb25uZWN0ZWQnLCBtZXNzYWdlLmVycm9yLCBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscywgbWVzc2FnZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuQ0xPU0VEOlxuXHRcdFx0dGhpcy5vbkNsb3NlKG1lc3NhZ2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkRJU0NPTk5FQ1RFRDpcblx0XHRcdHRoaXMub25EaXNjb25uZWN0KG1lc3NhZ2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkFDSzpcblx0XHRcdHRoaXMuZW1pdCgnYWNrJywgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLk5BQ0s6XG5cdFx0XHR0aGlzLmVtaXQoJ25hY2snLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5lcnJvcik7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuU1lOQzpcblx0XHRcdGlmKG1lc3NhZ2UuY29ubmVjdGlvbklkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0LyogYSB0cmFuc3BvcnQgU1lOQyAqL1xuXHRcdFx0XHR0aGlzLmVtaXQoJ3N5bmMnLCBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgbWVzc2FnZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Lyogb3RoZXJ3aXNlIGl0J3MgYSBjaGFubmVsIFNZTkMsIHNvIGhhbmRsZSBpdCBpbiB0aGUgY2hhbm5lbCAqL1xuXHRcdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkFVVEg6XG5cdFx0XHR0aGlzLmF1dGguYXV0aG9yaXplKGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCAnQWJseSByZXF1ZXN0ZWQgcmUtYXV0aGVudGljYXRpb24sIGJ1dCB1bmFibGUgdG8gb2J0YWluIGEgbmV3IHRva2VuOiAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkVSUk9SOlxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ3JlY2VpdmVkIGVycm9yIGFjdGlvbjsgY29ubmVjdGlvbklkID0gJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkICsgJzsgZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdChtZXNzYWdlLmVycm9yKSArIChtZXNzYWdlLmNoYW5uZWwgPyAoJywgY2hhbm5lbDogJyArICBtZXNzYWdlLmNoYW5uZWwpIDogJycpKTtcblx0XHRcdGlmKG1lc3NhZ2UuY2hhbm5lbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMub25GYXRhbEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdC8qIG90aGVyd2lzZSBpdCdzIGEgY2hhbm5lbC1zcGVjaWZpYyBlcnJvciwgc28gaGFuZGxlIGl0IGluIHRoZSBjaGFubmVsICovXG5cdFx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0LyogYWxsIG90aGVyIGFjdGlvbnMgYXJlIGNoYW5uZWwtc3BlY2lmaWMgKi9cblx0XHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcblx0XHR9XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG5cdFx0dmFyIG1heFByb21pc2VkSWRsZSA9IG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuXHRcdGlmKG1heFByb21pc2VkSWRsZSkge1xuXHRcdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBtYXhQcm9taXNlZElkbGUgKyB0aGlzLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG5cdFx0XHR0aGlzLm9uQWN0aXZpdHkoKTtcblx0XHR9XG5cdFx0LyogZWxzZSBSZWFsdGltZSBkZWNsaW5lcyB0byBndWFyYW50ZWUgYW55IG1heGltdW0gaWRsZSBpbnRlcnZhbCAtIENEMmggKi9cblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uRGlzY29ubmVjdCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHQvKiBVc2VkIGZvciB3aGVuIHRoZSBzZXJ2ZXIgaGFzIGRpc2Nvbm5lY3RlZCB0aGUgY2xpZW50ICh1c3VhbGx5IHdpdGggYVxuXHRcdCAqIERJU0NPTk5FQ1RFRCBhY3Rpb24pICovXG5cdFx0dmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uRGlzY29ubmVjdCgpJywgJ2VyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uRmF0YWxFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHQvKiBPbiByZWNlaXB0IG9mIGEgZmF0YWwgY29ubmVjdGlvbiBlcnJvciwgd2UgY2FuIGFzc3VtZSB0aGF0IHRoZSBzZXJ2ZXJcblx0XHQgKiB3aWxsIGNsb3NlIHRoZSBjb25uZWN0aW9uIGFuZCB0aGUgdHJhbnNwb3J0LCBhbmQgZG8gbm90IG5lZWQgdG8gcmVxdWVzdFxuXHRcdCAqIGEgZGlzY29ubmVjdGlvbiAtIFJUTjE1aSAqL1xuXHRcdHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vbkZhdGFsRXJyb3IoKScsICdlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0dGhpcy5maW5pc2goJ2ZhaWxlZCcsIGVycik7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vbkNsb3NlKCknLCAnZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdHRoaXMuZmluaXNoKCdjbG9zZWQnLCBlcnIpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdENsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKScsICcnKTtcblx0XHR0aGlzLnNlbmQoY2xvc2VNZXNzYWdlKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3REaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpJywgJycpO1xuXHRcdHRoaXMuc2VuZChkaXNjb25uZWN0TWVzc2FnZSk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24oaWQpIHtcblx0XHR2YXIgbXNnID0ge2FjdGlvbjogX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbi5IRUFSVEJFQVR9O1xuXHRcdGlmKGlkKSBtc2cuaWQgPSBpZDtcblx0XHR0aGlzLnNlbmQoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMobXNnKSk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG5cdFx0dGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcblx0XHR0aGlzLm9mZigpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25BY3Rpdml0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKCF0aGlzLm1heElkbGVJbnRlcnZhbCkgeyByZXR1cm47IH1cblx0XHR0aGlzLmxhc3RBY3Rpdml0eSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIubGFzdEFjdGl2aXR5ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKTtcblx0XHR0aGlzLnNldElkbGVUaW1lcih0aGlzLm1heElkbGVJbnRlcnZhbCArIDEwMCk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5zZXRJZGxlVGltZXIgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKCF0aGlzLmlkbGVUaW1lcikge1xuXHRcdFx0dGhpcy5pZGxlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLm9uSWRsZVRpbWVyRXhwaXJlKCk7XG5cdFx0XHR9LCB0aW1lb3V0KTtcblx0XHR9XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbklkbGVUaW1lckV4cGlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcblx0XHR2YXIgc2luY2VMYXN0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSAtIHRoaXMubGFzdEFjdGl2aXR5LFxuXHRcdFx0dGltZVJlbWFpbmluZyA9IHRoaXMubWF4SWRsZUludGVydmFsIC0gc2luY2VMYXN0O1xuXHRcdGlmKHRpbWVSZW1haW5pbmcgPD0gMCkge1xuXHRcdFx0dmFyIG1zZyA9ICdObyBhY3Rpdml0eSBzZWVuIGZyb20gcmVhbHRpbWUgaW4gJyArIHNpbmNlTGFzdCArICdtczsgYXNzdW1pbmcgY29ubmVjdGlvbiBoYXMgZHJvcHBlZCc7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKCknLCBtc2cpO1xuXHRcdFx0dGhpcy5kaXNjb25uZWN0KG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA4MDAwMywgNDA4KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0SWRsZVRpbWVyKHRpbWVSZW1haW5pbmcgKyAxMDApO1xuXHRcdH1cblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbigpIHt9O1xuXG5cdHJldHVybiBUcmFuc3BvcnQ7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFRyYW5zcG9ydCk7XG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSAoZnVuY3Rpb24oKSB7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENvbm5lY3Rpb25TdGF0ZUNoYW5nZShwcmV2aW91cywgY3VycmVudCwgcmV0cnlJbiwgcmVhc29uKSB7XG5cdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG5cdFx0aWYocmV0cnlJbikgdGhpcy5yZXRyeUluID0gcmV0cnlJbjtcblx0XHRpZihyZWFzb24pIHRoaXMucmVhc29uID0gcmVhc29uO1xuXHR9XG5cblx0cmV0dXJuIENvbm5lY3Rpb25TdGF0ZUNoYW5nZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29ubmVjdGlvblN0YXRlQ2hhbmdlKTtcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxudmFyIE11bHRpY2FzdGVyID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIE11bHRpY2FzdGVyKG1lbWJlcnMpIHtcblx0XHRtZW1iZXJzID0gbWVtYmVycyB8fCBbXTtcblxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWVtYmVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgbWVtYmVyID0gbWVtYmVyc1tpXTtcblx0XHRcdFx0aWYobWVtYmVyKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdG1lbWJlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdH0gY2F0Y2goZSl7XG5cdFx0XHRcdFx0XHRfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdNdWx0aWNhc3RlciBtdWx0aXBsZSBjYWxsYmFjayBoYW5kbGVyJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uOiAnICsgZSArICc7IHN0YWNrID0gJyArIGUuc3RhY2spO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRoYW5kbGVyLnB1c2ggPSBmdW5jdGlvbigpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG1lbWJlcnMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRyZXR1cm4gaGFuZGxlcjtcblx0fVxuXG5cdHJldHVybiBNdWx0aWNhc3Rlcjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTXVsdGljYXN0ZXIpO1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXG5cblxuXG5cbnZhciBFcnJvclJlcG9ydGVyID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBFcnJvclJlcG9ydGVyKCkge31cblxuXHR2YXIgbGV2ZWxzID0gRXJyb3JSZXBvcnRlci5sZXZlbHMgPSBbXG5cdFx0J2ZhdGFsJyxcblx0XHQnZXJyb3InLFxuXHRcdCd3YXJuaW5nJyxcblx0XHQnaW5mbycsXG5cdFx0J2RlYnVnJ1xuXHRdO1xuXG5cdC8qIChsZXZlbDogdHlwZW9mIEVycm9yUmVwb3J0ZXIubGV2ZWxzW251bWJlcl0sIG1lc3NhZ2U6IHN0cmluZywgZmluZ2VycHJpbnQ/OiBzdHJpbmcsIHRhZ3M/OiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSk6IHZvaWQgKi9cblx0RXJyb3JSZXBvcnRlci5yZXBvcnQgPSBmdW5jdGlvbihsZXZlbCwgbWVzc2FnZSwgZmluZ2VycHJpbnQsIHRhZ3MpIHtcblx0XHR2YXIgZXZlbnRJZCA9IF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJhbmRvbUhleFN0cmluZygxNik7XG5cblx0XHR2YXIgZXZlbnQgPSB7XG5cdFx0XHRldmVudF9pZDogZXZlbnRJZCxcblx0XHRcdHRhZ3M6IF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKHtcblx0XHRcdFx0bGliOiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxpYnZlclxuXHRcdFx0fSwgdGFncyksXG5cdFx0XHRwbGF0Zm9ybTogJ2phdmFzY3JpcHQnLFxuXHRcdFx0bGV2ZWw6IGxldmVsLFxuXHRcdFx0cmVsZWFzZTogX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS52ZXJzaW9uLFxuXHRcdFx0ZmluZ2VycHJpbnQ6IGZpbmdlcnByaW50ICYmIFsgZmluZ2VycHJpbnQgXSxcblx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdFx0XHRyZXF1ZXN0OiB7XG5cdFx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0XHQnVXNlci1BZ2VudCc6IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXNlckFnZW50XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVybDogcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jdXJyZW50VXJsXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Vycm9yUmVwb3J0ZXInLCAnUE9TVGluZyB0byBlcnJvciByZXBvcnRlcjogJyArIG1lc3NhZ2UpO1xuXHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5wb3N0VXJpKG51bGwsIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXJyb3JSZXBvcnRpbmdVcmwsIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZXJyb3JSZXBvcnRpbmdIZWFkZXJzLCBKU09OLnN0cmluZ2lmeShldmVudCksIHt9LCBmdW5jdGlvbihlcnIsIHJlcykge1xuXHRcdFx0X2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnRXJyb3JSZXBvcnRlcicsICdQT1NUaW5nIHRvIGVycm9yIHJlcG9ydGVyIHJlc3VsdGVkIGluOiAnICtcblx0XHRcdFx0KGVyciA/IF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpIDogX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEJvZHkocmVzKSlcblx0XHRcdCk7XG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIEVycm9yUmVwb3J0ZXI7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEVycm9yUmVwb3J0ZXIpO1xuXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbXNncGFjayA9IChmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGV4cG9ydHMgPSB7fTtcblxuXHRleHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXHRmdW5jdGlvbiBpbnNwZWN0KGJ1ZmZlcikge1xuXHRcdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBcInVuZGVmaW5lZFwiO1xuXHRcdHZhciB2aWV3O1xuXHRcdHZhciB0eXBlO1xuXHRcdGlmICggYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRcdHR5cGUgPSBcIkFycmF5QnVmZmVyXCI7XG5cdFx0XHR2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cdFx0fSBlbHNlIGlmICggYnVmZmVyIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcblx0XHRcdHR5cGUgPSBcIkRhdGFWaWV3XCI7XG5cdFx0XHR2aWV3ID0gYnVmZmVyO1xuXHRcdH1cblx0XHRpZiAoIXZpZXcpXG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYnVmZmVyKTtcblx0XHR2YXIgYnl0ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChpID4gMjApIHtcblx0XHRcdFx0Ynl0ZXMucHVzaChcIi4uLlwiKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYnl0ZV8gPSB2aWV3LmdldFVpbnQ4KGkpLnRvU3RyaW5nKDE2KTtcblx0XHRcdGlmIChieXRlXy5sZW5ndGggPT09IDEpXG5cdFx0XHRcdGJ5dGVfID0gXCIwXCIgKyBieXRlXztcblx0XHRcdGJ5dGVzLnB1c2goYnl0ZV8pO1xuXHRcdH1cblx0XHRyZXR1cm4gXCI8XCIgKyB0eXBlICsgXCIgXCIgKyBieXRlcy5qb2luKFwiIFwiKSArIFwiPlwiO1xuXHR9XG5cblx0Ly8gRW5jb2RlIHN0cmluZyBhcyB1dGY4IGludG8gZGF0YXZpZXcgYXQgb2Zmc2V0XG5cdGV4cG9ydHMudXRmOFdyaXRlID0gdXRmOFdyaXRlO1xuXHRmdW5jdGlvbiB1dGY4V3JpdGUodmlldywgb2Zmc2V0LCBzdHJpbmcpIHtcblx0XHR2YXIgYnl0ZUxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuXHRcdFx0Ly8gT25lIGJ5dGUgb2YgVVRGLThcblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4N2YgfCAweDAwKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR3byBieXRlcyBvZiBVVEYtOFxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gNiAmIDB4MWYgfCAweGMwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAwICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhyZWUgYnl0ZXMgb2YgVVRGLTguXG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDEyICYgMHgwZiB8IDB4ZTApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDYgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvdXIgYnl0ZXMgb2YgVVRGLThcblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDE4ICYgMHgwNyB8IDB4ZjApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDEyICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDYgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY29kZXBvaW50IFwiICsgY29kZVBvaW50KTtcblx0XHR9XG5cdH1cblxuXG5cdGV4cG9ydHMudXRmOFJlYWQgPSB1dGY4UmVhZDtcblx0ZnVuY3Rpb24gdXRmOFJlYWQodmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcblx0XHR2YXIgc3RyaW5nID0gXCJcIjtcblx0XHRmb3IgKHZhciBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBsZW5ndGg7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0dmFyIGJ5dGVfID0gdmlldy5nZXRVaW50OChpKTtcblx0XHRcdC8vIE9uZSBieXRlIGNoYXJhY3RlclxuXHRcdFx0aWYgKChieXRlXyAmIDB4ODApID09PSAweDAwKSB7XG5cdFx0XHRcdHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVfKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBUd28gYnl0ZSBjaGFyYWN0ZXJcblx0XHRcdGlmICgoYnl0ZV8gJiAweGUwKSA9PT0gMHhjMCkge1xuXHRcdFx0XHRzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGVfICYgMHgwZikgPDwgNikgfCAodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdC8vIFRocmVlIGJ5dGUgY2hhcmFjdGVyXG5cdFx0XHRpZiAoKGJ5dGVfICYgMHhmMCkgPT09IDB4ZTApIHtcblx0XHRcdFx0c3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MGYpIDw8IDEyKSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgNikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDApKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBGb3VyIGJ5dGUgY2hhcmFjdGVyXG5cdFx0XHRpZiAoKGJ5dGVfICYgMHhmOCkgPT09IDB4ZjApIHtcblx0XHRcdFx0c3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MDcpIDw8IDE4KSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMTIpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCkpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZSBcIiArIGJ5dGVfLnRvU3RyaW5nKDE2KSk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHJpbmc7XG5cdH1cblxuXG5cdGV4cG9ydHMudXRmOEJ5dGVDb3VudCA9IHV0ZjhCeXRlQ291bnQ7XG5cdGZ1bmN0aW9uIHV0ZjhCeXRlQ291bnQoc3RyaW5nKSB7XG5cdFx0dmFyIGNvdW50ID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG5cdFx0XHRcdGNvdW50ICs9IDE7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG5cdFx0XHRcdGNvdW50ICs9IDI7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcblx0XHRcdFx0Y291bnQgKz0gMztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcblx0XHRcdFx0Y291bnQgKz0gNDtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY29kZXBvaW50IFwiICsgY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9XG5cblxuXHRleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBzcGFyc2UpIHtcblx0XHR2YXIgc2l6ZSA9IHNpemVvZih2YWx1ZSwgc3BhcnNlKTtcblx0XHRpZihzaXplID09IDApXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XG5cdFx0dmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblx0XHRlbmNvZGUodmFsdWUsIHZpZXcsIDAsIHNwYXJzZSk7XG5cdFx0cmV0dXJuIGJ1ZmZlcjtcblx0fTtcblxuXHRleHBvcnRzLmRlY29kZSA9IGRlY29kZTtcblxuXHR2YXIgU0hfTF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KSwgU0hfUl8zMiA9IDEgLyBTSF9MXzMyO1xuXHRmdW5jdGlvbiBnZXRJbnQ2NCh2aWV3LCBvZmZzZXQpIHtcblx0XHRvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHRyZXR1cm4gdmlldy5nZXRJbnQzMihvZmZzZXQpICogU0hfTF8zMiArIHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VWludDY0KHZpZXcsIG9mZnNldCkge1xuXHRcdG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRcdHJldHVybiB2aWV3LmdldFVpbnQzMihvZmZzZXQpICogU0hfTF8zMiArIHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0SW50NjQodmlldywgb2Zmc2V0LCB2YWwpIHtcblx0XHRpZiAodmFsIDwgMHg4MDAwMDAwMDAwMDAwMDAwKSB7XG5cdFx0XHR2aWV3LnNldEludDMyKG9mZnNldCwgTWF0aC5mbG9vcih2YWwgKiBTSF9SXzMyKSk7XG5cdFx0XHR2aWV3LnNldEludDMyKG9mZnNldCArIDQsIHZhbCAmIC0xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0LCAweDdmZmZmZmZmKTtcblx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIDB4N2ZmZmZmZmYpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQsIHZhbCkge1xuXHRcdGlmICh2YWwgPCAweDEwMDAwMDAwMDAwMDAwMDAwKSB7XG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQsIE1hdGguZmxvb3IodmFsICogU0hfUl8zMikpO1xuXHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQgKyA0LCB2YWwgJiAtMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCwgMHhmZmZmZmZmZik7XG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyA0LCAweGZmZmZmZmZmKTtcblx0XHR9XG5cdH1cblxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZnJzeXVraS81NDMyNTU5IC0gdjUgc3BlY1xuLy9cbi8vIEkndmUgdXNlZCBvbmUgZXh0ZW5zaW9uIHBvaW50IGZyb20gYGZpeGV4dCAxYCB0byBzdG9yZSBgdW5kZWZpbmVkYC4gT24gdGhlIHdpcmUgdGhpc1xuLy8gc2hvdWxkIHRyYW5zbGF0ZSB0byBleGFjdGx5IDB4ZDQwMDAwXG4vL1xuLy8gKy0tLS0tLS0tKy0tLS0tLS0tKy0tLS0tLS0tK1xuLy8gfCAgMHhkNCAgfCAgMHgwMCAgfCAgMHgwMCAgfFxuLy8gKy0tLS0tLS0tKy0tLS0tLS0tKy0tLS0tLS0tK1xuLy8gICAgXiBmaXhleHQgfCAgICAgICAgXiB2YWx1ZSBwYXJ0IHVudXNlZCAoZml4ZWQgdG8gYmUgMClcbi8vICAgICAgICAgICAgIF4gaW5kaWNhdGVzIHVuZGVmaW5lZCB2YWx1ZVxuLy9cblxuXHRmdW5jdGlvbiBEZWNvZGVyKHZpZXcsIG9mZnNldCkge1xuXHRcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0dGhpcy52aWV3ID0gdmlldztcblx0fVxuXG5cblx0RGVjb2Rlci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IHRoaXMucGFyc2UoKTtcblx0XHRcdHZhbHVlW2tleV0gPSB0aGlzLnBhcnNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHREZWNvZGVyLnByb3RvdHlwZS5iaW4gPSBEZWNvZGVyLnByb3RvdHlwZS5idWYgPSBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcblx0XHQobmV3IFVpbnQ4QXJyYXkodmFsdWUpKS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy52aWV3LmJ1ZmZlciwgdGhpcy5vZmZzZXQsIGxlbmd0aCksIDApO1xuXHRcdHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0RGVjb2Rlci5wcm90b3R5cGUuc3RyID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gdXRmOFJlYWQodGhpcy52aWV3LCB0aGlzLm9mZnNldCwgbGVuZ3RoKTtcblx0XHR0aGlzLm9mZnNldCArPSBsZW5ndGg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdERlY29kZXIucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVbaV0gPSB0aGlzLnBhcnNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHREZWNvZGVyLnByb3RvdHlwZS5leHQgPSBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSB7fTtcblx0XHQvLyBHZXQgdGhlIHR5cGUgYnl0ZVxuXHRcdHZhbHVlWyd0eXBlJ10gPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCk7XG5cdFx0dGhpcy5vZmZzZXQrKztcblx0XHQvLyBHZXQgdGhlIGRhdGEgYXJyYXkgKGxlbmd0aClcblx0XHR2YWx1ZVsnZGF0YSddID0gdGhpcy5idWYobGVuZ3RoKTtcblx0XHR0aGlzLm9mZnNldCArPSBsZW5ndGg7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdERlY29kZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR5cGUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQpO1xuXHRcdHZhciB2YWx1ZSwgbGVuZ3RoO1xuXG5cdFx0Ly8gUG9zaXRpdmUgRml4SW50IC0gMHh4eHh4eHhcblx0XHRpZiAoKHR5cGUgJiAweDgwKSA9PT0gMHgwMCkge1xuXHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdHJldHVybiB0eXBlO1xuXHRcdH1cblxuXHRcdC8vIEZpeE1hcCAtIDEwMDB4eHh4XG5cdFx0aWYgKCh0eXBlICYgMHhmMCkgPT09IDB4ODApIHtcblx0XHRcdGxlbmd0aCA9IHR5cGUgJiAweDBmO1xuXHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuXHRcdH1cblxuXHRcdC8vIEZpeEFycmF5IC0gMTAwMXh4eHhcblx0XHRpZiAoKHR5cGUgJiAweGYwKSA9PT0gMHg5MCkge1xuXHRcdFx0bGVuZ3RoID0gdHlwZSAmIDB4MGY7XG5cdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBGaXhTdHIgLSAxMDF4eHh4eFxuXHRcdGlmICgodHlwZSAmIDB4ZTApID09PSAweGEwKSB7XG5cdFx0XHRsZW5ndGggPSB0eXBlICYgMHgxZjtcblx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBOZWdhdGl2ZSBGaXhJbnQgLSAxMTF4eHh4eFxuXHRcdGlmICgodHlwZSAmIDB4ZTApID09PSAweGUwKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0KTtcblx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cblx0XHRcdC8vIG5pbFxuXHRcdFx0Y2FzZSAweGMwOlxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0Ly8gMHhjMSBuZXZlciB1c2VkIC0gdXNlIGZvciB1bmRlZmluZWQgKE5PTi1TVEFOREFSRClcblx0XHRcdGNhc2UgMHhjMTpcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gZmFsc2Vcblx0XHRcdGNhc2UgMHhjMjpcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyB0cnVlXG5cdFx0XHRjYXNlIDB4YzM6XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBiaW4gOFxuXHRcdFx0Y2FzZSAweGM0OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmluKGxlbmd0aCk7XG5cblx0XHRcdC8vIGJpbiAxNlxuXHRcdFx0Y2FzZSAweGM1OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuXG5cdFx0XHQvLyBiaW4gMzJcblx0XHRcdGNhc2UgMHhjNjpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcblxuXHRcdFx0Ly8gZXh0IDhcblx0XHRcdGNhc2UgMHhjNzpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBleHQgMTZcblx0XHRcdGNhc2UgMHhjODpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZXh0IDMyXG5cdFx0XHRjYXNlIDB4Yzk6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGZsb2F0IDMyXG5cdFx0XHRjYXNlIDB4Y2E6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldEZsb2F0MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBmbG9hdCA2NFxuXHRcdFx0Y2FzZSAweGNiOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gdWludDhcblx0XHRcdGNhc2UgMHhjYzpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyB1aW50IDE2XG5cdFx0XHRjYXNlIDB4Y2Q6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIHVpbnQgMzJcblx0XHRcdGNhc2UgMHhjZTpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gdWludCA2NFxuXHRcdFx0Y2FzZSAweGNmOlxuXHRcdFx0XHR2YWx1ZSA9IGdldFVpbnQ2NCh0aGlzLnZpZXcsIHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDk7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gaW50IDhcblx0XHRcdGNhc2UgMHhkMDpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50OCh0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGludCAxNlxuXHRcdFx0Y2FzZSAweGQxOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGludCAzMlxuXHRcdFx0Y2FzZSAweGQyOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGludCA2NFxuXHRcdFx0Y2FzZSAweGQzOlxuXHRcdFx0XHR2YWx1ZSA9IGdldEludDY0KHRoaXMudmlldywgdGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gOTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBmaXhleHQgMVxuXHRcdFx0Y2FzZSAweGQ0OlxuXHRcdFx0XHRsZW5ndGggPSAxO1xuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZml4ZXh0IDJcblx0XHRcdGNhc2UgMHhkNTpcblx0XHRcdFx0bGVuZ3RoID0gMjtcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGZpeGV4dCA0XG5cdFx0XHRjYXNlIDB4ZDY6XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBmaXhleHQgOFxuXHRcdFx0Y2FzZSAweGQ3OlxuXHRcdFx0XHRsZW5ndGggPSA4O1xuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZml4ZXh0IDE2XG5cdFx0XHRjYXNlIDB4ZDg6XG5cdFx0XHRcdGxlbmd0aCA9IDE2O1xuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gc3RyOFxuXHRcdFx0Y2FzZSAweGQ5OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG5cblx0XHRcdC8vIHN0ciAxNlxuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuXG5cdFx0XHQvLyBzdHIgMzJcblx0XHRcdGNhc2UgMHhkYjpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcblxuXHRcdFx0Ly8gYXJyYXkgMTZcblx0XHRcdGNhc2UgMHhkYzpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuXG5cdFx0XHQvLyBhcnJheSAzMlxuXHRcdFx0Y2FzZSAweGRkOlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG5cblx0XHRcdC8vIG1hcCAxNlxuXHRcdFx0Y2FzZSAweGRlOlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuXG5cdFx0XHQvLyBtYXAgMzJcblx0XHRcdGNhc2UgMHhkZjpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIDB4XCIgKyB0eXBlLnRvU3RyaW5nKDE2KSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlcikge1xuXHRcdHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cdFx0dmFyIGRlY29kZXIgPSBuZXcgRGVjb2Rlcih2aWV3KTtcblx0XHR2YXIgdmFsdWUgPSBkZWNvZGVyLnBhcnNlKCk7XG5cdFx0aWYgKGRlY29kZXIub2Zmc2V0ICE9PSBidWZmZXIuYnl0ZUxlbmd0aClcblx0XHRcdHRocm93IG5ldyBFcnJvcigoYnVmZmVyLmJ5dGVMZW5ndGggLSBkZWNvZGVyLm9mZnNldCkgKyBcIiB0cmFpbGluZyBieXRlc1wiKTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKSB7XG5cdFx0dmFyIGtleXMgPSBbXTsgLy8gVE9ETzogdXNlIE9iamVjdC5rZXlzIHdoZW4gd2UgYXJlIGFibGUgdG8gdHJhbnNwaWxlIHRvIEVTM1xuXHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0aWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcblx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdH1cblx0XHRyZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcblx0XHRcdHZhciB2YWwgPSB2YWx1ZVtlXSwgdHlwZSA9IHR5cGVvZih2YWwpO1xuXHRcdFx0cmV0dXJuICghc3BhcnNlIHx8ICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwpKSAmJiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZSB8fCAhIXZhbC50b0pTT04pO1xuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGUodmFsdWUsIHZpZXcsIG9mZnNldCwgc3BhcnNlKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHQvLyBTdHJpbmdzIEJ5dGVzXG5cdFx0Ly8gVGhlcmUgYXJlIGZvdXIgc3RyaW5nIHR5cGVzOiBmaXhzdHIvc3RyOC9zdHIxNi9zdHIzMlxuXHRcdGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG5cblx0XHRcdC8vIGZpeHN0clxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MjApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIGxlbmd0aCB8IDB4YTApO1xuXHRcdFx0XHR1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMSArIGxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc3RyOFxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQ5KTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHR1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMiwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMiArIGxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc3RyMTZcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGRhKTtcblx0XHRcdFx0dmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0dXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDMsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDMgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdHIzMlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGRiKTtcblx0XHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0dXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDUsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDUgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcblx0XHRcdC8vIGV4dHJhY3QgdGhlIGFycmF5YnVmZmVyIGFuZCBmYWxsdGhyb3VnaFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5idWZmZXI7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlcmUgYXJlIHRocmVlIGJpbiB0eXBlczogYmluOC9iaW4xNi9iaW4zMlxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUuYnl0ZUxlbmd0aDtcblxuXHRcdFx0Ly8gYmluOFxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM0KTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHQobmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyAyKTtcblx0XHRcdFx0cmV0dXJuIDIgKyBsZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJpbjE2XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNSk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdChuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDMpO1xuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzYpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHQobmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyA1KTtcblx0XHRcdFx0cmV0dXJuIDUgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcblxuXHRcdFx0Ly8gRmxvYXRpbmcgUG9pbnRcblx0XHRcdC8vIE5PVEU6IFdlJ3JlIGFsd2F5cyB1c2luZyBmbG9hdDY0XG5cdFx0XHRpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNiKTtcblx0XHRcdFx0dmlldy5zZXRGbG9hdDY0KG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEludGVnZXJzXG5cdFx0XHRpZiAodmFsdWUgPj0gMCkge1xuXHRcdFx0XHQvLyBwb3NpdGl2ZSBmaXhudW1cblx0XHRcdFx0aWYgKHZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdWludCA4XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2MpO1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHVpbnQgMTZcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNkKTtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdWludCAzMlxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNlKTtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdWludCA2NFxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwMDAwMDAwMDAwMDAwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2YpO1xuXHRcdFx0XHRcdHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWcgMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG5lZ2F0aXZlIGZpeG51bVxuXHRcdFx0aWYgKHZhbHVlID49IC0weDIwKSB7XG5cdFx0XHRcdHZpZXcuc2V0SW50OChvZmZzZXQsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnQgOFxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQwKTtcblx0XHRcdFx0dmlldy5zZXRJbnQ4KG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnQgMTZcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQxKTtcblx0XHRcdFx0dmlldy5zZXRJbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW50IDMyXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDIpO1xuXHRcdFx0XHR2aWV3LnNldEludDMyKG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDU7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnQgNjRcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQzKTtcblx0XHRcdFx0c2V0SW50NjQodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gc21hbGwgLTB4XCIgKyAoLXZhbHVlKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcblx0XHR9XG5cblx0XHQvLyB1bmRlZmluZWQgLSB1c2UgZDQgKE5PTi1TVEFOREFSRClcblx0XHRpZiAodHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0aWYoc3BhcnNlKSByZXR1cm4gMDtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQ0KTtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgMHgwMCk7XG5cdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCArIDIsIDB4MDApO1xuXHRcdFx0cmV0dXJuIDM7XG5cdFx0fVxuXG5cdFx0Ly8gbnVsbFxuXHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0aWYoc3BhcnNlKSByZXR1cm4gMDtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGMwKTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblxuXHRcdC8vIEJvb2xlYW5cblx0XHRpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCB2YWx1ZSA/IDB4YzMgOiAweGMyKTtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblxuXHRcdGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG5cdFx0XHRyZXR1cm4gZW5jb2RlKHZhbHVlLnRvSlNPTigpLCB2aWV3LCBvZmZzZXQsIHNwYXJzZSk7XG5cblx0XHQvLyBDb250YWluZXIgVHlwZXNcblx0XHRpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuXHRcdFx0dmFyIGxlbmd0aCwgc2l6ZSA9IDA7XG5cdFx0XHR2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXG5cdFx0XHRpZiAoaXNBcnJheSkge1xuXHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuXHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHNpemU7XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoIHwgKCBpc0FycmF5ID8gMHg5MCA6IDB4ODApKTtcblx0XHRcdFx0c2l6ZSA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIGlzQXJyYXkgPyAweGRjIDogMHhkZSk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdHNpemUgPSAzO1xuXHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDB4ZGQgOiAweGRmKTtcblx0XHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0c2l6ZSA9IDU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc0FycmF5KSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzaXplICs9IGVuY29kZSh2YWx1ZVtpXSwgdmlldywgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdHNpemUgKz0gZW5jb2RlKGtleSwgdmlldywgb2Zmc2V0ICsgc2l6ZSk7XG5cdFx0XHRcdFx0c2l6ZSArPSBlbmNvZGUodmFsdWVba2V5XSwgdmlldywgb2Zmc2V0ICsgc2l6ZSwgc3BhcnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2l6ZTtcblx0XHR9XG5cdFx0aWYodHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuXHRcdFx0cmV0dXJuIDA7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyB0eXBlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNpemVvZih2YWx1ZSwgc3BhcnNlKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHQvLyBmaXhzdHIgb3Igc3RyOCBvciBzdHIxNiBvciBzdHIzMlxuXHRcdGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgyMCkge1xuXHRcdFx0XHRyZXR1cm4gMSArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRyZXR1cm4gMiArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHJldHVybiAzICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHJldHVybiA1ICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG5cdFx0XHQvLyBleHRyYWN0IHRoZSBhcnJheWJ1ZmZlciBhbmQgZmFsbHRocm91Z2hcblx0XHRcdHZhbHVlID0gdmFsdWUuYnVmZmVyO1xuXHRcdH1cblxuXHRcdC8vIGJpbjggb3IgYmluMTYgb3IgYmluMzJcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0cmV0dXJuIDIgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHRyZXR1cm4gNSArIGxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuXHRcdFx0Ly8gRmxvYXRpbmcgUG9pbnQgKDMyIGJpdHMpXG5cdFx0XHQvLyBkb3VibGVcblx0XHRcdGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpXG5cdFx0XHRcdHJldHVybiA5O1xuXG5cdFx0XHQvLyBJbnRlZ2Vyc1xuXHRcdFx0aWYgKHZhbHVlID49IDApIHtcblx0XHRcdFx0Ly8gcG9zaXRpdmUgZml4aW50XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4ODApXG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdC8vIHVpbnQgOFxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMClcblx0XHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdFx0Ly8gdWludCAxNlxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwKVxuXHRcdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0XHQvLyB1aW50IDMyXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwKVxuXHRcdFx0XHRcdHJldHVybiA1O1xuXHRcdFx0XHQvLyB1aW50IDY0XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwMDAwMDAwMDApXG5cdFx0XHRcdFx0cmV0dXJuIDk7XG5cdFx0XHRcdC8vIFRvbyBiaWdcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWcgMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBuZWdhdGl2ZSBmaXhpbnRcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHgyMClcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHQvLyBpbnQgOFxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwKVxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdC8vIGludCAxNlxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwMDApXG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0Ly8gaW50IDMyXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApXG5cdFx0XHRcdHJldHVybiA1O1xuXHRcdFx0Ly8gaW50IDY0XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDAwMDAwMDAwMClcblx0XHRcdFx0cmV0dXJuIDk7XG5cdFx0XHQvLyBUb28gc21hbGxcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk51bWJlciB0b28gc21hbGwgLTB4XCIgKyB2YWx1ZS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcblx0XHR9XG5cblx0XHQvLyBCb29sZWFuXG5cdFx0aWYgKHR5cGUgPT09IFwiYm9vbGVhblwiKSByZXR1cm4gMTtcblxuXHRcdC8vIHVuZGVmaW5lZCwgbnVsbFxuXHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHNwYXJzZSA/IDAgOiAxO1xuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gc3BhcnNlID8gMCA6IDM7XG5cblx0XHRpZignZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUudG9KU09OKVxuXHRcdFx0cmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcblxuXHRcdC8vIENvbnRhaW5lciBUeXBlc1xuXHRcdGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHR2YXIgbGVuZ3RoLCBzaXplID0gMDtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRzaXplICs9IHNpemVvZih2YWx1ZVtpXSwgc3BhcnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKVxuXHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdHNpemUgKz0gc2l6ZW9mKGtleSkgKyBzaXplb2YodmFsdWVba2V5XSwgc3BhcnNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0cmV0dXJuIDEgKyBzaXplO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDMgKyBzaXplO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHJldHVybiA1ICsgc2l6ZTtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkFycmF5IG9yIG9iamVjdCB0b28gbG9uZyAweFwiICsgbGVuZ3RoLnRvU3RyaW5nKDE2KSk7XG5cdFx0fVxuXHRcdGlmKHR5cGUgPT09IFwiZnVuY3Rpb25cIilcblx0XHRcdHJldHVybiAwO1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIFwiICsgdHlwZSk7XG5cdH1cblxuXHRyZXR1cm4gZXhwb3J0cztcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAobXNncGFjayk7XG5cblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZXF1ZXVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbXVsdGljYXN0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9lcnJvcnJlcG9ydGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX3RyYW5zcG9ydHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfd2Vic29ja2V0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIENvbm5lY3Rpb25NYW5hZ2VyID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgaGF2ZVdlYlN0b3JhZ2UgPSAhISh0eXBlb2YocGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkgIT09ICd1bmRlZmluZWQnICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0KTtcblx0dmFyIGhhdmVTZXNzaW9uU3RvcmFnZSA9ICEhKHR5cGVvZihwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRTZXNzaW9uKTtcblx0dmFyIGFjdGlvbnMgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uO1xuXHR2YXIgUGVuZGluZ01lc3NhZ2UgPSBfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5QZW5kaW5nTWVzc2FnZTtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHR2YXIgdHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXI7XG5cdHZhciBvcHRpbWFsVHJhbnNwb3J0ID0gdHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyW3RyYW5zcG9ydFByZWZlcmVuY2VPcmRlci5sZW5ndGggLSAxXTtcblx0dmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gJ2FibHktdHJhbnNwb3J0LXByZWZlcmVuY2UnO1xuXG5cdHZhciBzZXNzaW9uUmVjb3ZlcnlOYW1lID0gJ2FibHktY29ubmVjdGlvbi1yZWNvdmVyeSc7XG5cdGZ1bmN0aW9uIGdldFNlc3Npb25SZWNvdmVyRGF0YSgpIHtcblx0XHRyZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0U2Vzc2lvbihzZXNzaW9uUmVjb3ZlcnlOYW1lKTtcblx0fVxuXHRmdW5jdGlvbiBzZXRTZXNzaW9uUmVjb3ZlckRhdGEodmFsdWUpIHtcblx0XHRyZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2V0U2Vzc2lvbihzZXNzaW9uUmVjb3ZlcnlOYW1lLCB2YWx1ZSk7XG5cdH1cblx0ZnVuY3Rpb24gY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XG5cdFx0cmV0dXJuIGhhdmVTZXNzaW9uU3RvcmFnZSAmJiBwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJlbW92ZVNlc3Npb24oc2Vzc2lvblJlY292ZXJ5TmFtZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBiZXR0ZXJUcmFuc3BvcnRUaGFuKGEsIGIpIHtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbmRleE9mKHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlciwgYS5zaG9ydE5hbWUpID5cblx0XHQgICBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluZGV4T2YodHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyLCBiLnNob3J0TmFtZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBUcmFuc3BvcnRQYXJhbXMob3B0aW9ucywgaG9zdCwgbW9kZSwgY29ubmVjdGlvbktleSkge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5ob3N0ID0gaG9zdDtcblx0XHR0aGlzLm1vZGUgPSBtb2RlO1xuXHRcdHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25LZXk7XG5cdFx0dGhpcy5mb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nO1xuXG5cdFx0dGhpcy5jb25uZWN0aW9uU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudGltZVNlcmlhbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdFRyYW5zcG9ydFBhcmFtcy5wcm90b3R5cGUuZ2V0Q29ubmVjdFBhcmFtcyA9IGZ1bmN0aW9uKGF1dGhQYXJhbXMpIHtcblx0XHR2YXIgcGFyYW1zID0gYXV0aFBhcmFtcyA/IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY29weShhdXRoUGFyYW1zKSA6IHt9O1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHN3aXRjaCh0aGlzLm1vZGUpIHtcblx0XHRcdGNhc2UgJ3VwZ3JhZGUnOlxuXHRcdFx0XHRwYXJhbXMudXBncmFkZSA9IHRoaXMuY29ubmVjdGlvbktleTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyZXN1bWUnOlxuXHRcdFx0XHRwYXJhbXMucmVzdW1lID0gdGhpcy5jb25uZWN0aW9uS2V5O1xuXHRcdFx0XHRpZih0aGlzLnRpbWVTZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHBhcmFtcy50aW1lU2VyaWFsID0gdGhpcy50aW1lU2VyaWFsO1xuXHRcdFx0XHR9IGVsc2UgaWYodGhpcy5jb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRwYXJhbXMuY29ubmVjdGlvblNlcmlhbCA9IHRoaXMuY29ubmVjdGlvblNlcmlhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3JlY292ZXInOlxuXHRcdFx0XHR2YXIgbWF0Y2ggPSBvcHRpb25zLnJlY292ZXIuc3BsaXQoJzonKTtcblx0XHRcdFx0aWYobWF0Y2gpIHtcblx0XHRcdFx0XHRwYXJhbXMucmVjb3ZlciA9IG1hdGNoWzBdO1xuXHRcdFx0XHRcdHZhciByZWNvdmVyU2VyaWFsID0gbWF0Y2hbMV07XG5cdFx0XHRcdFx0aWYoaXNOYU4ocmVjb3ZlclNlcmlhbCkpIHtcblx0XHRcdFx0XHRcdHBhcmFtcy50aW1lU2VyaWFsID0gcmVjb3ZlclNlcmlhbDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cGFyYW1zLmNvbm5lY3Rpb25TZXJpYWwgPSByZWNvdmVyU2VyaWFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0fVxuXHRcdGlmKG9wdGlvbnMuY2xpZW50SWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cGFyYW1zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnRJZDtcblx0XHR9XG5cdFx0aWYob3B0aW9ucy5lY2hvTWVzc2FnZXMgPT09IGZhbHNlKSB7XG5cdFx0XHRwYXJhbXMuZWNobyA9ICdmYWxzZSc7XG5cdFx0fVxuXHRcdGlmKHRoaXMuZm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHBhcmFtcy5mb3JtYXQgPSB0aGlzLmZvcm1hdDtcblx0XHR9XG5cdFx0aWYodGhpcy5zdHJlYW0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cGFyYW1zLnN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuXHRcdH1cblx0XHRpZih0aGlzLmhlYXJ0YmVhdHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cGFyYW1zLmhlYXJ0YmVhdHMgPSB0aGlzLmhlYXJ0YmVhdHM7XG5cdFx0fVxuXHRcdHBhcmFtcy52ID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcGlWZXJzaW9uO1xuXHRcdHBhcmFtcy5saWIgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxpYnN0cmluZztcblx0XHRpZihvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKHBhcmFtcywgb3B0aW9ucy50cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyYW1zO1xuXHR9O1xuXG5cdFRyYW5zcG9ydFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1ttb2RlPScgKyB0aGlzLm1vZGU7XG5cdFx0aWYodGhpcy5ob3N0KSB7IHJlc3VsdCArPSAoJyxob3N0PScgKyB0aGlzLmhvc3QpOyB9XG5cdFx0aWYodGhpcy5jb25uZWN0aW9uS2V5KSB7IHJlc3VsdCArPSAoJyxjb25uZWN0aW9uS2V5PScgKyB0aGlzLmNvbm5lY3Rpb25LZXkpOyB9XG5cdFx0aWYodGhpcy5jb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHsgcmVzdWx0ICs9ICgnLGNvbm5lY3Rpb25TZXJpYWw9JyArIHRoaXMuY29ubmVjdGlvblNlcmlhbCk7IH1cblx0XHRpZih0aGlzLnRpbWVTZXJpYWwpIHsgcmVzdWx0ICs9ICgnLHRpbWVTZXJpYWw9JyArIHRoaXMudGltZVNlcmlhbCk7IH1cblx0XHRpZih0aGlzLmZvcm1hdCkgeyByZXN1bHQgKz0gKCcsZm9ybWF0PScgKyB0aGlzLmZvcm1hdCk7IH1cblx0XHRyZXN1bHQgKz0gJ10nO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ29ubmVjdGlvbk1hbmFnZXIocmVhbHRpbWUsIG9wdGlvbnMpIHtcblx0XHRfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHZhciB0aW1lb3V0cyA9IG9wdGlvbnMudGltZW91dHM7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdC8qIGNvbm5lY3RpbmdUaW1lb3V0OiBsZWF2ZSBwcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKH42cykgdG8gdHJ5IHRoZVxuXHRcdCAqIHByZWZlcmVuY2UgdHJhbnNwb3J0LCB0aGVuIHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQgKH4xMHMpIHRvIGVzdGFibGlzaFxuXHRcdCAqIHRoZSBiYXNlIHRyYW5zcG9ydCBpbiBjYXNlIHRoYXQgZmFpbHMgKi9cblx0XHR2YXIgY29ubmVjdGluZ1RpbWVvdXQgPSB0aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKyB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuXHRcdHRoaXMuc3RhdGVzID0ge1xuXHRcdFx0aW5pdGlhbGl6ZWQ6ICAge3N0YXRlOiAnaW5pdGlhbGl6ZWQnLCAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IHRydWUsICBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJ30sXG5cdFx0XHRjb25uZWN0aW5nOiAgICB7c3RhdGU6ICdjb25uZWN0aW5nJywgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogdHJ1ZSwgIHNlbmRFdmVudHM6IGZhbHNlLCByZXRyeURlbGF5OiBjb25uZWN0aW5nVGltZW91dCwgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJ30sXG5cdFx0XHRjb25uZWN0ZWQ6ICAgICB7c3RhdGU6ICdjb25uZWN0ZWQnLCAgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IHRydWUsICBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcblx0XHRcdHN5bmNocm9uaXppbmc6IHtzdGF0ZTogJ2Nvbm5lY3RlZCcsICAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiB0cnVlLCAgc2VuZEV2ZW50czogZmFsc2UsIGZvcmNlUXVldWVFdmVudHM6IHRydWUsIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxuXHRcdFx0ZGlzY29ubmVjdGVkOiAge3N0YXRlOiAnZGlzY29ubmVjdGVkJywgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IHRydWUsICBzZW5kRXZlbnRzOiBmYWxzZSwgcmV0cnlEZWxheTogdGltZW91dHMuZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0LCBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcblx0XHRcdHN1c3BlbmRlZDogICAgIHtzdGF0ZTogJ3N1c3BlbmRlZCcsICAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnN1c3BlbmRlZFJldHJ5VGltZW91dCwgZmFpbFN0YXRlOiAnc3VzcGVuZGVkJ30sXG5cdFx0XHRjbG9zaW5nOiAgICAgICB7c3RhdGU6ICdjbG9zaW5nJywgICAgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCByZXRyeURlbGF5OiB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LCBmYWlsU3RhdGU6ICdjbG9zZWQnfSxcblx0XHRcdGNsb3NlZDogICAgICAgIHtzdGF0ZTogJ2Nsb3NlZCcsICAgICAgICB0ZXJtaW5hbDogdHJ1ZSwgIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogJ2Nsb3NlZCd9LFxuXHRcdFx0ZmFpbGVkOiAgICAgICAge3N0YXRlOiAnZmFpbGVkJywgICAgICAgIHRlcm1pbmFsOiB0cnVlLCAgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiAnZmFpbGVkJ31cblx0XHR9O1xuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5pbml0aWFsaXplZDtcblx0XHR0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcblxuXHRcdHRoaXMucXVldWVkTWVzc2FnZXMgPSBuZXcgX21lc3NhZ2VxdWV1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCk7XG5cdFx0dGhpcy5tc2dTZXJpYWwgPSAwO1xuXHRcdHRoaXMuY29ubmVjdGlvbkRldGFpbHMgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudGltZVNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSB0aW1lb3V0cy5jb25uZWN0aW9uU3RhdGVUdGw7XG5cdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuXG5cdFx0dGhpcy50cmFuc3BvcnRzID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnRlcnNlY3QoKG9wdGlvbnMudHJhbnNwb3J0cyB8fCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlZmF1bHRUcmFuc3BvcnRzKSwgQ29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0cyk7XG5cdFx0LyogYmFzZVRyYW5zcG9ydHMgc2VsZWN0cyB0aGUgbGVmdG1vc3QgdHJhbnNwb3J0IGluIHRoZSBEZWZhdWx0cy5iYXNlVHJhbnNwb3J0T3JkZXIgbGlzdFxuXHRcdCogdGhhdCdzIGJvdGggcmVxdWVzdGVkIGFuZCBzdXBwb3J0ZWQuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB4aHJfcG9sbGluZztcblx0XHQqIGlmIHhociBpc24ndCBzdXBwb3J0ZWQgaXQgd2lsbCBiZSBqc29ucC4gSWYgdGhlIHVzZXIgaGFzIGZvcmNlZCBhXG5cdFx0KiB0cmFuc3BvcnQsIGl0J2xsIGp1c3QgYmUgdGhhdCBvbmUuICovXG5cdFx0dGhpcy5iYXNlVHJhbnNwb3J0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnRlcnNlY3QoX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlVHJhbnNwb3J0T3JkZXIsIHRoaXMudHJhbnNwb3J0cylbMF07XG5cdFx0dGhpcy51cGdyYWRlVHJhbnNwb3J0cyA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW50ZXJzZWN0KHRoaXMudHJhbnNwb3J0cywgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51cGdyYWRlVHJhbnNwb3J0cyk7XG5cdFx0dGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcblxuXHRcdHRoaXMuaHR0cEhvc3RzID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRIb3N0cyhvcHRpb25zKTtcblx0XHR0aGlzLmFjdGl2ZVByb3RvY29sID0gbnVsbDtcblx0XHR0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cyA9IFtdO1xuXHRcdHRoaXMucGVuZGluZ1RyYW5zcG9ydHMgPSBbXTtcblx0XHR0aGlzLmhvc3QgPSBudWxsO1xuXHRcdHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcblx0XHR0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG5cdFx0dGhpcy5tb3N0UmVjZW50TXNnID0gbnVsbDtcblx0XHR0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gZmFsc2U7XG5cdFx0dGhpcy5jb25uZWN0Q291bnRlciA9IDA7XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdzdGFydGVkJyk7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAncmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbJyArIChvcHRpb25zLnRyYW5zcG9ydHMgfHwgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWZhdWx0VHJhbnNwb3J0cykgKyAnXScpO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2F2YWlsYWJsZSB0cmFuc3BvcnRzID0gWycgKyB0aGlzLnRyYW5zcG9ydHMgKyAnXScpO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2h0dHAgaG9zdHMgPSBbJyArIHRoaXMuaHR0cEhvc3RzICsgJ10nKTtcblxuXHRcdGlmKCF0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgbXNnID0gJ25vIHJlcXVlc3RlZCB0cmFuc3BvcnRzIGF2YWlsYWJsZSc7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAncmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsIG1zZyk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0XHR9XG5cblx0XHR2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWRkRXZlbnRMaXN0ZW5lcjtcblx0XHRpZihhZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHQvKiBpbnRlcmNlcHQgY2xvc2UgZXZlbnQgaW4gYnJvd3NlciB0byBwZXJzaXN0IGNvbm5lY3Rpb24gaWQgaWYgcmVxdWVzdGVkICovXG5cdFx0XHRpZihoYXZlU2Vzc2lvblN0b3JhZ2UgJiYgdHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHQvKiBVc3VhbGx5IGNhbid0IHVzZSBiaW5kIGFzIG5vdCBzdXBwb3J0ZWQgaW4gSUU4LCBidXQgSUUgZG9lc24ndCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlLCBzby4uLiAqL1xuXHRcdFx0XHRhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLnBlcnNpc3RDb25uZWN0aW9uLmJpbmQodGhpcykpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcblx0XHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NQUpPUiwgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnYmVmb3JldW5sb2FkIGV2ZW50IGhhcyB0cmlnZ2VyZWQgdGhlIGNvbm5lY3Rpb24gdG8gY2xvc2UgYXMgY2xvc2VPblVubG9hZCBpcyB0cnVlJyk7XG5cdFx0XHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY2xvc2luZyd9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIExpc3RlbiBmb3Igb25saW5lIGFuZCBvZmZsaW5lIGV2ZW50cyAqL1xuXHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT0gc2VsZi5zdGF0ZXMuZGlzY29ubmVjdGVkIHx8IHNlbGYuc3RhdGUgPT0gc2VsZi5zdGF0ZXMuc3VzcGVuZGVkKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIGNhdWdodCBicm93c2VyIOKAmG9ubGluZeKAmSBldmVudCcsICdyZWF0dGVtcHRpbmcgY29ubmVjdGlvbicpO1xuXHRcdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihzZWxmLnN0YXRlID09IHNlbGYuc3RhdGVzLmNvbm5lY3RlZCkge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciDigJhvZmZsaW5l4oCZIGV2ZW50JywgJ2Rpc2Nvbm5lY3RpbmcgYWN0aXZlIHRyYW5zcG9ydCcpO1xuXHRcdFx0XHRcdC8vIE5vdCBzdWZmaWNpZW50IHRvIGp1c3QgZ28gdG8gdGhlICdkaXNjb25uZWN0ZWQnIHN0YXRlLCB3YW50IHRvXG5cdFx0XHRcdFx0Ly8gZm9yY2UgYWxsIHRyYW5zcG9ydHMgdG8gcmVhdHRlbXB0IHRoZSBjb25uZWN0aW9uLiBXaWxsIGltbWVkaWF0ZWx5XG5cdFx0XHRcdFx0Ly8gcmV0cnkuXG5cdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhDb25uZWN0aW9uTWFuYWdlciwgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKipcblx0ICogdHJhbnNwb3J0IG1hbmFnZW1lbnRcblx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzID0ge307XG5cblx0T2JqZWN0KF93ZWJzb2NrZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X19bLyogZGVmYXVsdCAqLyBcImFcIl0pKENvbm5lY3Rpb25NYW5hZ2VyKTtcblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKHBsYXRmb3JtX3RyYW5zcG9ydHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X19bLyogZGVmYXVsdCAqLyBcImFcIl0sIGZ1bmN0aW9uIChpbml0Rm4pIHtcblx0XHRpbml0Rm4oQ29ubmVjdGlvbk1hbmFnZXIpO1xuXHR9KTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0UGFyYW1zID0gZnVuY3Rpb24oaG9zdCwgbW9kZSkge1xuXHRcdHZhciBwYXJhbXMgPSBuZXcgVHJhbnNwb3J0UGFyYW1zKHRoaXMub3B0aW9ucywgaG9zdCwgbW9kZSwgdGhpcy5jb25uZWN0aW9uS2V5KTtcblx0XHRpZih0aGlzLnRpbWVTZXJpYWwpIHtcblx0XHRcdHBhcmFtcy50aW1lU2VyaWFsID0gdGhpcy50aW1lU2VyaWFsO1xuXHRcdH0gZWxzZSBpZih0aGlzLmNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cGFyYW1zLmNvbm5lY3Rpb25TZXJpYWwgPSB0aGlzLmNvbm5lY3Rpb25TZXJpYWw7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJhbXM7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFRyYW5zcG9ydFBhcmFtcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gZGVjaWRlTW9kZShtb2RlQ2IpIHtcblx0XHRcdGlmKHNlbGYuY29ubmVjdGlvbktleSkge1xuXHRcdFx0XHRtb2RlQ2IoJ3Jlc3VtZScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKHR5cGVvZiBzZWxmLm9wdGlvbnMucmVjb3ZlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0bW9kZUNiKCdyZWNvdmVyJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlY292ZXJGbiA9IHNlbGYub3B0aW9ucy5yZWNvdmVyLFxuXHRcdFx0XHRsYXN0U2Vzc2lvbkRhdGEgPSBnZXRTZXNzaW9uUmVjb3ZlckRhdGEoKTtcblx0XHRcdGlmKGxhc3RTZXNzaW9uRGF0YSAmJiB0eXBlb2YocmVjb3ZlckZuKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnQ2FsbGluZyBjbGllbnRPcHRpb25zLXByb3ZpZGVkIHJlY292ZXIgZnVuY3Rpb24gd2l0aCBsYXN0IHNlc3Npb24gZGF0YScpO1xuXHRcdFx0XHRyZWNvdmVyRm4obGFzdFNlc3Npb25EYXRhLCBmdW5jdGlvbihzaG91bGRSZWNvdmVyKSB7XG5cdFx0XHRcdFx0aWYoc2hvdWxkUmVjb3Zlcikge1xuXHRcdFx0XHRcdFx0c2VsZi5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XG5cdFx0XHRcdFx0XHRtb2RlQ2IoJ3JlY292ZXInKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bW9kZUNiKCdjbGVhbicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG1vZGVDYignY2xlYW4nKTtcblx0XHR9XG5cblx0XHRkZWNpZGVNb2RlKGZ1bmN0aW9uKG1vZGUpIHtcblx0XHRcdHZhciB0cmFuc3BvcnRQYXJhbXMgPSBzZWxmLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhudWxsLCBtb2RlKTtcblx0XHRcdGlmKG1vZGUgPT09ICdyZWNvdmVyJykge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnVHJhbnNwb3J0IHJlY292ZXJ5IG1vZGUgPSByZWNvdmVyOyByZWNvdmVyeUtleSA9ICcgKyBzZWxmLm9wdGlvbnMucmVjb3Zlcik7XG5cdFx0XHRcdHZhciBtYXRjaCA9IHNlbGYub3B0aW9ucy5yZWNvdmVyLnNwbGl0KCc6Jyk7XG5cdFx0XHRcdGlmKG1hdGNoICYmIG1hdGNoWzJdKSB7XG5cdFx0XHRcdFx0c2VsZi5tc2dTZXJpYWwgPSBtYXRjaFsyXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpJywgJ1RyYW5zcG9ydCBwYXJhbXMgPSAnICsgdHJhbnNwb3J0UGFyYW1zLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sodHJhbnNwb3J0UGFyYW1zKTtcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBjb25uZWN0IHVzaW5nIGEgZ2l2ZW4gdHJhbnNwb3J0XG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcblx0ICogQHBhcmFtIGNhbmRpZGF0ZSwgdGhlIHRyYW5zcG9ydCB0byB0cnlcblx0ICogQHBhcmFtIGNhbGxiYWNrXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudHJ5QVRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpcywgaG9zdCA9IHRyYW5zcG9ydFBhcmFtcy5ob3N0O1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndHJ5aW5nICcgKyBjYW5kaWRhdGUpO1xuXHRcdChDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW2NhbmRpZGF0ZV0pLnRyeUNvbm5lY3QodGhpcywgdGhpcy5yZWFsdGltZS5hdXRoLCB0cmFuc3BvcnRQYXJhbXMsIGZ1bmN0aW9uKHdyYXBwZWRFcnIsIHRyYW5zcG9ydCkge1xuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5zdGF0ZTtcblx0XHRcdGlmKHN0YXRlID09IHNlbGYuc3RhdGVzLmNsb3NpbmcgfHwgc3RhdGUgPT0gc2VsZi5zdGF0ZXMuY2xvc2VkIHx8IHN0YXRlID09IHNlbGYuc3RhdGVzLmZhaWxlZCkge1xuXHRcdFx0XHRpZih0cmFuc3BvcnQpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb24gJyArIHN0YXRlLnN0YXRlICsgJyB3aGlsZSB3ZSB3ZXJlIGF0dGVtcHRpbmcgdGhlIHRyYW5zcG9ydDsgY2xvc2luZyAnICsgdHJhbnNwb3J0KTtcblx0XHRcdFx0XHR0cmFuc3BvcnQuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayh0cnVlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih3cmFwcGVkRXJyKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ICcgKyBjYW5kaWRhdGUgKyAnICcgKyB3cmFwcGVkRXJyLmV2ZW50ICsgJywgZXJyOiAnICsgd3JhcHBlZEVyci5lcnJvci50b1N0cmluZygpKTtcblxuXHRcdFx0XHQvKiBDb21ldCB0cmFuc3BvcnQgb25jb25uZWN0IHRva2VuIGVycm9ycyBjYW4gYmUgZGVhbHQgd2l0aCBoZXJlLlxuXHRcdFx0XHQqIFdlYnNvY2tldCBvbmVzIG9ubHkgaGFwcGVuIGFmdGVyIHRoZSB0cmFuc3BvcnQgY2xhaW1zIHRvIGJlIHZpYWJsZSxcblx0XHRcdFx0KiBzbyBhcmUgZGVhbHQgd2l0aCBhcyBub24tb25jb25uZWN0IHRva2VuIGVycm9ycyAqL1xuXHRcdFx0XHRpZihfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycih3cmFwcGVkRXJyLmVycm9yKSAmJiAhKHNlbGYuZXJyb3JSZWFzb24gJiYgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIoc2VsZi5lcnJvclJlYXNvbikpKSB7XG5cdFx0XHRcdFx0c2VsZi5lcnJvclJlYXNvbiA9IHdyYXBwZWRFcnIuZXJyb3I7XG5cdFx0XHRcdFx0LyogcmUtZ2V0IGEgdG9rZW4gYW5kIHRyeSBhZ2FpbiAqL1xuXHRcdFx0XHRcdHNlbGYucmVhbHRpbWUuYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdFx0XHRzZWxmLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2UgaWYod3JhcHBlZEVyci5ldmVudCA9PT0gJ2ZhaWxlZCcpIHtcblx0XHRcdFx0XHQvKiBFcnJvciB0aGF0J3MgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cblx0XHRcdFx0XHRzZWxmLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiB3cmFwcGVkRXJyLmVycm9yfSk7XG5cdFx0XHRcdFx0Y2FsbGJhY2sodHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZih3cmFwcGVkRXJyLmV2ZW50ID09PSAnZGlzY29ubmVjdGVkJykge1xuXHRcdFx0XHRcdC8qIEVycm9yIHdpdGggdGhhdCB0cmFuc3BvcnQgb25seSAqL1xuXHRcdFx0XHRcdGNhbGxiYWNrKGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgY2FuZGlkYXRlICsgJzsgc2V0dGluZyBwZW5kaW5nJyk7XG5cdFx0XHRzZWxmLnNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcblx0XHR9KTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBpbmRpY2F0ZWQgdG8gYmUgdmlhYmxlLCBhbmQgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyXG5cdCAqIGV4cGVjdHMgdG8gYWN0aXZhdGUgdGhpcyB0cmFuc3BvcnQgYXMgc29vbiBhcyBpdCBpcyBjb25uZWN0ZWQuXG5cdCAqIEBwYXJhbSBob3N0XG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRUcmFuc3BvcnRQZW5kaW5nID0gZnVuY3Rpb24odHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpIHtcblx0XHR2YXIgbW9kZSA9IHRyYW5zcG9ydFBhcmFtcy5tb2RlO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFuc3BvcnRQZW5kaW5nKCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCArICc7IG1vZGUgPSAnICsgbW9kZSk7XG5cblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuXHRcdHRoaXMucGVuZGluZ1RyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnQpO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRyYW5zcG9ydC5vbmNlKCdjb25uZWN0ZWQnLCBmdW5jdGlvbihlcnJvciwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKSB7XG5cdFx0XHRpZihtb2RlID09ICd1cGdyYWRlJyAmJiBzZWxmLmFjdGl2ZVByb3RvY29sKSB7XG5cdFx0XHRcdC8qICBpZiB3cyBhbmQgeGhycyBhcmUgY29ubmVjdGluZyBpbiBwYXJhbGxlbCwgZGVsYXkgeGhycyBhY3RpdmF0aW9uIHRvIGxldCB3cyBnbyBhaGVhZCAqL1xuXHRcdFx0XHRpZih0cmFuc3BvcnQuc2hvcnROYW1lICE9PSBvcHRpbWFsVHJhbnNwb3J0ICYmIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW4oc2VsZi5nZXRVcGdyYWRlUG9zc2liaWxpdGllcygpLCBvcHRpbWFsVHJhbnNwb3J0KSkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pO1xuXHRcdFx0XHRcdH0sIHNlbGYub3B0aW9ucy50aW1lb3V0cy5wYXJhbGxlbFVwZ3JhZGVEZWxheSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pO1xuXG5cdFx0XHRcdC8qIGFsbG93IGNvbm5lY3RJbXBsIHRvIHN0YXJ0IHRoZSB1cGdyYWRlIHByb2Nlc3MgaWYgbmVlZGVkLCBidXQgYWxsb3dcblx0XHRcdFx0ICogb3RoZXIgZXZlbnQgaGFuZGxlcnMsIGluY2x1ZGluZyBhY3RpdmF0aW5nIHRoZSB0cmFuc3BvcnQsIHRvIHJ1biBmaXJzdCAqL1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG1vZGUgPT09ICdyZWNvdmVyJyAmJiBzZWxmLm9wdGlvbnMucmVjb3Zlcikge1xuXHRcdFx0XHQvKiBBZnRlciBhIHN1Y2Nlc3NmdWwgcmVjb3ZlcnksIHdlIHVucGVyc2lzdCwgYXMgYSByZWNvdmVyeSBrZXkgY2Fubm90XG5cdFx0XHRcdCogYmUgdXNlZCBtb3JlIHRoYW4gb25jZSAqL1xuXHRcdFx0XHRzZWxmLm9wdGlvbnMucmVjb3ZlciA9IG51bGw7XG5cdFx0XHRcdHNlbGYudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dHJhbnNwb3J0Lm9uKFsnZGlzY29ubmVjdGVkJywgJ2Nsb3NlZCcsICdmYWlsZWQnXSwgZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdHNlbGYuZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRoaXMuZXZlbnQsIGVycm9yKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuZW1pdCgndHJhbnNwb3J0LnBlbmRpbmcnLCB0cmFuc3BvcnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBhbiB1cGdyYWRlIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsXG5cdCAqIHRvIHNjaGVkdWxlIHRoZSBhY3RpdmF0aW9uIG9mIHRoYXQgdHJhbnNwb3J0LlxuXHQgKiBAcGFyYW0gZXJyb3Jcblx0ICogQHBhcmFtIHRyYW5zcG9ydFxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbklkXG5cdCAqIEBwYXJhbSBjb25uZWN0aW9uRGV0YWlsc1xuXHQgKiBAcGFyYW0gY29ubmVjdGVkTWVzc2FnZVxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbiA9IGZ1bmN0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIHVwZ3JhZGVDb25uZWN0aW9uUG9zaXRpb24pIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRjdXJyZW50VHJhbnNwb3J0ID0gdGhpcy5hY3RpdmVQcm90b2NvbCAmJiB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLFxuXHRcdFx0YWJhbmRvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHNlbGYucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG5cdFx0XHR9O1xuXG5cdFx0aWYodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkICYmIHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcblx0XHRcdC8qIFRoaXMgaXMgbW9zdCBsaWtlbHkgdG8gaGFwcGVuIGZvciB0aGUgZGVsYXllZCB4aHJzLCB3aGVuIHhocnMgYW5kIHdzIGFyZSBzY2hlZHVsZWQgaW4gcGFyYWxsZWwqL1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSAoJyArIHRoaXMuc3RhdGUuc3RhdGUgKyAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgKyAnKSBpcyBub3QgdmFsaWQgdG8gdXBncmFkZSBpbjsgYWJhbmRvbmluZyB1cGdyYWRlIHRvICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lKTtcblx0XHRcdGFiYW5kb24oKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihjdXJyZW50VHJhbnNwb3J0ICYmICFiZXR0ZXJUcmFuc3BvcnRUaGFuKHRyYW5zcG9ydCwgY3VycmVudFRyYW5zcG9ydCkpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcm9wb3NlZCB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnIGlzIG5vIGJldHRlciB0aGFuIGN1cnJlbnQgYWN0aXZlIHRyYW5zcG9ydCAnICsgY3VycmVudFRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnIC0gYWJhbmRvbmluZyB1cGdyYWRlJyk7XG5cdFx0XHRhYmFuZG9uKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1NjaGVkdWxpbmcgdHJhbnNwb3J0IHVwZ3JhZGU7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXG5cdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5vbmNlTm9wZW5kaW5nKGZ1bmN0aW9uKGVycikge1xuXHRcdFx0dmFyIG9sZFByb3RvY29sO1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdVbmFibGUgdG8gYWN0aXZhdGUgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0ICsgJzsgZXJyID0gJyArIGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0XHQvKiBUaGlzIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIHhociBzdHJlYW1pbmcgdHJhbnNwb3J0IHdhcyBkaXNjb25uZWN0ZWQgZHVyaW5nIHRoZSBwYXJhbGxlbFVwZ3JhZGVEZWxheSAqL1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJvcG9zZWQgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJ2lzIG5vIGxvbmdlciBjb25uZWN0ZWQ7IGFiYW5kb25pbmcgdXBncmFkZScpO1xuXHRcdFx0XHRhYmFuZG9uKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuY29ubmVjdGVkKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdDdXJyZW50bHkgY29ubmVjdGVkLCBzbyB0ZW1wb3JhcmlseSBwYXVzaW5nIGV2ZW50cyB1bnRpbCB0aGUgdXBncmFkZSBpcyBjb21wbGV0ZScpO1xuXHRcdFx0XHRzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZztcblx0XHRcdFx0b2xkUHJvdG9jb2wgPSBzZWxmLmFjdGl2ZVByb3RvY29sO1xuXHRcdFx0fSBlbHNlIGlmKHNlbGYuc3RhdGUgIT09IHNlbGYuc3RhdGVzLmNvbm5lY3RpbmcpIHtcblx0XHRcdFx0LyogTm90ZTogdXBncmFkaW5nIGZyb20gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgaXMgdmFsaWQgaWYgdGhlIG9sZCBhY3RpdmVcblx0XHRcdFx0KiB0cmFuc3BvcnQgd2FzIGRlYWN0aXZhdGVkIGFmdGVyIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCBmaXJzdCBjb25uZWN0ZWQ7XG5cdFx0XHRcdCogc2VlIGxvZ2ljIGluIGRlYWN0aXZhdGVUcmFuc3BvcnQgKi9cblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSAoJyArIHNlbGYuc3RhdGUuc3RhdGUgKyAoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgKyAnKSBpcyBub3QgdmFsaWQgdG8gdXBncmFkZSBpbjsgYWJhbmRvbmluZyB1cGdyYWRlIHRvICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lKTtcblx0XHRcdFx0YWJhbmRvbigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIElmIHRoZSBjb25uZWN0aW9uSWQgaGFzIGNoYW5nZWQsIHRoZSB1cGdyYWRlIGhhc24ndCB3b3JrZWQuIEJ1dCBhc1xuXHRcdFx0KiBpdCdzIHN0aWxsIGFuIHVwZ3JhZGUsIHJlYWx0aW1lIHN0aWxsIGV4cGVjdHMgYSBzeW5jIC0gaXQganVzdCBuZWVkcyB0b1xuXHRcdFx0KiBiZSBhIHN5bmMgd2l0aCB0aGUgbmV3IGNvbm5lY3Rpb24gcG9zaXRpb24uIChBbmQgaXRcblx0XHRcdCogbmVlZHMgdG8gYmUgc2V0IGluIHRoZSBsaWJyYXJ5LCB3aGljaCBpcyBkb25lIGJ5IGFjdGl2YXRlVHJhbnNwb3J0KS4gKi9cblx0XHRcdHZhciBjb25uZWN0aW9uUmVzZXQgPSBjb25uZWN0aW9uSWQgIT09IHNlbGYuY29ubmVjdGlvbklkLFxuXHRcdFx0XHRzeW5jUG9zaXRpb24gPSBjb25uZWN0aW9uUmVzZXQgPyB1cGdyYWRlQ29ubmVjdGlvblBvc2l0aW9uIDogc2VsZjtcblxuXHRcdFx0aWYoY29ubmVjdGlvblJlc2V0KSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdVcGdyYWRlIHJlc3VsdGVkIGluIG5ldyBjb25uZWN0aW9uSWQ7IHJlc2V0dGluZyBsaWJyYXJ5IGNvbm5lY3Rpb24gcG9zaXRpb24gZnJvbSAnICsgKHNlbGYudGltZVNlcmlhbCB8fCBzZWxmLmNvbm5lY3Rpb25TZXJpYWwpICsgJyB0byAnICsgKHN5bmNQb3NpdGlvbi50aW1lU2VyaWFsIHx8IHN5bmNQb3NpdGlvbi5jb25uZWN0aW9uU2VyaWFsKSArICc7IHVwZ3JhZGUgZXJyb3Igd2FzICcgKyBlcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdTeW5jaW5nIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRzZWxmLnN5bmModHJhbnNwb3J0LCBzeW5jUG9zaXRpb24sIGZ1bmN0aW9uKHN5bmNFcnIsIGNvbm5lY3Rpb25JZCwgcG9zdFN5bmNQb3NpdGlvbikge1xuXHRcdFx0XHQvKiBJZiB0aGVyZSdzIGJlZW4gc29tZSBwcm9ibGVtIHdpdGggc3luY2luZyAoYW5kIHRoZSBjb25uZWN0aW9uIGhhc24ndFxuXHRcdFx0XHQgKiBjbG9zZWQgb3Igc29tZXRoaW5nIGluIHRoZSBtZWFudGltZSksIHdlIGhhdmUgYSBwcm9ibGVtIC0tIHdlIGNhbid0XG5cdFx0XHRcdCAqIGp1c3QgZmFsbCBiYWNrIG9uIHRoZSBvbGQgdHJhbnNwb3J0LCBhcyB3ZSBkb24ndCBrbm93IHdoZXRoZXJcblx0XHRcdFx0ICogcmVhbHRpbWUgZ290IHRoZSBzeW5jIC0tIGlmIGl0IGRpZCwgdGhlIG9sZCB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyXG5cdFx0XHRcdCAqIHZhbGlkLiBUbyBiZSBzYWZlLCB3ZSBkaXNjb25uZWN0IGJvdGggYW5kIHN0YXJ0IGFnYWluIGZyb20gc2NyYXRjaC4gKi9cblx0XHRcdFx0aWYoc3luY0Vycikge1xuXHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcblx0XHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdVbmV4cGVjdGVkIGVycm9yIGF0dGVtcHRpbmcgdG8gc3luYyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQgKyAnOyBlcnIgPSAnICsgc3luY0Vycik7XG5cdFx0XHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZmluaXNoVXBncmFkZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdBY3RpdmF0aW5nIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRcdFx0c2VsZi5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBwb3N0U3luY1Bvc2l0aW9uKTtcblx0XHRcdFx0XHQvKiBSZXN0b3JlIHByZS1zeW5jIHN0YXRlLiBJZiBzdGF0ZSBoYXMgY2hhbmdlZCBpbiB0aGUgbWVhbnRpbWUsXG5cdFx0XHRcdFx0ICogZG9uJ3QgdG91Y2ggaXQgLS0gc2luY2UgdGhlIHdlYnNvY2tldCB0cmFuc3BvcnQgd2FpdHMgYSB0aWNrIGJlZm9yZVxuXHRcdFx0XHRcdCAqIGRpc3Bvc2luZyBpdHNlbGYsIGl0J3MgcG9zc2libGUgZm9yIGl0IHRvIGhhdmUgaGFwcGlseSBzeW5jZWRcblx0XHRcdFx0XHQgKiB3aXRob3V0IGVyciB3aGlsZSwgdW5rbm93biB0byBpdCwgdGhlIGNvbm5lY3Rpb24gaGFzIGNsb3NlZCBpbiB0aGVcblx0XHRcdFx0XHQgKiBtZWFudGltZSBhbmQgdGhlIHdzIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGRlYXRoICovXG5cdFx0XHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZykge1xuXHRcdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1ByZS11cGdyYWRlIHByb3RvY29sIGlkbGUsIHNlbmRpbmcgcXVldWVkIG1lc3NhZ2VzIG9uIHVwZ3JhZGVkIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRcdFx0XHRzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZXMuY29ubmVjdGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJlLXVwZ3JhZGUgcHJvdG9jb2wgaWRsZSwgYnV0IHN0YXRlIGlzIG5vdyAnICsgc2VsZi5zdGF0ZS5zdGF0ZSArICcsIHNvIGxlYXZpbmcgdW5jaGFuZ2VkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUuc2VuZEV2ZW50cykge1xuXHRcdFx0XHRcdFx0c2VsZi5zZW5kUXVldWVkTWVzc2FnZXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0LyogV2FpdCB1bnRpbCBzeW5jIGlzIGRvbmUgYW5kIG9sZCB0cmFuc3BvcnQgaXMgaWRsZSBiZWZvcmUgYWN0aXZhdGluZyBuZXcgdHJhbnNwb3J0LiBUaGlzXG5cdFx0XHRcdCAqIGd1YXJhbnRlZXMgdGhhdCBtZXNzYWdlcyBhcnJpdmUgYXQgcmVhbHRpbWUgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSBhcmUgc2VudC5cblx0XHRcdFx0ICpcblx0XHRcdFx0ICogSWYgYSBtZXNzYWdlIHRpbWVzIG91dCBvbiB0aGUgb2xkIHRyYW5zcG9ydCwgc2luY2UgaXQncyBzdGlsbCB0aGUgYWN0aXZlIHRyYW5zcG9ydCB0aGVcblx0XHRcdFx0ICogbWVzc2FnZSB3aWxsIGJlIHJlcXVldWVkLiBkZWFjdGl2YXRlVHJhbnNwb3J0IHdpbGwgc2VlIHRoZSBwZW5kaW5nIHRyYW5zcG9ydCBhbmQgbm90aWZ5XG5cdFx0XHRcdCAqIHRoZSBgY29ubmVjdGluZ2Agc3RhdGUgd2l0aG91dCBzdGFydGluZyBhIG5ldyBjb25uZWN0aW9uLCBzbyB0aGUgbmV3IHRyYW5zcG9ydCBjYW4gdGFrZVxuXHRcdFx0XHQgKiBvdmVyIG9uY2UgZGVhY3RpdmF0ZVRyYW5zcG9ydCBjbGVhcnMgdGhlIG9sZCBwcm90b2NvbCdzIHF1ZXVlLlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBJZiB0aGVyZSBpcyBubyBvbGQgcHJvdG9jb2wsIHRoYXQgbWVhbnQgdGhhdCB3ZSB3ZXJlbid0IGluIHRoZSBjb25uZWN0ZWQgc3RhdGUgYXQgdGhlXG5cdFx0XHRcdCAqIGJlZ2lubmluZyBvZiB0aGUgc3luYyAtIGxpa2VseSB0aGUgYmFzZSB0cmFuc3BvcnQgZGllZCBqdXN0IGJlZm9yZSB0aGUgc3luYy4gU28gY2FuIGp1c3Rcblx0XHRcdFx0ICogZmluaXNoIHRoZSB1cGdyYWRlLiBJZiB3ZSdyZSBhY3R1YWxseSBpbiBjbG9zaW5nL2ZhaWxlZCByYXRoZXIgdGhhbiBjb25uZWN0aW5nLCB0aGF0J3Ncblx0XHRcdFx0ICogZmluZSwgYWN0aXZhdGV0cmFuc3BvcnQgd2lsbCBkZWFsIHdpdGggdGhhdC4gKi9cblx0XHRcdFx0aWYob2xkUHJvdG9jb2wpIHtcblx0XHRcdFx0IC8qIE1vc3Qgb2YgdGhlIHRpbWUgdGhpcyB3aWxsIGJlIGFscmVhZHkgdHJ1ZTogdGhlIG5ldy10cmFuc3BvcnQgc3luYyB3aWxsIGhhdmUgZ2l2ZW5cblx0XHRcdFx0ICogZW5vdWdoIHRpbWUgZm9yIGluLWZsaWdodCBtZXNzYWdlcyBvbiB0aGUgb2xkIHRyYW5zcG9ydCB0byBjb21wbGV0ZS4gKi9cblx0XHRcdFx0XHRvbGRQcm90b2NvbC5vbmNlSWRsZShmaW5pc2hVcGdyYWRlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmaW5pc2hVcGdyYWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsIGFuZCB0aGUgY29ubmVjdGlvbm1hbmFnZXIgZGVjaWRlcyB0aGF0XG5cdCAqIGl0IHdpbGwgbm93IGJlIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGl0IGFjdGl2YXRlZFxuXHQgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0IHRoZSB0cmFuc3BvcnQgaW5zdGFuY2Vcblx0ICogQHBhcmFtIGNvbm5lY3Rpb25JZCB0aGUgaWQgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuXHQgKiBAcGFyYW0gY29ubmVjdGlvblBvc2l0aW9uIHRoZSBwb3NpdGlvbiBhdCB0aGUgcG9pbnQgYWN0aXZhdGlvbjsgZWl0aGVyIHtjb25uZWN0aW9uU2VyaWFsOiA8c2VyaWFsPn0gb3Ige3RpbWVTZXJpYWw6IDxzZXJpYWw+fVxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0aWYoZXJyb3IpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Vycm9yID0gJyArIGVycm9yKTtcblx0XHR9XG5cdFx0aWYoY29ubmVjdGlvbklkKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uSWQgPSAgJyArIGNvbm5lY3Rpb25JZCk7XG5cdFx0fVxuXHRcdGlmKGNvbm5lY3Rpb25EZXRhaWxzKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uRGV0YWlscyA9ICAnICsgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbkRldGFpbHMpKTtcblx0XHR9XG5cdFx0aWYoY29ubmVjdGlvblBvc2l0aW9uKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdzZXJpYWwgPSAgJyArIChjb25uZWN0aW9uUG9zaXRpb24udGltZVNlcmlhbCB8fCBjb25uZWN0aW9uUG9zaXRpb24uY29ubmVjdGlvblNlcmlhbCkpO1xuXHRcdH1cblxuXHRcdHRoaXMucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0KTtcblxuXHRcdC8qIGlmIHRoZSBjb25uZWN0aW9ubWFuYWdlciBtb3ZlZCB0byB0aGUgY2xvc2luZy9jbG9zZWQgc3RhdGUgYmVmb3JlIHRoaXNcblx0XHQgKiBjb25uZWN0aW9uIGV2ZW50LCB0aGVuIHdlIHdvbid0IGFjdGl2YXRlIHRoaXMgdHJhbnNwb3J0ICovXG5cdFx0dmFyIGV4aXN0aW5nU3RhdGUgPSB0aGlzLnN0YXRlLFxuXHRcdFx0Y29ubmVjdGVkU3RhdGUgPSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGU7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY3VycmVudCBzdGF0ZSA9ICcgKyBleGlzdGluZ1N0YXRlLnN0YXRlKTtcblx0XHRpZihleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3Npbmcuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5mYWlsZWQuc3RhdGUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0Rpc2Nvbm5lY3RpbmcgdHJhbnNwb3J0IGFuZCBhYmFuZG9uaW5nJyk7XG5cdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qIHJlbW92ZSB0aGlzIHRyYW5zcG9ydCBmcm9tIHBlbmRpbmcgdHJhbnNwb3J0cyAqL1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblxuXHRcdC8qIGlmIHRoZSB0cmFuc3BvcnQgaXMgbm90IGNvbm5lY3RlZCAoZWcgYmVjYXVzZSBpdCBmYWlsZWQgZHVyaW5nIGFcblx0XHQgKiBzY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24jb25jZU5vUGVuZGluZyB3YWl0KSB0aGVuIGRvbid0IGFjdGl2YXRlIGl0ICovXG5cdFx0aWYoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnRGVjbGluaW5nIHRvIGFjdGl2YXRlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0ICsgJyBzaW5jZSBpdCBhcHBlYXJzIHRvIG5vIGxvbmdlciBiZSBjb25uZWN0ZWQnKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKiB0aGUgZ2l2ZW4gdHJhbnNwb3J0IGlzIGNvbm5lY3RlZDsgdGhpcyB3aWxsIGltbWVkaWF0ZWx5XG5cdFx0ICogdGFrZSBvdmVyIGFzIHRoZSBhY3RpdmUgdHJhbnNwb3J0ICovXG5cdFx0dmFyIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sO1xuXHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wgPSBuZXcgX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0odHJhbnNwb3J0KTtcblx0XHR0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG5cblx0XHR2YXIgY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG5cdFx0aWYoY29ubmVjdGlvbktleSAmJiB0aGlzLmNvbm5lY3Rpb25LZXkgIT0gY29ubmVjdGlvbktleSkgIHtcblx0XHRcdHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24sICEhZXJyb3IpO1xuXHRcdH1cblxuXHRcdC8qIFJlYnJvYWRjYXN0IGFueSBuZXcgY29ubmVjdGlvbkRldGFpbHMgZnJvbSB0aGUgYWN0aXZlIHRyYW5zcG9ydCwgd2hpY2hcblx0XHQgKiBjYW4gY29tZSBhdCBhbnkgdGltZSAoZWcgZm9sbG93aW5nIGEgcmVhdXRoKSwgYW5kIGVtaXQgYW4gUlROMjQgVVBEQVRFXG5cdFx0ICogZXZlbnQuIChMaXN0ZW5lciBhZGRlZCBvbiBuZXh0VGljayBiZWNhdXNlIHdlJ3JlIGluIGEgdHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnKVxuXHRcdCAqIGNhbGxiYWNrIGF0IHRoZSBtb21lbnQ7IGlmIHdlIGFkZCBpdCBub3cgd2UnbGwgYmUgYWRkaW5nIGl0IHRvIHRoZSBlbmRcblx0XHQgKiBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGFuZCBpdCdsbCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkpICovXG5cdFx0dGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0dHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnLCBmdW5jdGlvbihjb25uZWN0ZWRFcnIsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG5cdFx0XHRcdHNlbGYub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KTtcblx0XHRcdFx0c2VsZi5lbWl0KCd1cGRhdGUnLCBuZXcgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXShjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGNvbm5lY3RlZEVycikpO1xuXHRcdFx0fSk7XG5cdFx0fSlcblxuXHRcdC8qIElmIHByZXZpb3VzbHkgbm90IGNvbm5lY3RlZCwgbm90aWZ5IHRoZSBzdGF0ZSBjaGFuZ2UgKGluY2x1ZGluZyBhbnlcblx0XHQgKiBlcnJvcikuICovXG5cdFx0aWYoZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG5cdFx0XHRpZihlcnJvcikge1xuXHRcdFx0XHQvKiBpZiB1cGdyYWRpbmcgd2l0aG91dCBlcnJvciwgbGVhdmUgYW55IGV4aXN0aW5nIGVycm9yUmVhc29uIGFsb25lICovXG5cdFx0XHRcdHRoaXMuZXJyb3JSZWFzb24gPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBlcnJvcjtcblx0XHRcdFx0LyogT25seSBib3RoZXIgZW1pdHRpbmcgYW4gdXBncmFkZSBpZiB0aGVyZSdzIGFuIGVycm9yOyBvdGhlcndpc2UgaXQnc1xuXHRcdFx0XHQgKiBqdXN0IGEgdHJhbnNwb3J0IHVwZ3JhZGUsIHNvIGF1dGggZGV0YWlscyB3b24ndCBoYXZlIGNoYW5nZWQgKi9cblx0XHRcdFx0dGhpcy5lbWl0KCd1cGRhdGUnLCBuZXcgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXShjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGVycm9yKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiAnY29ubmVjdGVkJywgZXJyb3I6IGVycm9yfSk7XG5cdFx0XHR0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3IgfHwgbnVsbDtcblx0XHR9XG5cblx0XHQvKiBTZW5kIGFmdGVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIHVwZGF0ZSwgYXMgQ2hhbm5lbHMgaG9va3MgaW50byB0aGlzIHRvXG5cdFx0ICogcmVzZW5kIGF0dGFjaGVzIG9uIGEgbmV3IHRyYW5zcG9ydCBpZiBuZWNlc3NhcnkgKi9cblx0XHR0aGlzLmVtaXQoJ3RyYW5zcG9ydC5hY3RpdmUnLCB0cmFuc3BvcnQpO1xuXG5cdFx0LyogR3JhY2VmdWxseSB0ZXJtaW5hdGUgZXhpc3RpbmcgcHJvdG9jb2wgKi9cblx0XHRpZihleGlzdGluZ0FjdGl2ZVByb3RvY29sKSB7XG5cdFx0XHRpZihleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpID4gMCkge1xuXHRcdFx0XHQvKiBXZSBjb3VsZCBqdXN0IHJlcXVldWUgcGVuZGluZyBtZXNzYWdlcyBvbiB0aGUgbmV3IHRyYW5zcG9ydCwgYnV0XG5cdFx0XHRcdCAqIGFjdHVhbGx5IHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjogdHJhbnNwb3J0cyBzaG91bGQgb25seSB0YWtlIG92ZXJcblx0XHRcdFx0ICogZnJvbSBvdGhlciBhY3RpdmUgdHJhbnNwb3J0cyB3aGVuIHVwZ3JhZGluZywgYW5kIHVwZ3JhZGluZyB3YWl0cyBmb3Jcblx0XHRcdFx0ICogdGhlIG9sZCB0cmFuc3BvcnQgdG8gYmUgaWRsZS4gU28gbG9nIGFuIGVycm9yLiAqL1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdQcmV2aW91cyBhY3RpdmUgcHJvdG9jb2wgKGZvciB0cmFuc3BvcnQgJyArIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wudHJhbnNwb3J0LnNob3J0TmFtZSArICcsIG5ldyBvbmUgaXMgJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnKSBmaW5pc2hpbmcgd2l0aCAnICsgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArICcgbWVzc2FnZXMgc3RpbGwgcGVuZGluZycpO1xuXHRcdFx0fVxuXHRcdFx0aWYoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ0Fzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCB3YXMgYWxzbyB0aGUgdHJhbnNwb3J0IGZvciB0aGUgcHJldmlvdXMgYWN0aXZlIHByb3RvY29sOyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICc7IHN0YWNrID0gJyArIG5ldyBFcnJvcigpLnN0YWNrO1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XG5cdFx0XHRcdF91dGlsX2Vycm9ycmVwb3J0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVwb3J0KCdlcnJvcicsIG1zZywgJ3RyYW5zcG9ydC1wcmV2aW91c2x5LWFjdGl2ZScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5maW5pc2goKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiBUZXJtaW5hdGUgYW55IG90aGVyIHBlbmRpbmcgdHJhbnNwb3J0KHMpLCBhbmRcblx0XHQgKiBhYm9ydCBhbnkgbm90LXlldC1wZW5kaW5nIHRyYW5zcG9ydCBhdHRlbXB0cyAqL1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24ocGVuZGluZ1RyYW5zcG9ydCkge1xuXHRcdFx0aWYocGVuZGluZ1RyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IGlzIHN0aWxsIG1hcmtlZCBhcyBhIHBlbmRpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICc7IHN0YWNrID0gJyArIG5ldyBFcnJvcigpLnN0YWNrO1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XG5cdFx0XHRcdF91dGlsX2Vycm9ycmVwb3J0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVwb3J0KCdlcnJvcicsIG1zZywgJ3RyYW5zcG9ydC1hY3RpdmF0aW5nLXBlbmRpbmcnKTtcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZShzZWxmLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGVuZGluZ1RyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24ocHJvcG9zZWRUcmFuc3BvcnQpIHtcblx0XHRcdGlmKHByb3Bvc2VkVHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgaXMgc3RpbGwgbWFya2VkIGFzIGEgcHJvcG9zZWQgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICc7IHN0YWNrID0gJyArIG5ldyBFcnJvcigpLnN0YWNrO1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XG5cdFx0XHRcdF91dGlsX2Vycm9ycmVwb3J0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVwb3J0KCdlcnJvcicsIG1zZywgJ3RyYW5zcG9ydC1hY3RpdmF0aW5nLXByb3Bvc2VkJyk7XG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUoc2VsZi5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcm9wb3NlZFRyYW5zcG9ydC5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBUaGlzIGNhbiBvY2N1clxuXHQgKiBpbiBhbnkgdHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWFjdGl2YXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0LCBzdGF0ZSwgZXJyb3IpIHtcblx0XHR2YXIgY3VycmVudFByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbCxcblx0XHRcdHdhc0FjdGl2ZSA9IGN1cnJlbnRQcm90b2NvbCAmJiBjdXJyZW50UHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkgPT09IHRyYW5zcG9ydCxcblx0XHRcdHdhc1BlbmRpbmcgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCksXG5cdFx0XHR3YXNQcm9wb3NlZCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUodGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCksXG5cdFx0XHRub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID0gdGhpcy5ub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKCk7XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAnc3RhdGUgPSAnICsgc3RhdGUgKyAod2FzQWN0aXZlID8gJzsgd2FzIGFjdGl2ZScgOiB3YXNQZW5kaW5nID8gJzsgd2FzIHBlbmRpbmcnIDogd2FzUHJvcG9zZWQgPyAnOyB3YXMgcHJvcG9zZWQnIDogJycpICsgKG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPyAnJyA6ICc7IGFub3RoZXIgdHJhbnNwb3J0IGlzIHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbicpKTtcblx0XHRpZihlcnJvciAmJiBlcnJvci5tZXNzYWdlKVxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdyZWFzb24gPSAgJyArIGVycm9yLm1lc3NhZ2UpO1xuXG5cdFx0aWYod2FzQWN0aXZlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0dldHRpbmcsIGNsZWFyaW5nLCBhbmQgcmVxdWV1aW5nICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgJyBwZW5kaW5nIG1lc3NhZ2VzJyk7XG5cdFx0XHR0aGlzLnF1ZXVlUGVuZGluZ01lc3NhZ2VzKGN1cnJlbnRQcm90b2NvbC5nZXRQZW5kaW5nTWVzc2FnZXMoKSk7XG5cdFx0XHQvKiBDbGVhciBhbnkgbWVzc2FnZXMgd2UgcmVxdWV1ZSB0byBhbGxvdyB0aGUgcHJvdG9jb2wgdG8gYmVjb21lIGlkbGUuXG5cdFx0XHQgKiBJbiBjYXNlIG9mIGFuIHVwZ3JhZGUsIHRoaXMgd2lsbCB0cmlnZ2VyIGFuIGltbWVkaWF0ZSBhY3RpdmF0aW9uIG9mXG5cdFx0XHQgKiB0aGUgdXBncmFkZSB0cmFuc3BvcnQsIHNvIGRlbGF5IGEgdGljayBzbyB0aGlzIHRyYW5zcG9ydCBjYW4gZmluaXNoXG5cdFx0XHQgKiBkZWFjdGl2YXRpbmcgKi9cblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1cnJlbnRQcm90b2NvbC5jbGVhclBlbmRpbmdNZXNzYWdlcygpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sID0gdGhpcy5ob3N0ID0gbnVsbDtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmNoYW5uZWxSZXN1bWVDaGVja1RpbWVyKTtcblx0XHR9XG5cblx0XHR0aGlzLmVtaXQoJ3RyYW5zcG9ydC5pbmFjdGl2ZScsIHRyYW5zcG9ydCk7XG5cblx0XHQvKiB0aGlzIHRyYW5zcG9ydCBzdGF0ZSBjaGFuZ2UgaXMgYSBzdGF0ZSBjaGFuZ2UgZm9yIHRoZSBjb25uZWN0aW9ubWFuYWdlciBpZlxuXHRcdCAqIC0gdGhlIHRyYW5zcG9ydCB3YXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgYW5kIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzXG5cdFx0ICogICB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24sIGp1c3Qgd2FpdGluZyBmb3IgdGhlXG5cdFx0ICogICBhY3RpdmUgdHJhbnNwb3J0IHRvIGZpbmlzaCB3aGF0IGl0cyBkb2luZzsgb3Jcblx0XHQgKiAtIHRoZSB0cmFuc3BvcnQgd2FzIHRoZSBhY3RpdmUgdHJhbnNwb3J0IGFuZCB0aGUgZXJyb3Igd2FzIGZhdGFsIChzb1xuXHRcdCAqICAgdW5oZWFsYWJsZSBieSBhbm90aGVyIHRyYW5zcG9ydCk7IG9yXG5cdFx0ICogLSB0aGVyZSBpcyBubyBhY3RpdmUgdHJhbnNwb3J0LCBhbmQgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmdcblx0XHQgKiAgIHBlbmRpbmcgdHJhbnNwb3J0IChzbyB3ZSB3ZXJlIGluIHRoZSBjb25uZWN0aW5nIHN0YXRlKVxuXHRcdCAqL1xuXHRcdGlmKCh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbikgfHxcblx0XHRcdCh3YXNBY3RpdmUgJiYgKHN0YXRlID09PSAnZmFpbGVkJykgfHwgKHN0YXRlID09PSAnY2xvc2VkJykpIHx8XG5cdFx0XHQoY3VycmVudFByb3RvY29sID09PSBudWxsICYmIHdhc1BlbmRpbmcgJiYgdGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGggPT09IDApKSB7XG5cblx0XHRcdC8qIElmIHdlJ3JlIGRpc2Nvbm5lY3RlZCB3aXRoIGEgNXh4IHdlIG5lZWQgdG8gdHJ5IGZhbGxiYWNrIGhvc3RzXG5cdFx0XHQgKiAoUlROMTRkKSwgYnV0IChhKSBkdWUgdG8gaG93IHRoZSB1cGdyYWRlIHNlcXVlbmNlIHdvcmtzLCB0aGVcblx0XHRcdCAqIGhvc3QvdHJhbnNwb3J0IHNlbGVjdGlvbiBzZXF1ZW5jZSBvbmx5IGNhcmVzIGFib3V0IGdldHRpbmcgdG9cblx0XHRcdCAqIGBwcmVjb25uZWN0YCAoZWcgZXN0YWJsaXNoaW5nIGEgd2Vic29ja2V0KSBnZXR0aW5nIGEgYGRpc2Nvbm5lY3RlZGBcblx0XHRcdCAqIHByb3RvY29sIG1lc3NhZ2UgYWZ0ZXJ3YXJkcyBpcyB0b28gbGF0ZTsgYW5kIChiKSBob3N0IHJldHJ5IG9ubHlcblx0XHRcdCAqIGFwcGxpZXMgdG8gY29ubmVjdEJhc2UgdW5sZXNzIHRoZSBzdG9yZWQgcHJlZmVyZW5jZSB0cmFuc3BvcnQgZG9lc24ndFxuXHRcdFx0ICogd29yay4gV2Ugc29sdmUgdGhpcyBieSB1bnBlcnNpc3RpbmcgdGhlIHRyYW5zcG9ydCBwcmVmZXJlbmNlIGFuZFxuXHRcdFx0ICogc2V0dGluZyBhbiBpbnN0YW5jZSB2YXJpYWJsZSB0byBmb3JjZSBmYWxsYmFjayBob3N0cyB0byBiZSB1c2VkIChpZlxuXHRcdFx0ICogYW55KSBoZXJlLiBCaXQgb2YgYSBrbHVkZ2UsIGJ1dCBubyByZWFsIGJldHRlciBhbHRlcm5hdGl2ZXMgd2l0aG91dFxuXHRcdFx0ICogcmV3cml0aW5nIHRoZSBlbnRpcmUgdGhpbmcgKi9cblx0XHRcdGlmKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiBlcnJvciAmJiBlcnJvci5zdGF0dXNDb2RlID4gNTAwICYmIHRoaXMuaHR0cEhvc3RzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG5cdFx0XHRcdHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSB0cnVlO1xuXHRcdFx0XHQvKiBhbmQgdHJ5IHRvIGNvbm5lY3QgYWdhaW4gdG8gdHJ5IGEgZmFsbGJhY2sgaG9zdCB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSB1c3VhbCAxNXMgZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0ICovXG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiBzdGF0ZSwgZXJyb3I6IGVycm9yLCByZXRyeUltbWVkaWF0ZWx5OiB0cnVlfSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogVE9ETyByZW1vdmUgYmVsb3cgbGluZSBvbmNlIHJlYWx0aW1lIHNlbmRzIHRva2VuIGVycm9ycyBhcyBESVNDT05ORUNURURzICovXG5cdFx0XHR2YXIgbmV3Q29ubmVjdGlvblN0YXRlID0gKHN0YXRlID09PSAnZmFpbGVkJyAmJiBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycihlcnJvcikpID8gJ2Rpc2Nvbm5lY3RlZCcgOiBzdGF0ZTtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiBuZXdDb25uZWN0aW9uU3RhdGUsIGVycm9yOiBlcnJvcn0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKHdhc0FjdGl2ZSAmJiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSAmJiAodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZykpIHtcblx0XHRcdC8qIElmIHdlIHdlcmUgYWN0aXZlIGJ1dCB0aGVyZSBpcyBhbm90aGVyIHRyYW5zcG9ydCBzY2hlZHVsZWQgZm9yXG5cdFx0XHQqIGFjdGl2YXRpb24sIGdvIGludG8gdG8gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgdW50aWwgdGhhdCB0cmFuc3BvcnRcblx0XHRcdCogYWN0aXZhdGVzIGFuZCBzZXRzIHVzIGJhY2sgdG8gY29ubmVjdGVkLiAobWFudWFsbHkgc3RhcnRpbmcgdGhlXG5cdFx0XHQqIHRyYW5zaXRpb24gdGltZXJzIGluIGNhc2UgdGhhdCBuZXZlciBoYXBwZW5zKS4gKElmIHdlIHdlcmUgaW4gdGhlXG5cdFx0XHQqIHN5bmNocm9uaXppbmcgc3RhdGUsIHRoZW4gdGhhdCdzIGZpbmUsIHRoZSBvbGQgdHJhbnNwb3J0IGp1c3QgZ290IGl0c1xuXHRcdFx0KiBkaXNjb25uZWN0ZWQgYmVmb3JlIHRoZSBuZXcgb25lIGdvdCB0aGUgc3luYyAtLSBpZ25vcmUgaXQgYW5kIGtlZXBcblx0XHRcdCogd2FpdGluZyBmb3IgdGhlIHN5bmMuIElmIGl0IGZhaWxzIHdlIGhhdmUgYSBzZXBhcmF0ZSBzeW5jIHRpbWVyIHRoYXRcblx0XHRcdCogd2lsbCBleHBpcmUpLiAqL1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICd3YXNBY3RpdmUgYnV0IGFub3RoZXIgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCBhbmQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uLCBzbyBnb2luZyBpbnRvIHRoZSBjb25uZWN0aW5nIHN0YXRlIHVudGlsIGl0IGFjdGl2YXRlcycpO1xuXHRcdFx0dGhpcy5zdGFydFN1c3BlbmRUaW1lcigpO1xuXHRcdFx0dGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZycsIGVycm9yOiBlcnJvcn0pO1xuXHRcdH1cblx0fTtcblxuXHQvKiBIZWxwZXIgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMgd2hpY2ggYXJlIHBlbmRpbmcsXG5cdCogaGF2ZSBiZWVuIGNvbm5lY3RlZCwgYW5kIGFyZSBqdXN0IHdhaXRpbmcgZm9yIG9uY2VOb1BlbmRpbmcgdG8gZmlyZSBiZWZvcmVcblx0KiBiZWluZyBhY3RpdmF0ZWQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5KHRoaXMucGVuZGluZ1RyYW5zcG9ydHMpIHx8XG5cdFx0XHR0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmV2ZXJ5KGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdFx0XHRyZXR1cm4gIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZDtcblx0XHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBhY3RpdmF0aW5nIGEgbmV3IHRyYW5zcG9ydCwgdG8gZW5zdXJlIG1lc3NhZ2UgZGVsaXZlcnlcblx0ICogb24gdGhlIG5ldyB0cmFuc3BvcnQgc3luY2hyb25pc2VzIHdpdGggdGhlIG1lc3NhZ2VzIGFscmVhZHkgcmVjZWl2ZWRcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24odHJhbnNwb3J0LCByZXF1ZXN0ZWRTeW5jUG9zaXRpb24sIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRyYW5zcG9ydC5vZmYoJ3N5bmMnKTtcblx0XHRcdGNhbGxiYWNrKG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdUaW1lb3V0IHdhaXRpbmcgZm9yIHN5bmMgcmVzcG9uc2UnLCA1MDAwMCwgNTAwKSk7XG5cdFx0fSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuXG5cdFx0Lyogc2VuZCBzeW5jIHJlcXVlc3QgKi9cblx0XHR2YXIgc3luY01lc3NhZ2UgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0XHRhY3Rpb246IGFjdGlvbnMuU1lOQyxcblx0XHRcdGNvbm5lY3Rpb25LZXk6IHRoaXMuY29ubmVjdGlvbktleVxuXHRcdH0pO1xuXG5cdFx0aWYocmVxdWVzdGVkU3luY1Bvc2l0aW9uLnRpbWVTZXJpYWwpIHtcblx0XHRcdHN5bmNNZXNzYWdlLnRpbWVTZXJpYWwgPSByZXF1ZXN0ZWRTeW5jUG9zaXRpb24udGltZVNlcmlhbDtcblx0XHR9IGVsc2UgaWYocmVxdWVzdGVkU3luY1Bvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c3luY01lc3NhZ2UuY29ubmVjdGlvblNlcmlhbCA9IHJlcXVlc3RlZFN5bmNQb3NpdGlvbi5jb25uZWN0aW9uU2VyaWFsO1xuXHRcdH1cblx0XHR0cmFuc3BvcnQuc2VuZChzeW5jTWVzc2FnZSk7XG5cblx0XHR0cmFuc3BvcnQub25jZSgnc3luYycsIGZ1bmN0aW9uKGNvbm5lY3Rpb25JZCwgc3luY1Bvc2l0aW9uKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBjb25uZWN0aW9uSWQsIHN5bmNQb3NpdGlvbik7XG5cdFx0fSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldENvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24sIGhhc0Nvbm5lY3Rpb25FcnJvcikge1xuXHRcdC8qIGlmIGNvbm5lY3Rpb25LZXkgY2hhbmdlcyBidXQgY29ubmVjdGlvbklkIHN0YXlzIHRoZSBzYW1lLCB0aGVuIGp1c3QgYVxuXHRcdCAqIHRyYW5zcG9ydCBjaGFuZ2Ugb24gdGhlIHNhbWUgY29ubmVjdGlvbi4gSWYgY29ubmVjdGlvbklkIGNoYW5nZXMsIHdlJ3JlXG5cdFx0ICogb24gYSBuZXcgY29ubmVjdGlvbiwgd2l0aCBpbXBsaWNhdGlvbnMgZm9yIG1zZ1NlcmlhbCBhbmQgY2hhbm5lbCBzdGF0ZSxcblx0XHQgKiBhbmQgcmVzZXR0aW5nIHRoZSBjb25uZWN0aW9uU2VyaWFsIHBvc2l0aW9uICovXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdC8qIElmIG5vIHByZXZpb3VzIGNvbm5lY3Rpb25JZCwgZG9uJ3QgcmVzZXQgdGhlIG1zZ1NlcmlhbCBhcyBpdCBtYXkgaGF2ZVxuXHRcdCAqIGJlZW4gc2V0IGJ5IHJlY292ZXIgZGF0YSAodW5sZXNzIHRoZSByZWNvdmVyIGZhaWxlZCkgKi9cblx0XHR2YXIgcHJldkNvbm5JZCA9IHRoaXMuY29ubmVjdGlvbmlkLFxuXHRcdFx0Y29ubklkQ2hhbmdlZCA9IHByZXZDb25uSWQgJiYgKHByZXZDb25uSWQgIT09IGNvbm5lY3Rpb25JZCksXG5cdFx0XHRyZWNvdmVyRmFpbHVyZSA9ICFwcmV2Q29ubklkICYmIGhhc0Nvbm5lY3Rpb25FcnJvcjtcblx0XHRpZihjb25uSWRDaGFuZ2VkIHx8IHJlY292ZXJGYWlsdXJlKSAge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdSZXNldHRpbmcgbXNnU2VyaWFsJyk7XG5cdFx0XHR0aGlzLm1zZ1NlcmlhbCA9IDA7XG5cdFx0fVxuXHRcdC8qIGJ1dCBkbyBuZWVkIHRvIHJlYXR0YWNoIGNoYW5uZWxzLCBmb3IgY2hhbm5lbHMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgaW5cblx0XHQgKiB0aGUgYXR0YWNoZWQgc3RhdGUgZXZlbiB0aG91Z2ggdGhlIGNvbm5lY3Rpb24gbW9kZSB3YXMgJ2NsZWFuJyBkdWUgdG8gYVxuXHRcdCAqIGZyZXNobmVzcyBjaGVjayAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8zOTQgKi9cblx0XHRpZih0aGlzLmNvbm5lY3Rpb25JZCAhPT0gY29ubmVjdGlvbklkKSAge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdOZXcgY29ubmVjdGlvbklkOyByZWF0dGFjaGluZyBhbnkgYXR0YWNoZWQgY2hhbm5lbHMnKTtcblx0XHRcdC8qIFdhaXQgdGlsbCBuZXh0IHRpY2sgYmVmb3JlIHJlYXR0YWNoaW5nIGNoYW5uZWxzLCBzbyB0aGF0IGNvbm5lY3Rpb25cblx0XHRcdCAqIHN0YXRlIHdpbGwgYmUgdXBkYXRlZCBhbmQgc28gdGhhdCBpdCB3aWxsIGJlIGFwcGxpZWQgYWZ0ZXJcblx0XHRcdCAqIENoYW5uZWxzI29uVHJhbnNwb3J0VXBkYXRlLCBlbHNlIGNoYW5uZWxzIHdpbGwgbm90IGhhdmUgYW4gQVRUQUNIRURcblx0XHRcdCAqIHNlbnQgdHdpY2UgKG9uY2UgZnJvbSB0aGlzIGFuZCBvbmNlIGZyb20gdGhhdCkuICovXG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnJlYWx0aW1lLmNoYW5uZWxzLnJlYXR0YWNoKCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYodGhpcy5vcHRpb25zLmNoZWNrQ2hhbm5lbHNPblJlc3VtZSkge1xuXHRcdFx0LyogRm9yIGF0dGFjaGVkIGNoYW5uZWxzLCBzZXQgdGhlIGF0dGFjaGVkIG1zZyBpbmRpY2F0b3IgdmFyaWFibGUgdG8gZmFsc2UsXG5cdFx0XHQgKiB3YWl0IDMwcywgYW5kIGNoZWNrIHdlIGdvdCBhbiBhdHRhY2hlZCBmb3IgZWFjaCBvbmUuXG5cdFx0XHQgKiAzMHMgd2FzIGNob3NlbiB0byBiZSA1cyBsb25nZXIgdGhhbiB0aGUgdHJhbnNwb3J0IGlkbGUgdGltZW91dCBleHBpcmVcblx0XHRcdCAqIHRpbWUsIGluIGFuIGF0dGVtcHQgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzIGR1ZSB0byBhIHRyYW5zcG9ydFxuXHRcdFx0ICogc2lsZW50bHkgZmFpbGluZyBpbW1lZGlhdGVseSBhZnRlciBhIHJlc3VtZSAqL1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdTYW1lIGNvbm5lY3Rpb25JZDsgY2hlY2tDaGFubmVsc09uUmVzdW1lIGlzIGVuYWJsZWQnKTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmNoYW5uZWxSZXN1bWVDaGVja1RpbWVyKTtcblx0XHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucmVzZXRBdHRhY2hlZE1zZ0luZGljYXRvcnMoKTtcblx0XHRcdHRoaXMuY2hhbm5lbFJlc3VtZUNoZWNrVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnJlYWx0aW1lLmNoYW5uZWxzLmNoZWNrQXR0YWNoZWRNc2dJbmRpY2F0b3JzKGNvbm5lY3Rpb25JZCk7XG5cdFx0XHR9LCAzMDAwMCk7XG5cdFx0fVxuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5rZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5O1xuXHRcdHZhciBmb3JjZVJlc2V0TWVzc2FnZVNlcmlhbCA9IGNvbm5JZENoYW5nZWQgfHwgIXByZXZDb25uSWQ7XG5cdFx0dGhpcy5zZXRDb25uZWN0aW9uU2VyaWFsKGNvbm5lY3Rpb25Qb3NpdGlvbiwgZm9yY2VSZXNldE1lc3NhZ2VTZXJpYWwpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2xlYXJDb25uZWN0aW9uU2VyaWFsKCk7XG5cdFx0dGhpcy5tc2dTZXJpYWwgPSAwO1xuXHRcdHRoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuXHR9O1xuXG5cdC8qIGZvcmNlOiBzZXQgdGhlIGNvbm5lY3Rpb25TZXJpYWwgZXZlbiBpZiBpdCdzIGxlc3MgdGhhbiB0aGUgY3VycmVudFxuXHQgKiBjb25uZWN0aW9uU2VyaWFsLiBVc2VkIGZvciBuZXcgY29ubmVjdGlvbnMuXG5cdCAqIFJldHVybnMgdHJ1ZSBpZmYgdGhlIG1lc3NhZ2Ugd2FzIHJlamVjdGVkIGFzIGEgZHVwbGljYXRlLiAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0Q29ubmVjdGlvblNlcmlhbCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25Qb3NpdGlvbiwgZm9yY2UpIHtcblx0XHR2YXIgdGltZVNlcmlhbCA9IGNvbm5lY3Rpb25Qb3NpdGlvbi50aW1lU2VyaWFsLFxuXHRcdFx0Y29ubmVjdGlvblNlcmlhbCA9IGNvbm5lY3Rpb25Qb3NpdGlvbi5jb25uZWN0aW9uU2VyaWFsO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uU2VyaWFsKCknLCAnVXBkYXRpbmcgY29ubmVjdGlvbiBzZXJpYWw7IHNlcmlhbCA9ICcgKyBjb25uZWN0aW9uU2VyaWFsICsgJzsgdGltZVNlcmlhbCA9ICcgKyB0aW1lU2VyaWFsICsgJzsgZm9yY2UgPSAnICsgZm9yY2UgKyAnOyBwcmV2aW91cyA9ICcgKyB0aGlzLmNvbm5lY3Rpb25TZXJpYWwpO1xuXHRcdGlmKHRpbWVTZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodGltZVNlcmlhbCA8PSB0aGlzLnRpbWVTZXJpYWwgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uU2VyaWFsKCknLCAncmVjZWl2ZWQgbWVzc2FnZSB3aXRoIHRpbWVTZXJpYWwgJyArIHRpbWVTZXJpYWwgKyAnLCBidXQgY3VycmVudCB0aW1lU2VyaWFsIGlzICcgKyB0aGlzLnRpbWVTZXJpYWwgKyAnOyBhc3N1bWluZyBtZXNzYWdlIGlzIGEgZHVwbGljYXRlIGFuZCBkaXNjYXJkaW5nIGl0Jyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnRpbWVTZXJpYWwgPSB0aGlzLnRpbWVTZXJpYWwgPSB0aW1lU2VyaWFsO1xuXHRcdFx0dGhpcy5zZXRSZWNvdmVyeUtleSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZihjb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKGNvbm5lY3Rpb25TZXJpYWwgPD0gdGhpcy5jb25uZWN0aW9uU2VyaWFsICYmICFmb3JjZSkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvblNlcmlhbCgpJywgJ3JlY2VpdmVkIG1lc3NhZ2Ugd2l0aCBjb25uZWN0aW9uU2VyaWFsICcgKyBjb25uZWN0aW9uU2VyaWFsICsgJywgYnV0IGN1cnJlbnQgY29ubmVjdGlvblNlcmlhbCBpcyAnICsgdGhpcy5jb25uZWN0aW9uU2VyaWFsICsgJzsgYXNzdW1pbmcgbWVzc2FnZSBpcyBhIGR1cGxpY2F0ZSBhbmQgZGlzY2FyZGluZyBpdCcpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5zZXJpYWwgPSB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSBjb25uZWN0aW9uU2VyaWFsO1xuXHRcdFx0dGhpcy5zZXRSZWNvdmVyeUtleSgpO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJDb25uZWN0aW9uU2VyaWFsID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnNlcmlhbCA9IHRoaXMuY29ubmVjdGlvblNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24udGltZVNlcmlhbCA9IHRoaXMudGltZVNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNsZWFyUmVjb3ZlcnlLZXkoKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0UmVjb3ZlcnlLZXkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ucmVjb3ZlcnlLZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgKyAnOicgKyAodGhpcy50aW1lU2VyaWFsIHx8IHRoaXMuY29ubmVjdGlvblNlcmlhbCkgKyAnOicgKyB0aGlzLm1zZ1NlcmlhbDtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJSZWNvdmVyeUtleSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5yZWNvdmVyeUtleSA9IG51bGw7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLmNvbm5lY3Rpb25JZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBzaW5jZUxhc3QgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG5cdFx0aWYoc2luY2VMYXN0ID4gdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgKyB0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCknLCAnTGFzdCBrbm93biBhY3Rpdml0eSBmcm9tIHJlYWx0aW1lIHdhcyAnICsgc2luY2VMYXN0ICsgJ21zIGFnbzsgZGlzY2FyZGluZyBjb25uZWN0aW9uIHN0YXRlJyk7XG5cdFx0XHR0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuXHRcdFx0dGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnc3VzcGVuZGVkJztcblx0XHRcdHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcucXVldWVFdmVudHMgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuXHQgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBlcnNpc3RDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoaGF2ZVNlc3Npb25TdG9yYWdlKSB7XG5cdFx0XHR2YXIgcmVjb3ZlcnlLZXkgPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ucmVjb3ZlcnlLZXk7XG5cdFx0XHRpZihyZWNvdmVyeUtleSkge1xuXHRcdFx0XHRzZXRTZXNzaW9uUmVjb3ZlckRhdGEoe1xuXHRcdFx0XHRcdHJlY292ZXJ5S2V5OiByZWNvdmVyeUtleSxcblx0XHRcdFx0XHRkaXNjb25uZWN0ZWRBdDogX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSxcblx0XHRcdFx0XHRsb2NhdGlvbjogZ2xvYmFsLmxvY2F0aW9uLFxuXHRcdFx0XHRcdGNsaWVudElkOiB0aGlzLnJlYWx0aW1lLmF1dGguY2xpZW50SWRcblx0XHRcdFx0fSwgdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIHdhbnRzIHRvIHBlcnNpc3QgdHJhbnNwb3J0XG5cdCAqIHN0YXRlIGZvciBsYXRlciByZWNvdmVyeS4gT25seSBhcHBsaWNhYmxlIGluIHRoZSBicm93c2VyIGNvbnRleHQuXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudW5wZXJzaXN0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdGNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCk7XG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHQgKiBzdGF0ZSBtYW5hZ2VtZW50XG5cdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXJyb3JSZWFzb24gfHwgdGhpcy5nZXRTdGF0ZUVycm9yKCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFN0YXRlRXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1svKiBkZWZhdWx0ICovIFwiYVwiXVt0aGlzLnN0YXRlLnN0YXRlXTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0aXZlU3RhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cyB8fCB0aGlzLnN0YXRlLnNlbmRFdmVudHM7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmVuYWN0U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdHZhciBsb2dMZXZlbCA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09ICdmYWlsZWQnID8gX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SIDogX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01BSk9SO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihsb2dMZXZlbCwgJ0Nvbm5lY3Rpb24gc3RhdGUnLCBzdGF0ZUNoYW5nZS5jdXJyZW50ICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiA/ICgnOyByZWFzb246ICcgKyBzdGF0ZUNoYW5nZS5yZWFzb24pIDogJycpKTtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZW5hY3RTdGF0ZUNoYW5nZScsICdzZXR0aW5nIG5ldyBzdGF0ZTogJyArIHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyAnOyByZWFzb24gPSAnICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiAmJiBzdGF0ZUNoYW5nZS5yZWFzb24ubWVzc2FnZSkpO1xuXHRcdHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZUNoYW5nZS5jdXJyZW50XTtcblx0XHRpZihzdGF0ZUNoYW5nZS5yZWFzb24pIHtcblx0XHRcdHRoaXMuZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG5cdFx0fVxuXHRcdGlmKG5ld1N0YXRlLnRlcm1pbmFsIHx8IG5ld1N0YXRlLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0Lyogc3VzcGVuZGVkIGlzIG5vbnRlcm1pbmFsLCBidXQgb25jZSBpbiB0aGUgc3VzcGVuZGVkIHN0YXRlLCByZWFsdGltZVxuXHRcdFx0ICogd2lsbCBoYXZlIGRpc2NhcmRlZCBvdXIgY29ubmVjdGlvbiBzdGF0ZSwgc28gZnV0aGVyIGNvbm5lY3Rpb25cblx0XHRcdCAqIGF0dGVtcHRzIHNob3VsZCBzdGFydCBmcm9tIHNjcmF0Y2ggKi9cblx0XHRcdHRoaXMuY2xlYXJDb25uZWN0aW9uKCk7XG5cdFx0fVxuXHRcdHRoaXMuZW1pdCgnY29ubmVjdGlvbnN0YXRlJywgc3RhdGVDaGFuZ2UpO1xuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIENvbm5lY3Rpb25NYW5hZ2VyIGNvbm5lY3Rpb24gbGlmZWN5Y2xlXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFRyYW5zaXRpb25UaW1lciA9IGZ1bmN0aW9uKHRyYW5zaXRpb25TdGF0ZSkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydFRyYW5zaXRpb25UaW1lcigpJywgJ3RyYW5zaXRpb25TdGF0ZTogJyArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZSk7XG5cblx0XHRpZih0aGlzLnRyYW5zaXRpb25UaW1lcikge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKCknLCAnY2xlYXJpbmcgYWxyZWFkeS1ydW5uaW5nIHRpbWVyJyk7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuXHRcdH1cblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihzZWxmLnRyYW5zaXRpb25UaW1lcikge1xuXHRcdFx0XHRzZWxmLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciAnICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlICsgJyB0aW1lciBleHBpcmVkJywgJ3JlcXVlc3RpbmcgbmV3IHN0YXRlOiAnICsgdHJhbnNpdGlvblN0YXRlLmZhaWxTdGF0ZSk7XG5cdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlfSk7XG5cdFx0XHR9XG5cdFx0fSwgdHJhbnNpdGlvblN0YXRlLnJldHJ5RGVsYXkpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYW5jZWxUcmFuc2l0aW9uVGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCknLCAnJyk7XG5cdFx0aWYodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25UaW1lcik7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFN1c3BlbmRUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZih0aGlzLnN1c3BlbmRUaW1lcilcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLnN1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihzZWxmLnN1c3BlbmRUaW1lcikge1xuXHRcdFx0XHRzZWxmLnN1c3BlbmRUaW1lciA9IG51bGw7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBzdXNwZW5kIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6IHN1c3BlbmRlZCcpO1xuXHRcdFx0XHRzZWxmLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdzdXNwZW5kZWQnO1xuXHRcdFx0XHRzZWxmLnN0YXRlcy5jb25uZWN0aW5nLnF1ZXVlRXZlbnRzID0gZmFsc2U7XG5cdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiAnc3VzcGVuZGVkJ30pO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2hlY2tTdXNwZW5kVGltZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdGlmKHN0YXRlICE9PSAnZGlzY29ubmVjdGVkJyAmJiBzdGF0ZSAhPT0gJ3N1c3BlbmRlZCcgJiYgc3RhdGUgIT09ICdjb25uZWN0aW5nJylcblx0XHRcdHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFN1c3BlbmRUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG5cdFx0dGhpcy5zdGF0ZXMuY29ubmVjdGluZy5xdWV1ZUV2ZW50cyA9IHRydWU7XG5cdFx0aWYodGhpcy5zdXNwZW5kVGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnN1c3BlbmRUaW1lcik7XG5cdFx0XHR0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFJldHJ5VGltZXIgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIHJldHJ5IHRpbWVyIGV4cGlyZWQnLCAncmV0cnlpbmcnKTtcblx0XHRcdHNlbGYucmV0cnlUaW1lciA9IG51bGw7XG5cdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJ30pO1xuXHRcdH0sIGludGVydmFsKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FuY2VsUmV0cnlUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMucmV0cnlUaW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG5cdFx0XHR0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubm90aWZ5U3RhdGUgPSBmdW5jdGlvbihpbmRpY2F0ZWQpIHtcblx0XHR2YXIgc3RhdGUgPSBpbmRpY2F0ZWQuc3RhdGUsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdC8qIFdlIHJldHJ5IGltbWVkaWF0ZWx5IGlmOlxuXHRcdCAqIC0gc29tZXRoaW5nIGRpc2Nvbm5lY3RzIHVzIHdoaWxlIHdlJ3JlIGNvbm5lY3RlZCwgb3Jcblx0XHQgKiAtIGEgdmlhYmxlIChidXQgbm90IHlldCBhY3RpdmUpIHRyYW5zcG9ydCBmYWlscyBkdWUgdG8gYSB0b2tlbiBlcnJvciAoc29cblx0XHQgKiAgIHRoaXMuZXJyb3JSZWFzb24gd2lsbCBiZSBzZXQsIGFuZCBzdGFydENvbm5lY3Qgd2lsbCBkbyBhIGZvcmNlZFxuXHRcdCAqICAgYXV0aG9yaXplKS4gSWYgdGhpcy5lcnJvclJlYXNvbiBpcyBhbHJlYWR5IHNldCAodG8gYSB0b2tlbiBlcnJvciksXG5cdFx0ICogICB0aGVuIHRoZXJlIGhhcyBiZWVuIGF0IGxlYXN0IG9uZSBwcmV2aW91cyBhdHRlbXB0IHRvIGNvbm5lY3QgdGhhdCBhbHNvXG5cdFx0ICogICBmYWlsZWQgZm9yIGEgdG9rZW4gZXJyb3IsIHNvIGJ5IFJUTjE0YiB3ZSBnbyB0byBESVNDT05ORUNURUQgYW5kIHdhaXRcblx0XHQgKiAgIGJlZm9yZSB0cnlpbmcgYWdhaW4gKi9cblx0XHR2YXIgcmV0cnlJbW1lZGlhdGVseSA9IChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiZcblx0XHRcdCh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgICAgIHx8XG5cdFx0XHQgdGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyB8fFxuXHRcdFx0IGluZGljYXRlZC5yZXRyeUltbWVkaWF0ZWx5ICAgICAgICAgICAgICAgfHxcblx0XHRcdFx0KHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcgJiZcblx0XHRcdFx0XHRpbmRpY2F0ZWQuZXJyb3IgJiYgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIoaW5kaWNhdGVkLmVycm9yKSAmJlxuXHRcdFx0XHRcdCEodGhpcy5lcnJvclJlYXNvbiAmJiBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkpKSk7XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICduZXcgc3RhdGU6ICcgKyBzdGF0ZSArIChyZXRyeUltbWVkaWF0ZWx5ID8gJzsgd2lsbCByZXRyeSBjb25uZWN0aW9uIGltbWVkaWF0ZWx5JyA6ICcnKSk7XG5cdFx0LyogZG8gbm90aGluZyBpZiB3ZSdyZSBhbHJlYWR5IGluIHRoZSBpbmRpY2F0ZWQgc3RhdGUgKi9cblx0XHRpZihzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Lyoga2lsbCB0aW1lcnMgKHBvc3NpYmx5IGV4Y2VwdGluZyBzdXNwZW5kIHRpbWVyIGRlcGVuZGluZyBvbiB0aGUgbm90aWZpZWRcblx0XHQqIHN0YXRlKSwgYXMgdGhlc2UgYXJlIHN1cGVyc2VkZWQgYnkgdGhpcyBub3RpZmljYXRpb24gKi9cblx0XHR0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuXHRcdHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuXHRcdHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoaW5kaWNhdGVkLnN0YXRlKTtcblxuXHRcdC8qIGRvIG5vdGhpbmcgaWYgd2UncmUgdW5hYmxlIHRvIG1vdmUgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSAqL1xuXHRcdGlmKHRoaXMuc3RhdGUudGVybWluYWwpXG5cdFx0XHRyZXR1cm47XG5cblx0XHQvKiBwcm9jZXNzIG5ldyBzdGF0ZSAqL1xuXHRcdHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW2luZGljYXRlZC5zdGF0ZV0sXG5cdFx0XHRjaGFuZ2UgPSBuZXcgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXSh0aGlzLnN0YXRlLnN0YXRlLCBuZXdTdGF0ZS5zdGF0ZSwgbmV3U3RhdGUucmV0cnlEZWxheSwgKGluZGljYXRlZC5lcnJvciB8fCBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdW25ld1N0YXRlLnN0YXRlXSkpO1xuXG5cdFx0aWYocmV0cnlJbW1lZGlhdGVseSkge1xuXHRcdFx0dmFyIGF1dG9SZWNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuZGlzY29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0c2VsZi5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpO1xuXHRcdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR2YXIgc2luY2VMYXN0ID0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgJiYgKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCkgLSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCArIDEpO1xuXHRcdFx0aWYoc2luY2VMYXN0ICYmIChzaW5jZUxhc3QgPCAxMDAwKSkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICdMYXN0IHJlY29ubmVjdCBhdHRlbXB0IHdhcyBvbmx5ICcgKyBzaW5jZUxhc3QgKyAnbXMgYWdvLCB3YWl0aW5nIGFub3RoZXIgJyArICgxMDAwIC0gc2luY2VMYXN0KSArICdtcyBiZWZvcmUgdHJ5aW5nIGFnYWluJyk7XG5cdFx0XHRcdHNldFRpbWVvdXQoYXV0b1JlY29ubmVjdCwgMTAwMCAtIHNpbmNlTGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGF1dG9SZWNvbm5lY3QpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZihzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgfHwgc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG5cdFx0XHR0aGlzLnN0YXJ0UmV0cnlUaW1lcihuZXdTdGF0ZS5yZXRyeURlbGF5KTtcblx0XHR9XG5cblx0XHQgLyogSWYgZ29pbmcgaW50byBkaXNjb25uZWN0L3N1c3BlbmRlZCAoYW5kIG5vdCByZXRyeWluZyBpbW1lZGlhdGVseSksIG9yIGFcblx0XHRcdCogdGVybWluYWwgc3RhdGUsIGVuc3VyZSB0aGVyZSBhcmUgbm8gb3JwaGFuZWQgdHJhbnNwb3J0cyBoYW5naW5nIGFyb3VuZC4gKi9cblx0XHRpZigoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmICFyZXRyeUltbWVkaWF0ZWx5KSB8fFxuXHRcdFx0IChzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHx8XG5cdFx0XHQgbmV3U3RhdGUudGVybWluYWwpIHtcblx0XHRcdFx0IC8qIFdhaXQgdGlsbCB0aGUgbmV4dCB0aWNrIHNvIHRoZSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZSBpcyBlbmFjdGVkLFxuXHRcdFx0XHQgKiBzbyBhYm9ydGluZyB0cmFuc3BvcnRzIGRvZXNuJ3QgdHJpZ2dlciByZWR1bmRhbnQgc3RhdGUgY2hhbmdlcyAqL1xuXHRcdFx0XHQgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQgc2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHQgfSk7XG5cdFx0IH1cblxuXHRcdGlmKHN0YXRlID09ICdjb25uZWN0ZWQnICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICdCcm9rZW4gaW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gZ28gaW50byBjb25uZWN0ZWQgc3RhdGUsIGJ1dCB0aGVyZSBpcyBubyBhY3RpdmUgcHJvdG9jb2wnKTtcblx0XHR9XG5cblx0XHQvKiBpbXBsZW1lbnQgdGhlIGNoYW5nZSBhbmQgbm90aWZ5ICovXG5cdFx0dGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG5cdFx0aWYodGhpcy5zdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHR0aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuXHRcdH0gZWxzZSBpZighdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cykge1xuXHRcdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKHN0YXRlLCBjaGFuZ2UucmVhc29uKTtcblx0XHRcdHRoaXMuZmFpbFF1ZXVlZE1lc3NhZ2VzKGNoYW5nZS5yZWFzb24pOyAvLyBSVE43Y1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVxdWVzdFN0YXRlID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuXHRcdHZhciBzdGF0ZSA9IHJlcXVlc3Quc3RhdGUsIHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoKScsICdyZXF1ZXN0ZWQgc3RhdGU6ICcgKyBzdGF0ZSArICc7IGN1cnJlbnQgc3RhdGU6ICcgKyB0aGlzLnN0YXRlLnN0YXRlKTtcblx0XHRpZihzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuXHRcdFx0cmV0dXJuOyAvKiBzaWxlbnRseSBkbyBub3RoaW5nICovXG5cblx0XHQvKiBraWxsIHJ1bm5pbmcgdGltZXJzLCBhcyB0aGlzIHJlcXVlc3Qgc3VwZXJzZWRlcyB0aGVtICovXG5cdFx0dGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcblx0XHR0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcblx0XHQvKiBmb3Igc3VzcGVuZCB0aW1lciBjaGVjayByYXRoZXIgdGhhbiBjYW5jZWwgLS0gZWcgcmVxdWVzdGluZyBhIGNvbm5lY3Rpbmdcblx0XHQqIHN0YXRlIHNob3VsZCBub3QgcmVzZXQgdGhlIHN1c3BlbmQgdGltZXIgKi9cblx0XHR0aGlzLmNoZWNrU3VzcGVuZFRpbWVyKHN0YXRlKTtcblxuXHRcdGlmKHN0YXRlID09ICdjb25uZWN0aW5nJyAmJiB0aGlzLnN0YXRlLnN0YXRlID09ICdjb25uZWN0ZWQnKSByZXR1cm47XG5cdFx0aWYoc3RhdGUgPT0gJ2Nsb3NpbmcnICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gJ2Nsb3NlZCcpIHJldHVybjtcblxuXHRcdHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlXSxcblx0XHRcdGNoYW5nZSA9IG5ldyBfY2xpZW50X2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKHRoaXMuc3RhdGUuc3RhdGUsIG5ld1N0YXRlLnN0YXRlLCBudWxsLCAocmVxdWVzdC5lcnJvciB8fCBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdW25ld1N0YXRlLnN0YXRlXSkpO1xuXG5cdFx0dGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG5cblx0XHRpZihzdGF0ZSA9PSAnY29ubmVjdGluZycpIHtcblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYuc3RhcnRDb25uZWN0KCk7IH0pO1xuXHRcdH1cblx0XHRpZihzdGF0ZSA9PSAnY2xvc2luZycpIHtcblx0XHRcdHRoaXMuY2xvc2VJbXBsKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0Q29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKScsICdNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCwgYnV0IHdhcyAnICsgdGhpcy5zdGF0ZS5zdGF0ZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGF1dGggPSB0aGlzLnJlYWx0aW1lLmF1dGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdC8qIFRoZSBwb2ludCBvZiB0aGUgY29ubmVjdENvdW50ZXIgbWVjaGFuaXNtIGlzIHRvIGVuc3VyZSB0aGF0IHRoZVxuXHRcdCAqIGNvbm5lY3Rpb24gcHJvY2VkdXJlIGNhbiBiZSBjYW5jZWxsZWQuIFdlIHdhbnQgZGlzY29ubmVjdEFsbFRyYW5zcG9ydHNcblx0XHQgKiB0byBiZSBhYmxlIHRvIHN0b3AgYW55IGluLXByb2dyZXNzIGNvbm5lY3Rpb24sIGV2ZW4gYmVmb3JlIGl0IGdldHMgdG9cblx0XHQgKiB0aGUgc3RhZ2Ugb2YgaGF2aW5nIGEgcGVuZGluZyAob3IgZXZlbiBhIHByb3Bvc2VkKSB0cmFuc3BvcnQgdGhhdCBpdCBjYW5cblx0XHQgKiBkaXNwb3NlKCkgb2YuIFNvIHdlIGNoZWNrIHRoYXQgaXQncyBzdGlsbCBjdXJyZW50IGFmdGVyIGFueSBhc3luYyBzdGFnZSxcblx0XHQgKiB1cCB1bnRpbCB0aGUgc3RhZ2UgdGhhdCBpcyBzeW5jaHJvbm91cyB3aXRoIGluc3RhbnRpYXRpbmcgYSB0cmFuc3BvcnQgKi9cblx0XHR2YXIgY29ubmVjdENvdW50ID0gKyt0aGlzLmNvbm5lY3RDb3VudGVyO1xuXG5cdFx0dmFyIGNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKTtcblx0XHRcdHNlbGYuZ2V0VHJhbnNwb3J0UGFyYW1zKGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcykge1xuXHRcdFx0XHRpZihjb25uZWN0Q291bnQgIT09IHNlbGYuY29ubmVjdENvdW50ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpJywgJ3N0YXJ0aW5nIGNvbm5lY3Rpb24nKTtcblx0XHR0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XG5cdFx0dGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcblxuXHRcdGlmKGF1dGgubWV0aG9kID09PSAnYmFzaWMnKSB7XG5cdFx0XHRjb25uZWN0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBhdXRoQ2IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYoY29ubmVjdENvdW50ICE9PSBzZWxmLmNvbm5lY3RDb3VudGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdHNlbGYuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25uZWN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRpZih0aGlzLmVycm9yUmVhc29uICYmIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSB7XG5cdFx0XHRcdC8qIEZvcmNlIGEgcmVmZXRjaCBvZiBhIG5ldyB0b2tlbiAqL1xuXHRcdFx0XHRhdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwsIGF1dGhDYik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSwgYXV0aENiKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZXJlIGFyZSB0aHJlZSBzdGFnZXMgaW4gY29ubmVjdGluZzpcblx0ICogLSBwcmVmZXJlbmNlOiBpZiB0aGVyZSBpcyBhIGNhY2hlZCB0cmFuc3BvcnQgcHJlZmVyZW5jZSwgd2UgdHJ5IHRvIGNvbm5lY3Rcblx0ICogICBvbiB0aGF0LiBJZiB0aGF0IGZhaWxzIG9yIHRpbWVzIG91dCB3ZSBhYm9ydCB0aGUgYXR0ZW1wdCwgcmVtb3ZlIHRoZVxuXHQgKiAgIHByZWZlcmVuY2UgYW5kIGZhbGwgYmFjayB0byBiYXNlLiBJZiBpdCBzdWNjZWVkcywgd2UgdHJ5IHVwZ3JhZGluZyBpdCBpZlxuXHQgKiAgIG5lZWRlZCAod2lsbCBvbmx5IGJlIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBwcmVmZXJlbmNlIGlzIHhocnMgYW5kIHRoZVxuXHQgKiAgIGJyb3dzZXIgc3VwcG9ydHMgd3MpLlxuXHQgKiAtIGJhc2U6IHdlIHRyeSB0byBjb25uZWN0IHdpdGggdGhlIGJlc3QgdHJhbnNwb3J0IHRoYXQgd2UgdGhpbmsgd2lsbFxuXHQgKiAgIG5ldmVyIGZhaWwgZm9yIHRoaXMgYnJvd3NlciAodXN1YWxseSB0aGlzIGlzIHhocl9wb2xsaW5nOyBmb3IgdmVyeSBvbGRcblx0ICogICBicm93c2VycyB3aWxsIGJlIGpzb25wLCBmb3Igbm9kZSB3aWxsIGJlIGNvbWV0KS4gSWYgaXQgZG9lc24ndCB3b3JrLCB3ZVxuXHQgKiAgIHRyeSBmYWxsYmFjayBob3N0cy5cblx0ICogLSB1cGdyYWRlOiBnaXZlbiBhIGNvbm5lY3RlZCB0cmFuc3BvcnQsIHdlIHNlZSBpZiB0aGVyZSBhcmUgYW55IGJldHRlclxuXHQgKiAgIG9uZXMsIGFuZCBpZiBzbywgdHJ5IHRvIHVwZ3JhZGUgdG8gdGhlbS5cblx0ICpcblx0ICogY29ubmVjdEltcGwgd29ya3Mgb3V0IHdoYXQgc3RhZ2UgeW91J3JlIGF0ICh3aGljaCBpcyBwdXJlbHkgYSBmdW5jdGlvbiBvZlxuXHQgKiB0aGUgY3VycmVudCBjb25uZWN0aW9uIHN0YXRlIGFuZCB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgc3RvcmVkIHByZWZlcmVuY2VzKSxcblx0ICogYW5kIGRpc3BhdGNoZXMgYWNjb3JkaW5nbHkuIEFmdGVyIGEgdHJhbnNwb3J0IGhhcyBiZWVuIHNldCBwZW5kaW5nLFxuXHQgKiB0cnlBVHJhbnNwb3J0IGNhbGxzIGNvbm5lY3RJbXBsIHRvIHNlZSBpZiB0aGVyZSdzIGFub3RoZXIgc3RhZ2UgdG8gYmUgZG9uZS5cblx0ICogKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RJbXBsID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLnN0YXRlLnN0YXRlO1xuXG5cdFx0aWYoc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3Rpbmcuc3RhdGUgJiYgc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkge1xuXHRcdFx0LyogT25seSBrZWVwIHRyeWluZyBhcyBsb25nIGFzIGluIHRoZSAnY29ubmVjdGluZycgc3RhdGUgKG9yICdjb25uZWN0ZWQnXG5cdFx0XHQgKiBmb3IgdXBncmFkaW5nKS4gQW55IG9wZXJhdGlvbiBjYW4gcHV0IHVzIGludG8gJ2Rpc2Nvbm5lY3RlZCcgdG8gY2FuY2VsXG5cdFx0XHQgKiBjb25uZWN0aW9uIGF0dGVtcHRzIGFuZCB3YWl0IGJlZm9yZSByZXRyeWluZywgb3IgJ2ZhaWxlZCcgdG8gZmFpbC4gKi9cblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0IChvciBjb25uZWN0ZWQgdG8gdXBncmFkZSksIGJ1dCB3YXMgJyArIHN0YXRlKTtcblx0XHR9IGVsc2UgaWYodGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGgpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ1RyYW5zcG9ydHMgJyArIHRoaXMucGVuZGluZ1RyYW5zcG9ydHNbMF0udG9TdHJpbmcoKSArICcgY3VycmVudGx5IHBlbmRpbmc7IHRha2luZyBubyBhY3Rpb24nKTtcblx0XHR9IGVsc2UgaWYoc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG5cdFx0XHR0aGlzLnVwZ3JhZGVJZk5lZWRlZCh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLnRyYW5zcG9ydHMubGVuZ3RoID4gMSAmJiB0aGlzLmdldFRyYW5zcG9ydFByZWZlcmVuY2UoKSkge1xuXHRcdFx0dGhpcy5jb25uZWN0UHJlZmVyZW5jZSh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNvbm5lY3RCYXNlKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcblx0XHR9XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdFByZWZlcmVuY2UgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMpIHtcblx0XHR2YXIgcHJlZmVyZW5jZSA9IHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgPSBmYWxzZTtcblxuXHRcdGlmKCFfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluKHRoaXMudHJhbnNwb3J0cywgcHJlZmVyZW5jZSkpIHtcblx0XHRcdHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuXHRcdFx0dGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH1cblxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0UHJlZmVyZW5jZSgpJywgJ1RyeWluZyB0byBjb25uZWN0IHdpdGggc3RvcmVkIHRyYW5zcG9ydCBwcmVmZXJlbmNlICcgKyBwcmVmZXJlbmNlKTtcblxuXHRcdHZhciBwcmVmZXJlbmNlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuXHRcdFx0aWYoIShzZWxmLnN0YXRlLnN0YXRlID09PSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0UHJlZmVyZW5jZSgpJywgJ1Nob3J0Y2lyY3VpdCBjb25uZWN0aW9uIGF0dGVtcHQgd2l0aCAnICsgcHJlZmVyZW5jZSArICcgZmFpbGVkOyBjbGVhcmluZyBwcmVmZXJlbmNlIGFuZCB0cnlpbmcgZnJvbSBzY3JhdGNoJyk7XG5cdFx0XHRcdC8qIEFib3J0IGFsbCBjb25uZWN0aW9uIGF0dGVtcHRzLiAoVGhpcyBhbHNvIGRpc2Nvbm5lY3RzIHRoZSBhY3RpdmVcblx0XHRcdFx0ICogcHJvdG9jb2wsIGJ1dCBub25lIGV4aXN0cyBpZiB3ZSdyZSBub3QgaW4gdGhlIGNvbm5lY3RlZCBzdGF0ZSkgKi9cblx0XHRcdFx0c2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHQvKiBCZSBxdWl0ZSBhZ3Jlc3NpdmUgYWJvdXQgY2xlYXJpbmcgdGhlIHN0b3JlZCBwcmVmZXJlbmNlIGlmIGV2ZXIgaXQgZG9lc24ndCB3b3JrICovXG5cdFx0XHRcdHNlbGYudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQpO1xuXG5cdFx0LyogRm9yIGNvbm5lY3RQcmVmZXJlbmNlLCBqdXN0IHVzZSB0aGUgbWFpbiBob3N0LiBJZiBob3N0IGZhbGxiYWNrIGlzIG5lZWRlZCwgZG8gaXQgaW4gY29ubmVjdEJhc2UuXG5cdFx0ICogVGhlIHdzdHJhbnNwb3J0IGl0IHdpbGwgc3Vic3RpdHV0ZSB0aGUgaHR0cGhvc3QgZm9yIGFuIGFwcHJvcHJpYXRlIHdzaG9zdCAqL1xuXHRcdHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gc2VsZi5odHRwSG9zdHNbMF07XG5cdFx0c2VsZi50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgcHJlZmVyZW5jZSwgZnVuY3Rpb24oZmF0YWwsIHRyYW5zcG9ydCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHByZWZlcmVuY2VUaW1lb3V0KTtcblx0XHRcdGlmKHByZWZlcmVuY2VUaW1lb3V0RXhwaXJlZCAmJiB0cmFuc3BvcnQpIHtcblx0XHRcdFx0LyogVmlhYmxlLCBidXQgdG9vIGxhdGUgLSBjb25uZWN0SW1wbCgpIHdpbGwgYWxyZWFkeSBiZSB0cnlpbmdcblx0XHRcdFx0KiBjb25uZWN0QmFzZSwgYW5kIHdlIHdlcmVuJ3QgaW4gdXBncmFkZSBtb2RlLiBKdXN0IHJlbW92ZSB0aGVcblx0XHRcdFx0KiBvbmNvbm5lY3RlZCBsaXN0ZW5lciBhbmQgZ2V0IHJpZCBvZiBpdCAqL1xuXHRcdFx0XHR0cmFuc3BvcnQub2ZmKCk7XG5cdFx0XHRcdHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblx0XHRcdH0gZWxzZSBpZighdHJhbnNwb3J0ICYmICFmYXRhbCkge1xuXHRcdFx0XHQvKiBQcmVmZXJlbmNlIGZhaWxlZCBpbiBhIHRyYW5zcG9ydC1zcGVjaWZpYyB3YXkuIFRyeSBtb3JlICovXG5cdFx0XHRcdHNlbGYudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuXHRcdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHQvKiBJZiBzdWNlZWRlZCwgb3IgZmFpbGVkIGZhdGFsbHksIG5vdGhpbmcgdG8gZG8gKi9cblx0XHR9KTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBUcnkgdG8gZXN0YWJsaXNoIGEgdHJhbnNwb3J0IG9uIHRoZSBiYXNlIHRyYW5zcG9ydCAodGhlIGJlc3QgdHJhbnNwb3J0XG5cdCAqIHN1Y2ggdGhhdCBpZiBpdCBkb2Vzbid0IHdvcmssIG5vdGhpbmcgd2lsbCB3b3JrKSBhcyBkZXRlcm1pbmVkIHRocm91Z2hcblx0ICogc3RhdGljIGZlYXR1cmUgZGV0ZWN0aW9uLCBjaGVja2luZyBmb3IgbmV0d29yayBjb25uZWN0aXZpdHkgYW5kIHRyeWluZ1xuXHQgKiBmYWxsYmFjayBob3N0cyBpZiBhcHBsaWNhYmxlLlxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdEJhc2UgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdGdpdmVVcCA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRzZWxmLm5vdGlmeVN0YXRlKHtzdGF0ZTogc2VsZi5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUsIGVycm9yOiBlcnJ9KTtcblx0XHRcdH0sXG5cdFx0XHRjYW5kaWRhdGVIb3N0cyA9IHRoaXMuaHR0cEhvc3RzLnNsaWNlKCksXG5cdFx0XHRob3N0QXR0ZW1wdENiID0gZnVuY3Rpb24oZmF0YWwsIHRyYW5zcG9ydCkge1xuXHRcdFx0XHRpZihjb25uZWN0Q291bnQgIT09IHNlbGYuY29ubmVjdENvdW50ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcblx0XHRcdFx0XHR0cnlGYWxsYmFja0hvc3RzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEJhc2UoKScsICdUcnlpbmcgdG8gY29ubmVjdCB3aXRoIGJhc2UgdHJhbnNwb3J0ICcgKyB0aGlzLmJhc2VUcmFuc3BvcnQpO1xuXG5cdFx0LyogZmlyc3QgdHJ5IHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcHJpb3JpdHkgaG9zdCB3aXRoIGh0dHAgdHJhbnNwb3J0ICovXG5cdFx0dmFyIGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuXHRcdGlmKCFob3N0KSB7XG5cdFx0XHRnaXZlVXAobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1VuYWJsZSB0byBjb25uZWN0IChubyBhdmFpbGFibGUgaG9zdCknLCA4MDAwMywgNDA0KSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gaG9zdDtcblxuXHRcdC8qIHRoaXMgaXMgd2hhdCB3ZSdsbCBiZSBkb2luZyBpZiB0aGUgYXR0ZW1wdCBmb3IgdGhlIG1haW4gaG9zdCBmYWlscyAqL1xuXHRcdGZ1bmN0aW9uIHRyeUZhbGxiYWNrSG9zdHMoKSB7XG5cdFx0XHQvKiBpZiB0aGVyZSBhcmVuJ3QgYW55IGZhbGxiYWNrIGhvc3RzLCBmYWlsICovXG5cdFx0XHRpZighY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG5cdFx0XHRcdGdpdmVVcChuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVW5hYmxlIHRvIGNvbm5lY3QgKGFuZCBubyBtb3JlIGZhbGxiYWNrIGhvc3RzIHRvIHRyeSknLCA4MDAwMywgNDA0KSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIGJlZm9yZSB0cnlpbmcgYW55IGZhbGxiYWNrIChvciBhbnkgcmVtYWluaW5nIGZhbGxiYWNrKSB3ZSBkZWNpZGUgaWZcblx0XHRcdCAqIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBhYmx5IGhvc3QsIG9yIHRoZXJlIGlzIGEgZ2VuZXJhbCBjb25uZWN0aXZpdHlcblx0XHRcdCAqIHByb2JsZW0gKi9cblx0XHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlY2tDb25uZWN0aXZpdHkoZnVuY3Rpb24oZXJyLCBjb25uZWN0aXZpdHkpIHtcblx0XHRcdFx0aWYoY29ubmVjdENvdW50ICE9PSBzZWxmLmNvbm5lY3RDb3VudGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qIHdlIGtub3cgZXJyIHdvbid0IGhhcHBlbiBidXQgaGFuZGxlIGl0IGhlcmUgYW55d2F5ICovXG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGdpdmVVcChlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighY29ubmVjdGl2aXR5KSB7XG5cdFx0XHRcdFx0LyogdGhlIGludGVybmV0IGlzbid0IHJlYWNoYWJsZSwgc28gZG9uJ3QgdHJ5IHRoZSBmYWxsYmFjayBob3N0cyAqL1xuXHRcdFx0XHRcdGdpdmVVcChuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVW5hYmxlIHRvIGNvbm5lY3QgKG5ldHdvcmsgdW5yZWFjaGFibGUpJywgODAwMDMsIDQwNCkpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKiB0aGUgbmV0d29yayBpcyB0aGVyZSwgc28gdGhlcmUncyBhIHByb2JsZW0gd2l0aCB0aGUgbWFpbiBob3N0LCBvclxuXHRcdFx0XHQgKiBpdHMgZG5zLiBUcnkgdGhlIGZhbGxiYWNrIGhvc3RzLiBXZSBjb3VsZCB0cnkgdGhlbSBzaW11bHRhbmVvdXNseSBidXRcblx0XHRcdFx0ICogdGhhdCB3b3VsZCBwb3RlbnRpYWxseSBjYXVzZSBhIGh1Z2Ugc3Bpa2UgaW4gbG9hZCBvbiB0aGUgbG9hZCBiYWxhbmNlciAqL1xuXHRcdFx0XHR0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyUG9wUmFuZG9tRWxlbWVudChjYW5kaWRhdGVIb3N0cyk7XG5cdFx0XHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHNlbGYuYmFzZVRyYW5zcG9ydCwgaG9zdEF0dGVtcHRDYik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZih0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuXHRcdFx0dHJ5RmFsbGJhY2tIb3N0cygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHRoaXMuYmFzZVRyYW5zcG9ydCwgaG9zdEF0dGVtcHRDYik7XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VXBncmFkZVBvc3NpYmlsaXRpZXMgPSBmdW5jdGlvbigpIHtcblx0XHQvKiByZXR1cm5zIHRoZSBzdWJzZXQgb2YgdXBncmFkZVRyYW5zcG9ydHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XG5cdFx0ICogdHJhbnNwb3J0IGluIHVwZ3JhZGVUcmFuc3BvcnRzIChpZiBpdCdzIGluIHRoZXJlIC0gaWYgbm90LCBjdXJyZW50UG9zaXRpb25cblx0XHQgKiB3aWxsIGJlIC0xLCBzbyByZXR1cm4gdXBncmFkZVRyYW5zcG9ydHMuc2xpY2UoMCkgPT0gdXBncmFkZVRyYW5zcG9ydHMgKi9cblx0XHR2YXIgY3VycmVudCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuc2hvcnROYW1lO1xuXHRcdHZhciBjdXJyZW50UG9zaXRpb24gPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluZGV4T2YodGhpcy51cGdyYWRlVHJhbnNwb3J0cywgY3VycmVudCk7XG5cdFx0cmV0dXJuIHRoaXMudXBncmFkZVRyYW5zcG9ydHMuc2xpY2UoY3VycmVudFBvc2l0aW9uICsgMSk7XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudXBncmFkZUlmTmVlZGVkID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zKSB7XG5cdFx0dmFyIHVwZ3JhZGVQb3NzaWJpbGl0aWVzID0gdGhpcy5nZXRVcGdyYWRlUG9zc2liaWxpdGllcygpLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnVwZ3JhZGVJZk5lZWRlZCgpJywgJ3VwZ3JhZGUgcG9zc2liaWxpdGllczogJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdCh1cGdyYWRlUG9zc2liaWxpdGllcykpO1xuXG5cdFx0aWYoIXVwZ3JhZGVQb3NzaWJpbGl0aWVzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaCh1cGdyYWRlUG9zc2liaWxpdGllcywgZnVuY3Rpb24odXBncmFkZVRyYW5zcG9ydCkge1xuXHRcdFx0LyogTm90ZTogdGhlIHRyYW5zcG9ydCBtYXkgbXV0YXRlIHRoZSBwYXJhbXMsIHNvIGdpdmUgZWFjaCB0cmFuc3BvcnQgYSBmcmVzaCBvbmUgKi9cblx0XHRcdHZhciB1cGdyYWRlVHJhbnNwb3J0UGFyYW1zID0gc2VsZi5jcmVhdGVUcmFuc3BvcnRQYXJhbXModHJhbnNwb3J0UGFyYW1zLmhvc3QsICd1cGdyYWRlJyk7XG5cdFx0XHRzZWxmLnRyeUFUcmFuc3BvcnQodXBncmFkZVRyYW5zcG9ydFBhcmFtcywgdXBncmFkZVRyYW5zcG9ydCwgbm9vcCk7XG5cdFx0fSk7XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xvc2VJbXBsID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ2Nsb3NpbmcgY29ubmVjdGlvbicpO1xuXHRcdHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG5cdFx0dGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jbG9zaW5nKTtcblxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnQ2xvc2luZyBwZW5kaW5nIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRpZih0cmFuc3BvcnQpIHRyYW5zcG9ydC5jbG9zZSgpO1xuXHRcdH0pO1xuXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnRGlzcG9zaW5nIG9mIHByb3Bvc2VkIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRpZih0cmFuc3BvcnQpIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG5cdFx0fSk7XG5cblx0XHRpZih0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnQ2xvc2luZyBhY3RpdmUgdHJhbnNwb3J0OiAnICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSk7XG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmNsb3NlKCk7XG5cdFx0fVxuXG5cdFx0LyogSWYgdGhlcmUgd2FzIGFuIGFjdGl2ZSB0cmFuc3BvcnQsIHRoaXMgd2lsbCBwcm9iYWJseSBiZVxuXHRcdCAqIHByZWVtcHRlZCBieSB0aGUgbm90aWZ5U3RhdGUgY2FsbCBpbiBkZWFjdGl2YXRlVHJhbnNwb3J0ICovXG5cdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdjbG9zZWQnfSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbih0b2tlbkRldGFpbHMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHN3aXRjaCh0aGlzLnN0YXRlLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJywgJ1NlbmRpbmcgQVVUSCBtZXNzYWdlIG9uIGFjdGl2ZSB0cmFuc3BvcnQnKTtcblx0XHRcdFx0LyogSWYgdGhlcmUgYXJlIGFueSBwcm9wb3NlZC9wZW5kaW5nIHRyYW5zcG9ydHMgKGVnIGFuIHVwZ3JhZGUgdGhhdFxuXHRcdFx0XHQgKiBpc24ndCB5ZXQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uKSB0aGF0IGhhc24ndCB5ZXQgc3RhcnRlZCBzeW5jaW5nLFxuXHRcdFx0XHQgKiBqdXN0IHRvIGdldCByaWQgb2YgdGhlbSAmIHJlc3RhcnQgdGhlIHVwZ3JhZGUgd2l0aCB0aGUgbmV3IHRva2VuLCB0b1xuXHRcdFx0XHQgKiBhdm9pZCBhIHJhY2UgY29uZGl0aW9uLiAoSWYgaXQgaGFzIHN0YXJ0ZWQgc3luY2luZywgdGhlIEFVVEggd2lsbCBiZVxuXHRcdFx0XHQgKiBxdWV1ZWQgdW50aWwgdGhlIHVwZ3JhZGUgaXMgY29tcGxldGUsIHNvIGV2ZXJ5dGhpbmcncyBmaW5lKSAqL1xuXHRcdFx0XHRpZigodGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGggfHwgdGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMubGVuZ3RoKSAmJlxuXHRcdFx0XHRcdHNlbGYuc3RhdGUgIT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcblx0XHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKC8qIGV4Y2VwdEFjdGl2ZTogKi90cnVlKTtcblx0XHRcdFx0XHR2YXIgdHJhbnNwb3J0UGFyYW1zID0gdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5wYXJhbXM7XG5cdFx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBEbyBhbnkgdHJhbnNwb3J0LXNwZWNpZmljIG5ldy10b2tlbiBhY3Rpb24gKi9cblx0XHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscyk7XG5cblx0XHRcdFx0dmFyIGF1dGhNc2cgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0XHRcdFx0YWN0aW9uOiBhY3Rpb25zLkFVVEgsXG5cdFx0XHRcdFx0YXV0aDoge1xuXHRcdFx0XHRcdFx0YWNjZXNzVG9rZW46IHRva2VuRGV0YWlscy50b2tlblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuc2VuZChhdXRoTXNnKTtcblxuXHRcdFx0XHQvKiBUaGUgYW5zd2VyIHdpbGwgY29tZSBiYWNrIGFzIGVpdGhlciBhIGNvbm5lY3Rpb25kZXRhaWxzIGV2ZW50XG5cdFx0XHRcdCAqIChyZWFsdGltZSBzZW5kcyBhIENPTk5FQ1RFRCB0byBhc2tub3dsZWRnZSB0aGUgcmVhdXRoKSBvciBhXG5cdFx0XHRcdCAqIHN0YXRlY2hhbmdlIHRvIGZhaWxlZCAqL1xuXHRcdFx0XHR2YXIgc3VjY2Vzc0xpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR2YXIgZmFpbHVyZUxpc3RlbmVyID0gZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdFx0XHRpZihzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSAnZmFpbGVkJykge1xuXHRcdFx0XHRcdFx0c2VsZi5vZmYoc3VjY2Vzc0xpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHNlbGYub2ZmKGZhaWx1cmVMaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgc2VsZi5nZXRTdGF0ZUVycm9yKCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5vbmNlKCdjb25uZWN0aW9uZGV0YWlscycsIHN1Y2Nlc3NMaXN0ZW5lcik7XG5cdFx0XHRcdHRoaXMub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGZhaWx1cmVMaXN0ZW5lcik7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdjb25uZWN0aW5nJzpcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKScsXG5cdFx0XHRcdFx0J0Fib3J0aW5nIGN1cnJlbnQgY29ubmVjdGlvbiBhdHRlbXB0cyBpbiBvcmRlciB0byBzdGFydCBhZ2FpbiB3aXRoIHRoZSBuZXcgYXV0aCBkZXRhaWxzJyk7XG5cdFx0XHRcdHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcblx0XHRcdFx0LyogZmFsbHRocm91Z2ggdG8gYWRkIHN0YXRlY2hhbmdlIGxpc3RlbmVyICovXG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLFxuXHRcdFx0XHRcdCdDb25uZWN0aW9uIHN0YXRlIGlzICcgKyB0aGlzLnN0YXRlLnN0YXRlICsgJzsgd2FpdGluZyB1bnRpbCBlaXRoZXIgY29ubmVjdGVkIG9yIGZhaWxlZCcpO1xuXHRcdFx0XHR2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0XHRcdHN3aXRjaChzdGF0ZUNoYW5nZS5jdXJyZW50KSB7XG5cdFx0XHRcdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRcdFx0XHRzZWxmLm9mZihsaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XG5cdFx0XHRcdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRcdFx0XHRzZWxmLm9mZihsaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBzZWxmLmdldFN0YXRlRXJyb3IoKSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0LyogaWdub3JlIHRpbGwgd2UgZ2V0IGVpdGhlciBjb25uZWN0ZWQgb3IgZmFpbGVkICovXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0c2VsZi5vbignY29ubmVjdGlvbnN0YXRlJywgbGlzdGVuZXIpO1xuXHRcdFx0XHRpZih0aGlzLnN0YXRlLnN0YXRlID09PSAnY29ubmVjdGluZycpIHtcblx0XHRcdFx0XHQvKiBjYW4gaGFwcGVuIGlmIGluIHRoZSBjb25uZWN0aW5nIHN0YXRlIGJ1dCBubyB0cmFuc3BvcnQgd2FzIHBlbmRpbmdcblx0XHRcdFx0XHQgKiB5ZXQsIHNvIGRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzIGRpZCBub3QgdHJpZ2dlciBhIGRpc2Nvbm5lY3RlZCBzdGF0ZSAqL1xuXHRcdFx0XHRcdHNlbGYuc3RhcnRDb25uZWN0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZyd9KTtcblx0XHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMgPSBmdW5jdGlvbihleGNlcHRBY3RpdmUpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIGFsbCB0cmFuc3BvcnRzJyArIChleGNlcHRBY3RpdmUgPyAnIGV4Y2VwdCB0aGUgYWN0aXZlIHRyYW5zcG9ydCcgOiAnJykpO1xuXG5cdFx0LyogVGhpcyB3aWxsIHByZXZlbnQgYW55IGNvbm5lY3Rpb24gcHJvY2VkdXJlIGluIGFuIGFzeW5jIHBhcnQgb2Ygb25lIG9mIGl0cyBlYXJseSBzdGFnZXMgZnJvbSBjb250aW51aW5nICovXG5cdFx0dGhpcy5jb25uZWN0Q291bnRlcisrO1xuXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgcGVuZGluZyB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdH0pO1xuXHRcdHRoaXMucGVuZGluZ1RyYW5zcG9ydHMgPSBbXTtcblxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzcG9zaW5nIG9mIHByb3Bvc2VkIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRpZih0cmFuc3BvcnQpIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMgPSBbXTtcblxuXHRcdGlmKHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgIWV4Y2VwdEFjdGl2ZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0OiAnICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSk7XG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmRpc2Nvbm5lY3QoKTtcblx0XHR9XG5cdFx0LyogTm8gbmVlZCB0byBub3RpZnkgc3RhdGUgZGlzY29ubmVjdGVkOyBkaXNjb25uZWN0aW5nIHRoZSBhY3RpdmUgdHJhbnNwb3J0XG5cdFx0ICogd2lsbCBoYXZlIHRoYXQgZWZmZWN0ICovXG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKlxuXHQgKiBldmVudCBxdWV1ZWluZ1xuXHQgKioqKioqKioqKioqKioqKioqL1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obXNnLCBxdWV1ZUV2ZW50LCBjYWxsYmFjaykge1xuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG5cdFx0aWYoc3RhdGUuc2VuZEV2ZW50cykge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKScsICdzZW5kaW5nIGV2ZW50Jyk7XG5cdFx0XHR0aGlzLnNlbmRJbXBsKG5ldyBQZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBzaG91bGRRdWV1ZSA9IChxdWV1ZUV2ZW50ICYmIHN0YXRlLnF1ZXVlRXZlbnRzKSB8fCBzdGF0ZS5mb3JjZVF1ZXVlRXZlbnRzO1xuXHRcdGlmKCFzaG91bGRRdWV1ZSkge1xuXHRcdFx0dmFyIGVyciA9ICdyZWplY3RpbmcgZXZlbnQsIHF1ZXVlRXZlbnQgd2FzICcgKyBxdWV1ZUV2ZW50ICsgJywgc3RhdGUgd2FzICcgKyBzdGF0ZS5zdGF0ZTtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCBlcnIpO1xuXHRcdFx0Y2FsbGJhY2sodGhpcy5lcnJvclJlYXNvbiB8fCBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXShlcnIsIDkwMDAwLCA0MDApKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYoX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2hvdWxkTG9nKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTykpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCAncXVldWVpbmcgbXNnOyAnICsgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN0cmluZ2lmeShtc2cpKTtcblx0XHR9XG5cdFx0dGhpcy5xdWV1ZShtc2csIGNhbGxiYWNrKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZEltcGwgPSBmdW5jdGlvbihwZW5kaW5nTWVzc2FnZSkge1xuXHRcdHZhciBtc2cgPSBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlO1xuXHRcdC8qIElmIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gc2VuZCB0aGlzLCByZXNlbmQgd2l0aCB0aGUgc2FtZSBtc2dTZXJpYWwsXG5cdFx0ICogc28gQWJseSBjYW4gZGVkdXAgaWYgdGhlIHByZXZpb3VzIHNlbmQgc3VjY2VlZGVkICovXG5cdFx0aWYocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQgJiYgIXBlbmRpbmdNZXNzYWdlLnNlbmRBdHRlbXB0ZWQpIHtcblx0XHRcdG1zZy5tc2dTZXJpYWwgPSB0aGlzLm1zZ1NlcmlhbCsrO1xuXHRcdFx0dGhpcy5zZXRSZWNvdmVyeUtleSgpO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5zZW5kKHBlbmRpbmdNZXNzYWdlKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zZW5kSW1wbCgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGluIHRyYW5zcG9ydC5zZW5kKCk6ICcgKyBlLnN0YWNrKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gYnVuZGxlV2l0aChkZXN0LCBzcmMsIG1heFNpemUpIHtcblx0XHR2YXIgYWN0aW9uO1xuXHRcdGlmKGRlc3QuY2hhbm5lbCAhPT0gc3JjLmNoYW5uZWwpIHtcblx0XHRcdC8qIFJUTDZkMyAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZigoYWN0aW9uID0gZGVzdC5hY3Rpb24pICE9PSBhY3Rpb25zLlBSRVNFTkNFICYmIGFjdGlvbiAhPT0gYWN0aW9ucy5NRVNTQUdFKSB7XG5cdFx0XHQvKiBSVEw2ZCAtIGNhbiBvbmx5IGJ1bmRsZSBtZXNzYWdlcyBvciBwcmVzZW5jZSAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZihhY3Rpb24gIT09IHNyYy5hY3Rpb24pIHtcblx0XHRcdC8qIFJUTDZkNCAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR2YXIga2luZCA9IChhY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UpID8gJ3ByZXNlbmNlJyA6ICdtZXNzYWdlcycsXG5cdFx0XHRwcm9wb3NlZCA9IGRlc3Rba2luZF0uY29uY2F0KHNyY1traW5kXSksXG5cdFx0XHRzaXplID0gX3R5cGVzX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0TWVzc2FnZXNTaXplKHByb3Bvc2VkKTtcblx0XHRpZihzaXplID4gbWF4U2l6ZSkge1xuXHRcdFx0LyogUlRMNmQxICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmKCFfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFsbFNhbWUocHJvcG9zZWQsICdjbGllbnRJZCcpKSB7XG5cdFx0XHQvKiBSVEw2ZDIgKi9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYoIV91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRXZlcnkocHJvcG9zZWQsIGZ1bmN0aW9uKG1zZykge1xuXHRcdFx0cmV0dXJuICFtc2cuaWQ7XG5cdFx0fSkpIHtcblx0XHRcdC8qIFJUTDZkNyAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvKiB3ZSdyZSBnb29kIHRvIGdvISAqL1xuXHRcdGRlc3Rba2luZF0gPSBwcm9wb3NlZDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbihtc2csIGNhbGxiYWNrKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlKCknLCAncXVldWVpbmcgZXZlbnQnKTtcblx0XHR2YXIgbGFzdFF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMubGFzdCgpO1xuXHRcdHZhciBtYXhTaXplID0gdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuXHRcdC8qIElmIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gc2VuZCBhIG1lc3NhZ2UsIGRvbid0IG1lcmdlIG1vcmUgbWVzc2FnZXNcblx0XHQgKiBpbnRvIGl0LCBhcyBpZiB0aGUgcHJldmlvdXMgc2VuZCBhY3R1YWxseSBzdWNjZWVkZWQgYW5kIHJlYWx0aW1lIGlnbm9yZXNcblx0XHQgKiB0aGUgZHVwLCB0aGV5J2xsIGJlIGxvc3QgKi9cblx0XHRpZihsYXN0UXVldWVkICYmICFsYXN0UXVldWVkLnNlbmRBdHRlbXB0ZWQgJiYgYnVuZGxlV2l0aChsYXN0UXVldWVkLm1lc3NhZ2UsIG1zZywgbWF4U2l6ZSkpIHtcblx0XHRcdGlmKCFsYXN0UXVldWVkLm1lcmdlZCkge1xuXHRcdFx0XHRsYXN0UXVldWVkLmNhbGxiYWNrID0gT2JqZWN0KF91dGlsX211bHRpY2FzdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKShbbGFzdFF1ZXVlZC5jYWxsYmFja10pO1xuXHRcdFx0XHRsYXN0UXVldWVkLm1lcmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRsYXN0UXVldWVkLmNhbGxiYWNrLnB1c2goY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnF1ZXVlZE1lc3NhZ2VzLnB1c2gobmV3IFBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmRRdWV1ZWRNZXNzYWdlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kUXVldWVkTWVzc2FnZXMoKScsICdzZW5kaW5nICcgKyB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCkgKyAnIHF1ZXVlZCBtZXNzYWdlcycpO1xuXHRcdHZhciBwZW5kaW5nTWVzc2FnZTtcblx0XHR3aGlsZShwZW5kaW5nTWVzc2FnZSA9IHRoaXMucXVldWVkTWVzc2FnZXMuc2hpZnQoKSlcblx0XHRcdHRoaXMuc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5xdWV1ZVBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uKHBlbmRpbmdNZXNzYWdlcykge1xuXHRcdGlmKHBlbmRpbmdNZXNzYWdlcyAmJiBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIucXVldWVQZW5kaW5nTWVzc2FnZXMoKScsICdxdWV1ZWluZyAnICsgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCArICcgcGVuZGluZyBtZXNzYWdlcycpO1xuXHRcdFx0dGhpcy5xdWV1ZWRNZXNzYWdlcy5wcmVwZW5kKHBlbmRpbmdNZXNzYWdlcyk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5mYWlsUXVldWVkTWVzc2FnZXMgPSBmdW5jdGlvbihlcnIpIHtcblx0XHR2YXIgbnVtUXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpO1xuXHRcdGlmKG51bVF1ZXVlZCA+IDApIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5mYWlsUXVldWVkTWVzc2FnZXMoKScsICdmYWlsaW5nICcgKyBudW1RdWV1ZWQgKyAnIHF1ZXVlZCBtZXNzYWdlcywgZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0dGhpcy5xdWV1ZWRNZXNzYWdlcy5jb21wbGV0ZUFsbE1lc3NhZ2VzKGVycik7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbkNoYW5uZWxNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSwgdHJhbnNwb3J0KSB7XG5cdFx0dmFyIG9uQWN0aXZlVHJhbnNwb3J0ID0gdGhpcy5hY3RpdmVQcm90b2NvbCAmJiB0cmFuc3BvcnQgPT09IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCksXG5cdFx0XHRvblVwZ3JhZGVUcmFuc3BvcnQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCkgJiYgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nLFxuXHRcdFx0bm90Q29udHJvbE1zZyA9IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLk1FU1NBR0UgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0U7XG5cblx0XHQvKiBBcyB0aGUgbGliIG5vdyBoYXMgYSBwZXJpb2Qgd2hlcmUgdGhlIHVwZ3JhZGUgdHJhbnNwb3J0IGlzIHN5bmNlZCBidXRcblx0XHQgKiBiZWZvcmUgaXQncyBiZWNvbWUgYWN0aXZlICh3aGlsZSB3YWl0aW5nIGZvciB0aGUgb2xkIG9uZSB0byBiZWNvbWVcblx0XHQgKiBpZGxlKSwgbWVzc2FnZSBjYW4gdmFsaWRseSBhcnJpdmUgb24gaXQgZXZlbiB0aG91Z2ggaXQgaXNuJ3QgYWN0aXZlICovXG5cdFx0aWYob25BY3RpdmVUcmFuc3BvcnQgfHwgb25VcGdyYWRlVHJhbnNwb3J0KSB7XG5cdFx0XHRpZihub3RDb250cm9sTXNnKSB7XG5cdFx0XHRcdHZhciBzdXBwcmVzc2VkID0gdGhpcy5zZXRDb25uZWN0aW9uU2VyaWFsKG1lc3NhZ2UpO1xuXHRcdFx0XHRpZihzdXBwcmVzc2VkKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0R1cGxpY2F0ZShtZXNzYWdlLCB0aGlzLm1vc3RSZWNlbnRNc2cpKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBtZXNzYWdlIHdpdGggZGlmZmVyZW50IGNvbm5lY3Rpb25TZXJpYWwsIGJ1dCBzYW1lIG1lc3NhZ2UgaWQgYXMgYSBwcmV2aW91czsgZGlzY2FyZGluZzsgaWQgPSAnICsgbWVzc2FnZS5pZCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubW9zdFJlY2VudE1zZyA9IG1lc3NhZ2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIE1lc3NhZ2UgY2FtZSBpbiBvbiBhIGRlZnVuY3QgdHJhbnNwb3J0LiBBbGxvdyBvbmx5IGFja3MsIG5hY2tzLCAmIGVycm9ycyBmb3Igb3V0c3RhbmRpbmdcblx0XHRcdC8vIG1lc3NhZ2VzLCAgbm8gbmV3IG1lc3NhZ2VzIChhcyBzeW5jIGhhcyBiZWVuIHNlbnQgb24gbmV3IHRyYW5zcG9ydCBzbyBuZXcgbWVzc2FnZXMgd2lsbFxuXHRcdFx0Ly8gYmUgcmVzZW50IHRoZXJlLCBvciBjb25uZWN0aW9uIGhhcyBiZWVuIGNsb3NlZCBzbyBkb24ndCB3YW50IG5ldyBtZXNzYWdlcylcblx0XHRcdGlmKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZihbYWN0aW9ucy5BQ0ssIGFjdGlvbnMuTkFDSywgYWN0aW9ucy5FUlJPUl0sIG1lc3NhZ2UuYWN0aW9uKSA+IC0xKSB7XG5cdFx0XHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25DaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgbWVzc2FnZSAnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkgKyAnb24gZGVmdW5jdCB0cmFuc3BvcnQ7IGRpc2NhcmRpbmcnKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbih0cmFuc3BvcnQsIGNhbGxiYWNrKSB7XG5cdFx0LyogaWYgdHJhbnNwb3J0IGlzIHNwZWNpZmllZCwgdHJ5IHRoYXQgKi9cblx0XHRpZih0cmFuc3BvcnQpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5waW5nKCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cblx0XHRcdHZhciBvblRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRyYW5zcG9ydC5vZmYoJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0KTtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1RpbWVvdXQgd2FpdGluZyBmb3IgaGVhcnRiZWF0IHJlc3BvbnNlJywgNTAwMDAsIDUwMCkpO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHBpbmdTdGFydCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCksXG5cdFx0XHRcdGlkID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jaGVhcFJhbmRTdHIoKTtcblxuXHRcdFx0dmFyIG9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHJlc3BvbnNlSWQpIHtcblx0XHRcdFx0aWYocmVzcG9uc2VJZCA9PT0gaWQpIHtcblx0XHRcdFx0XHR0cmFuc3BvcnQub2ZmKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdCk7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0XHR2YXIgcmVzcG9uc2VUaW1lID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSAtIHBpbmdTdGFydDtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCByZXNwb25zZVRpbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgdGltZXIgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuXG5cdFx0XHR0cmFuc3BvcnQub24oJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0KTtcblx0XHRcdHRyYW5zcG9ydC5waW5nKGlkKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBpZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBkb24ndCBhdHRlbXB0ICovXG5cdFx0aWYodGhpcy5zdGF0ZS5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdVbmFibGUgdG8gcGluZyBzZXJ2aWNlOyBub3QgY29ubmVjdGVkJywgNDAwMDAsIDQwMCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIG5vIHRyYW5zcG9ydCB3YXMgc3BlY2lmaWVkLCBzbyB1c2UgdGhlIGN1cnJlbnQgKGNvbm5lY3RlZCkgb25lXG5cdFx0ICogYnV0IGVuc3VyZSB0aGF0IHdlIHJldHJ5IGlmIHRoZSB0cmFuc3BvcnQgaXMgc3VwZXJzZWRlZCBiZWZvcmUgd2UgY29tcGxldGUgKi9cblx0XHR2YXIgY29tcGxldGVkID0gZmFsc2UsIHNlbGYgPSB0aGlzO1xuXG5cdFx0dmFyIG9uUGluZ0NvbXBsZXRlID0gZnVuY3Rpb24oZXJyLCByZXNwb25zZVRpbWUpIHtcblx0XHRcdHNlbGYub2ZmKCd0cmFuc3BvcnQuYWN0aXZlJywgb25UcmFuc3BvcnRBY3RpdmUpO1xuXHRcdFx0aWYoIWNvbXBsZXRlZCkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0XHRjYWxsYmFjayhlcnIsIHJlc3BvbnNlVGltZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBvblRyYW5zcG9ydEFjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoIWNvbXBsZXRlZCkge1xuXHRcdFx0XHQvKiBlbnN1cmUgdGhhdCBubyBjYWxsYmFjayBoYXBwZW5zIGZvciB0aGUgY3VycmVudGx5IG91dHN0YW5kaW5nIG9wZXJhdGlvbiAqL1xuXHRcdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0XHQvKiByZXBlYXQgYnV0IHBpY2tpbmcgdXAgdGhlIG5ldyB0cmFuc3BvcnQgKi9cblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLnBpbmcobnVsbCwgY2FsbGJhY2spO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5vbigndHJhbnNwb3J0LmFjdGl2ZScsIG9uVHJhbnNwb3J0QWN0aXZlKTtcblx0XHR0aGlzLnBpbmcodGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSwgb25QaW5nQ29tcGxldGUpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5mYWlsKGVycm9yKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJQcm9wb3NlZFRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgfHwgKGhhdmVXZWJTdG9yYWdlICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0KHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0aWYoX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbihfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnVwZ3JhZGVUcmFuc3BvcnRzLCB0cmFuc3BvcnQuc2hvcnROYW1lKSkge1xuXHRcdFx0dGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gdHJhbnNwb3J0LnNob3J0TmFtZTtcblx0XHRcdGlmKGhhdmVXZWJTdG9yYWdlKSB7XG5cdFx0XHRcdHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2V0KHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lLCB0cmFuc3BvcnQuc2hvcnROYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuXHRcdGlmKGhhdmVXZWJTdG9yYWdlKSB7XG5cdFx0XHRwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJlbW92ZSh0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBkdXJpbmcgY29ubmVjdGlvbiBhdHRlbXB0cywgc28gaW1wbGVtZW50cyBSU0E0YzEsXG5cdCAqIFJTQTRjMiwgYW5kIFJTQTRkLiBJbiBwYXJ0aWN1bGFyIGl0IGlzIG5vdCBpbnZva2VkIGZvclxuXHQgKiBzZXJ2ZXJzaWRlLXRyaWdnZXJlZCByZWF1dGhzIG9yIG1hbnVhbCByZWF1dGhzLCBzbyBSU0E0YzMgZG9lcyBub3QgYXBwbHkgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0aWYoZXJyLmNvZGUgPT09IDQwMTcxKSB7XG5cdFx0XHQvKiBObyB3YXkgdG8gcmVhdXRoICovXG5cdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiBlcnJ9KTtcblx0XHR9IGVsc2UgaWYoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xuXHRcdFx0dmFyIG1zZyA9ICdDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXR1cm5lZCA0MDM7IGZhaWxpbmcgdGhlIGNvbm5lY3Rpb24nO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKCknLCBtc2cpO1xuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA4MDAxOSwgNDAzLCBlcnIpfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBtc2cgPSAnQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmVxdWVzdCBmYWlsZWQnO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplJywgbXNnKTtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiB0aGlzLnN0YXRlLmZhaWxTdGF0ZSwgZXJyb3I6IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKG1zZywgODAwMTksIDQwMSwgZXJyKX0pO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpIHtcblx0XHRpZighY29ubmVjdGlvbkRldGFpbHMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IGNvbm5lY3Rpb25EZXRhaWxzO1xuXHRcdGlmKGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemUgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZTtcblx0XHR9XG5cdFx0dmFyIGNsaWVudElkID0gY29ubmVjdGlvbkRldGFpbHMuY2xpZW50SWQ7XG5cdFx0aWYoY2xpZW50SWQpIHtcblx0XHRcdHZhciBlcnIgPSB0aGlzLnJlYWx0aW1lLmF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSgpJywgZXJyLm1lc3NhZ2UpO1xuXHRcdFx0XHQvKiBFcnJvcnMgc2V0dGluZyB0aGUgY2xpZW50SWQgYXJlIGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXG5cdFx0XHRcdHRyYW5zcG9ydC5mYWlsKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcblx0XHRpZihjb25uZWN0aW9uU3RhdGVUdGwpIHtcblx0XHRcdHRoaXMuY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvblN0YXRlVHRsO1xuXHRcdH1cblx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcblx0XHR0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25kZXRhaWxzJywgY29ubmVjdGlvbkRldGFpbHMpO1xuXHR9O1xuXG5cdHJldHVybiBDb25uZWN0aW9uTWFuYWdlcjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29ubmVjdGlvbk1hbmFnZXIpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpKVxuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG5cbnZhciBNZXNzYWdlUXVldWUgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIE1lc3NhZ2VRdWV1ZSgpIHtcblx0XHRfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMubWVzc2FnZXMgPSBbXTtcblx0fVxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKE1lc3NhZ2VRdWV1ZSwgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZXMuc2hpZnQoKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlc1t0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29weUFsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VzLnNsaWNlKCk7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihtZXNzYWdlcykge1xuXHRcdHRoaXMubWVzc2FnZXMucHVzaC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcblx0XHR0aGlzLm1lc3NhZ2VzLnVuc2hpZnQuYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29tcGxldGVNZXNzYWdlcyA9IGZ1bmN0aW9uKHNlcmlhbCwgY291bnQsIGVycikge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdNZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCk7XG5cdFx0ZXJyID0gZXJyIHx8IG51bGw7XG5cdFx0dmFyIG1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcztcblx0XHR2YXIgZmlyc3QgPSBtZXNzYWdlc1swXTtcblx0XHRpZihmaXJzdCkge1xuXHRcdFx0dmFyIHN0YXJ0U2VyaWFsID0gZmlyc3QubWVzc2FnZS5tc2dTZXJpYWw7XG5cdFx0XHR2YXIgZW5kU2VyaWFsID0gc2VyaWFsICsgY291bnQ7IC8qIHRoZSBzZXJpYWwgb2YgdGhlIGZpcnN0IG1lc3NhZ2UgdGhhdCBpcyAqbm90KiB0aGUgc3ViamVjdCBvZiB0aGlzIGNhbGwgKi9cblx0XHRcdGlmKGVuZFNlcmlhbCA+IHN0YXJ0U2VyaWFsKSB7XG5cdFx0XHRcdHZhciBjb21wbGV0ZU1lc3NhZ2VzID0gbWVzc2FnZXMuc3BsaWNlKDAsIChlbmRTZXJpYWwgLSBzdGFydFNlcmlhbCkpO1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY29tcGxldGVNZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbXBsZXRlTWVzc2FnZXNbaV0uY2FsbGJhY2soZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYobWVzc2FnZXMubGVuZ3RoID09IDApXG5cdFx0XHRcdHRoaXMuZW1pdCgnaWRsZScpO1xuXHRcdH1cblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmNvbXBsZXRlQWxsTWVzc2FnZXMgPSBmdW5jdGlvbihlcnIpIHtcblx0XHR0aGlzLmNvbXBsZXRlTWVzc2FnZXMoMCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTnVtYmVyLk1BWF9WQUxVRSwgZXJyKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ01lc3NhZ2VRdWV1ZS5jbGVhcigpJywgJ2NsZWFyaW5nICcgKyB0aGlzLm1lc3NhZ2VzLmxlbmd0aCArICcgbWVzc2FnZXMnKTtcblx0XHR0aGlzLm1lc3NhZ2VzID0gW107XG5cdFx0dGhpcy5lbWl0KCdpZGxlJyk7XG5cdH07XG5cblx0cmV0dXJuIE1lc3NhZ2VRdWV1ZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTWVzc2FnZVF1ZXVlKTtcblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZG9tZXZlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG5cblxuXG5cblxuXG5cblxuXG52YXIgWEhSUmVxdWVzdCA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHR2YXIgaWRDb3VudGVyID0gMDtcblx0dmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHt9O1xuXG5cdHZhciBSRVFfU0VORCA9IDAsXG5cdFx0UkVRX1JFQ1YgPSAxLFxuXHRcdFJFUV9SRUNWX1BPTEwgPSAyLFxuXHRcdFJFUV9SRUNWX1NUUkVBTSA9IDM7XG5cblx0ZnVuY3Rpb24gY2xlYXJQZW5kaW5nUmVxdWVzdHMoKSB7XG5cdFx0Zm9yKHZhciBpZCBpbiBwZW5kaW5nUmVxdWVzdHMpXG5cdFx0XHRwZW5kaW5nUmVxdWVzdHNbaWRdLmRpc3Bvc2UoKTtcblx0fVxuXG5cdHZhciBpc0lFID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLlhEb21haW5SZXF1ZXN0O1xuXG5cdGZ1bmN0aW9uIGllVmVyc2lvbigpIHtcblx0XHR2YXIgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvU3RyaW5nKCkubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKTtcblx0XHRyZXR1cm4gbWF0Y2ggJiYgTnVtYmVyKG1hdGNoWzFdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5lZWRKc29uRW52ZWxvcGUoKSB7XG5cdFx0LyogSUUgMTAgeGhyIGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYzMjAzMzkgKi9cblx0XHR2YXIgdmVyc2lvbjtcblx0XHRyZXR1cm4gaXNJRSAmJiAodmVyc2lvbiA9IGllVmVyc2lvbigpKSAmJiB2ZXJzaW9uID09PSAxMDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEhlYWRlcih4aHIsIGhlYWRlcikge1xuXHRcdHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgeGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG5cdH1cblxuXHQvKiBTYWZhcmkgbXlzdGVyaW91c2x5IHJldHVybnMgJ0lkZW50aXR5JyBmb3IgdHJhbnNmZXItZW5jb2Rpbmcgd2hlbiBpbiBmYWN0XG5cdCAqIGl0IGlzICdjaHVua2VkJy4gU28gaW5zdGVhZCwgZGVjaWRlIHRoYXQgaXQgaXMgY2h1bmtlZCB3aGVuXG5cdCAqIHRyYW5zZmVyLWVuY29kaW5nIGlzIHByZXNlbnQgb3IgY29udGVudC1sZW5ndGggaXMgYWJzZW50LiAgKCdvcicgYmVjYXVzZVxuXHQgKiB3aGVuIHVzaW5nIGh0dHAyIHN0cmVhbWluZywgdGhlcmUncyBubyB0cmFuc2Zlci1lbmNvZGluZyBoZWFkZXIsIGJ1dCBjYW5cblx0ICogc3RpbGwgZGVkdWNlIHN0cmVhbWluZyBmcm9tIGxhY2sgb2YgY29udGVudC1sZW5ndGgpICovXG5cdGZ1bmN0aW9uIGlzRW5jb2RpbmdDaHVua2VkKHhocikge1xuXHRcdHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXJcblx0XHRcdCYmICh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJylcblx0XHRcdHx8ICF4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SGVhZGVyc0FzT2JqZWN0KHhocikge1xuXHRcdHZhciBoZWFkZXJQYWlycyA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50cmltKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkuc3BsaXQoJ1xcclxcbicpLFxuXHRcdFx0aGVhZGVycyA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyUGFpcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0cyA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJNYXAoaGVhZGVyUGFpcnNbaV0uc3BsaXQoJzonKSwgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRyaW0pO1xuXHRcdFx0aGVhZGVyc1twYXJ0c1swXS50b0xvd2VyQ2FzZSgpXSA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHRyZXR1cm4gaGVhZGVycztcblx0fVxuXG5cdGZ1bmN0aW9uIFhIUlJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG5cdFx0X2NvbW1vbl9saWJfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblx0XHRwYXJhbXMucm5kID0gX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNoZWFwUmFuZFN0cigpO1xuXHRcdGlmKG5lZWRKc29uRW52ZWxvcGUoKSAmJiAhcGFyYW1zLmVudmVsb3BlKVxuXHRcdFx0cGFyYW1zLmVudmVsb3BlID0gJ2pzb24nO1xuXHRcdHRoaXMudXJpID0gdXJpICsgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvUXVlcnlTdHJpbmcocGFyYW1zKTtcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuXHRcdHRoaXMuYm9keSA9IGJvZHk7XG5cdFx0dGhpcy5tZXRob2QgPSBtZXRob2QgPyBtZXRob2QudG9VcHBlckNhc2UoKSA6IChfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhib2R5KSA/ICdHRVQnIDogJ1BPU1QnKTtcblx0XHR0aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG5cdFx0dGhpcy50aW1lb3V0cyA9IHRpbWVvdXRzO1xuXHRcdHRoaXMudGltZWRPdXQgPSBmYWxzZTtcblx0XHR0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdHBlbmRpbmdSZXF1ZXN0c1t0aGlzLmlkID0gU3RyaW5nKCsraWRDb3VudGVyKV0gPSB0aGlzO1xuXHR9XG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhYSFJSZXF1ZXN0LCBfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHR2YXIgY3JlYXRlUmVxdWVzdCA9IFhIUlJlcXVlc3QuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuXHRcdC8qIFhIUiByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG5cdFx0ICogdHJhbnNwb3J0LCBvciB3aXRoIHRpbWVvdXRzIHBhc3NlZCBpbiAoZm9yIHdoZW4gdXNlZCBieSBhIHJlc3QgY2xpZW50KSxcblx0XHQgKiBvciBjb21wbGV0ZWx5IHN0YW5kYWxvbmUuICBVc2UgdGhlIGFwcHJvcHJpYXRlIHRpbWVvdXRzIGluIGVhY2ggY2FzZSAqL1xuXHRcdHRpbWVvdXRzID0gdGltZW91dHMgfHwgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRJTUVPVVRTO1xuXHRcdHJldHVybiBuZXcgWEhSUmVxdWVzdCh1cmksIGhlYWRlcnMsIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jb3B5KHBhcmFtcyksIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKTtcblx0fTtcblxuXHRYSFJSZXF1ZXN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRpZighdGhpcy5yZXF1ZXN0Q29tcGxldGUpIHtcblx0XHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdGlmKCFlcnIgJiYgYm9keSkge1xuXHRcdFx0XHR0aGlzLmVtaXQoJ2RhdGEnLCBib2R5KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZW1pdCgnY29tcGxldGUnLCBlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXHRcdH1cblx0fTtcblxuXHRYSFJSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGlzcG9zZSgpO1xuXHR9O1xuXG5cdFhIUlJlcXVlc3QucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGltZW91dCA9ICh0aGlzLnJlcXVlc3RNb2RlID09IFJFUV9TRU5EKSA/IHRoaXMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogdGhpcy50aW1lb3V0cy5yZWN2VGltZW91dCxcblx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0dGltZXIgPSB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi50aW1lZE91dCA9IHRydWU7XG5cdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0fSwgdGltZW91dCksXG5cdFx0XHRib2R5ID0gdGhpcy5ib2R5LFxuXHRcdFx0bWV0aG9kID0gdGhpcy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzID0gdGhpcy5oZWFkZXJzLFxuXHRcdFx0eGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcblx0XHRcdGFjY2VwdCA9IGhlYWRlcnNbJ2FjY2VwdCddLFxuXHRcdFx0cmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuXG5cdFx0aWYoIWFjY2VwdCkge1xuXHRcdFx0aGVhZGVyc1snYWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbic7XG5cdFx0fSBlbHNlIGlmKGFjY2VwdC5pbmRleE9mKCdhcHBsaWNhdGlvbi94LW1zZ3BhY2snKSA9PT0gMCkge1xuXHRcdFx0cmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0XHR9XG5cblx0XHRpZihib2R5KSB7XG5cdFx0XHR2YXIgY29udGVudFR5cGUgPSBoZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAoaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdFx0aWYoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEgJiYgdHlwZW9mKGJvZHkpICE9ICdzdHJpbmcnKVxuXHRcdFx0XHRib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdFx0fVxuXG5cdFx0eGhyLm9wZW4obWV0aG9kLCB0aGlzLnVyaSwgdHJ1ZSk7XG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcblxuXHRcdGlmICgnYXV0aG9yaXphdGlvbicgaW4gaGVhZGVycykge1xuXHRcdFx0eGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Zm9yKHZhciBoIGluIGhlYWRlcnMpXG5cdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihoLCBoZWFkZXJzW2hdKTtcblxuXHRcdHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnJvckV2ZW50LCBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHR2YXIgZXJyb3JNZXNzYWdlID0gbWVzc2FnZSArICcgKGV2ZW50IHR5cGU6ICcgKyBlcnJvckV2ZW50LnR5cGUgKyAnKScgKyAoc2VsZi54aHIuc3RhdHVzVGV4dCA/ICcsIGN1cnJlbnQgc3RhdHVzVGV4dCBpcyAnICsgc2VsZi54aHIuc3RhdHVzVGV4dCA6ICcnKTtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnUmVxdWVzdC5vbicgKyBlcnJvckV2ZW50LnR5cGUgKyAnKCknLCBlcnJvck1lc3NhZ2UpO1xuXHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0oZXJyb3JNZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSk7XG5cdFx0fTtcblx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uKGVycm9yRXZlbnQpIHtcblx0XHRcdGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnWEhSIGVycm9yIG9jY3VycmVkJywgbnVsbCwgNDAwKTtcblx0XHR9XG5cdFx0eGhyLm9uYWJvcnQgPSBmdW5jdGlvbihlcnJvckV2ZW50KSB7XG5cdFx0XHRpZihzZWxmLnRpbWVkT3V0KSB7XG5cdFx0XHRcdGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnUmVxdWVzdCBhYm9ydGVkIGR1ZSB0byByZXF1ZXN0IHRpbWVvdXQgZXhwaXJpbmcnLCBudWxsLCA0MDgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IGNhbmNlbGxlZCcsIG51bGwsIDQwMCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oZXJyb3JFdmVudCkge1xuXHRcdFx0ZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IHRpbWVkIG91dCcsIG51bGwsIDQwOCk7XG5cdFx0fTtcblxuXHRcdHZhciBzdHJlYW1pbmcsXG5cdFx0XHRzdGF0dXNDb2RlLFxuXHRcdFx0cmVzcG9uc2VCb2R5LFxuXHRcdFx0Y29udGVudFR5cGUsXG5cdFx0XHRzdWNjZXNzUmVzcG9uc2UsXG5cdFx0XHRzdHJlYW1Qb3MgPSAwLFxuXHRcdFx0dW5wYWNrZWQgPSBmYWxzZTtcblxuXHRcdGZ1bmN0aW9uIG9uUmVzcG9uc2UoKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0c3VjY2Vzc1Jlc3BvbnNlID0gKHN0YXR1c0NvZGUgPCA0MDApO1xuXHRcdFx0aWYoc3RhdHVzQ29kZSA9PSAyMDQpIHtcblx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBudWxsLCBzdGF0dXNDb2RlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c3RyZWFtaW5nID0gKHNlbGYucmVxdWVzdE1vZGUgPT0gUkVRX1JFQ1ZfU1RSRUFNICYmIHN1Y2Nlc3NSZXNwb25zZSAmJiBpc0VuY29kaW5nQ2h1bmtlZCh4aHIpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkVuZCgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBjb250ZW50VHlwZSA9IGdldEhlYWRlcih4aHIsICdjb250ZW50LXR5cGUnKSxcblx0XHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRcdHJlc3BvbnNlQm9keSxcblx0XHRcdFx0XHQvKiBCZSBsaWJlcmFsIGluIHdoYXQgd2UgYWNjZXB0OyBidWdneSBhdXRoIHNlcnZlcnMgbWF5IHJlc3BvbmRcblx0XHRcdFx0XHQgKiB3aXRob3V0IHRoZSBjb3JyZWN0IGNvbnRlbnR0eXBlLCBidXQgYXNzdW1lIHRoZXkncmUgc3RpbGxcblx0XHRcdFx0XHQgKiByZXNwb25kaW5nIHdpdGgganNvbiAqL1xuXHRcdFx0XHRcdGpzb24gPSBjb250ZW50VHlwZSA/IChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPj0gMCkgOiAoeGhyLnJlc3BvbnNlVHlwZSA9PSAndGV4dCcpO1xuXG5cdFx0XHRcdGlmKGpzb24pIHtcblx0XHRcdFx0XHQvKiBJZiB3ZSByZXF1ZXN0ZWQgbXNncGFjayBidXQgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGpzb24sIHRoZW4gc2luY2Vcblx0XHRcdFx0XHQgKiB3ZSBzZXQgdGhlIHJlc3BvbnNlVHlwZSBleHBlY3RpbmcgbXNncGFjaywgdGhlIHJlc3BvbnNlIHdpbGwgYmVcblx0XHRcdFx0XHQgKiBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIGpzb24gKi9cblx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykgPyBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnV0ZjhEZWNvZGUoeGhyLnJlc3BvbnNlKSA6IFN0cmluZyh4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0XHRpZihyZXNwb25zZUJvZHkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlQm9keSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHVucGFja2VkID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSB4aHIucmVzcG9uc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihyZXNwb25zZUJvZHkucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8qIHVud3JhcCBKU09OIGVudmVsb3BlICovXG5cdFx0XHRcdFx0c3RhdHVzQ29kZSA9IHJlc3BvbnNlQm9keS5zdGF0dXNDb2RlO1xuXHRcdFx0XHRcdHN1Y2Nlc3NSZXNwb25zZSA9IChzdGF0dXNDb2RlIDwgNDAwKTtcblx0XHRcdFx0XHRoZWFkZXJzID0gcmVzcG9uc2VCb2R5LmhlYWRlcnM7XG5cdFx0XHRcdFx0cmVzcG9uc2VCb2R5ID0gcmVzcG9uc2VCb2R5LnJlc3BvbnNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhlYWRlcnMgPSBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHNlbGYuY29tcGxldGUobmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogJyArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxuXHRcdFx0ICogaXMgY29udGFpbnMgYW4gZXJyb3IgYWN0aW9uIChoZW5jZSB0aGUgbm9uc3VjY2VzcyBzdGF0dXNjb2RlKSwgd2UgY2FuXG5cdFx0XHQgKiBjb25zaWRlciB0aGUgcmVxdWVzdCB0byBoYXZlIHN1Y2NlZWRlZCwganVzdCBwYXNzIGl0IG9uIHRvXG5cdFx0XHQgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xuXHRcdFx0aWYoc3VjY2Vzc1Jlc3BvbnNlIHx8IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KHJlc3BvbnNlQm9keSkpIHtcblx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXJyID0gcmVzcG9uc2VCb2R5LmVycm9yICYmIF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMocmVzcG9uc2VCb2R5LmVycm9yKTtcblx0XHRcdGlmKCFlcnIpIHtcblx0XHRcdFx0ZXJyID0gbmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogJyArIHN0YXR1c0NvZGUgKyAnIGJvZHkgd2FzOiAnICsgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3QocmVzcG9uc2VCb2R5KSwgbnVsbCwgc3RhdHVzQ29kZSk7XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmNvbXBsZXRlKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Qcm9ncmVzcygpIHtcblx0XHRcdHJlc3BvbnNlQm9keSA9IHhoci5yZXNwb25zZVRleHQ7XG5cdFx0XHR2YXIgYm9keUVuZCA9IHJlc3BvbnNlQm9keS5sZW5ndGggLSAxLCBpZHgsIGNodW5rO1xuXHRcdFx0d2hpbGUoKHN0cmVhbVBvcyA8IGJvZHlFbmQpICYmIChpZHggPSByZXNwb25zZUJvZHkuaW5kZXhPZignXFxuJywgc3RyZWFtUG9zKSkgPiAtMSkge1xuXHRcdFx0XHRjaHVuayA9IHJlc3BvbnNlQm9keS5zbGljZShzdHJlYW1Qb3MsIGlkeCk7XG5cdFx0XHRcdHN0cmVhbVBvcyA9IGlkeCArIDE7XG5cdFx0XHRcdG9uQ2h1bmsoY2h1bmspO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uQ2h1bmsoY2h1bmspIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNodW5rID0gSlNPTi5wYXJzZShjaHVuayk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ01hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiAnICsgZS5tZXNzYWdlLCBudWxsLCA0MDApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5lbWl0KCdkYXRhJywgY2h1bmspO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uU3RyZWFtRW5kKCkge1xuXHRcdFx0b25Qcm9ncmVzcygpO1xuXHRcdFx0c2VsZi5zdHJlYW1Db21wbGV0ZSA9IHRydWU7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuY29tcGxldGUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG5cdFx0XHRpZihyZWFkeVN0YXRlIDwgMykgcmV0dXJuO1xuXHRcdFx0aWYoeGhyLnN0YXR1cyAhPT0gMCkge1xuXHRcdFx0XHRpZihzdGF0dXNDb2RlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzdGF0dXNDb2RlID0geGhyLnN0YXR1cztcblx0XHRcdFx0XHQvKiBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MCAqL1xuXHRcdFx0XHRcdGlmKHN0YXR1c0NvZGUgPT09IDEyMjMpIHN0YXR1c0NvZGUgPSAyMDQ7XG5cdFx0XHRcdFx0b25SZXNwb25zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHJlYWR5U3RhdGUgPT0gMyAmJiBzdHJlYW1pbmcpIHtcblx0XHRcdFx0XHRvblByb2dyZXNzKCk7XG5cdFx0XHRcdH0gZWxzZSBpZihyZWFkeVN0YXRlID09IDQpIHtcblx0XHRcdFx0XHRpZihzdHJlYW1pbmcpXG5cdFx0XHRcdFx0XHRvblN0cmVhbUVuZCgpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdG9uRW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5zZW5kKGJvZHkpO1xuXHR9O1xuXG5cdFhIUlJlcXVlc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgeGhyID0gdGhpcy54aHI7XG5cdFx0aWYoeGhyKSB7XG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0geGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPSBub29wO1xuXHRcdFx0dGhpcy54aHIgPSBudWxsO1xuXHRcdFx0dmFyIHRpbWVyID0gdGhpcy50aW1lcjtcblx0XHRcdGlmKHRpbWVyKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHRcdHRoaXMudGltZXIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRoaXMucmVxdWVzdENvbXBsZXRlKVxuXHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHR9XG5cdFx0ZGVsZXRlIHBlbmRpbmdSZXF1ZXN0c1t0aGlzLmlkXTtcblx0fTtcblxuXHRpZihwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnhoclN1cHBvcnRlZCkge1xuXHRcdGlmKHR5cGVvZiBfdXRpbF9kb21ldmVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0X3V0aWxfZG9tZXZlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hZGRVbmxvYWRMaXN0ZW5lcihjbGVhclBlbmRpbmdSZXF1ZXN0cyk7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZihwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0pICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuXHRcdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgcmVxID0gY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgUkVRX1NFTkQsIHJlc3QgJiYgcmVzdC5vcHRpb25zLnRpbWVvdXRzLCBtZXRob2QpO1xuXHRcdFx0XHRyZXEub25jZSgnY29tcGxldGUnLCBjYWxsYmFjayk7XG5cdFx0XHRcdHJlcS5leGVjKCk7XG5cdFx0XHRcdHJldHVybiByZXE7XG5cdFx0XHR9O1xuXG5cdFx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgdXBVcmwgPSBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW50ZXJuZXRVcFVybDtcblx0XHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICcoWEhSUmVxdWVzdClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIHVwVXJsKTtcblx0XHRcdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFVyaShudWxsLCB1cFVybCwgbnVsbCwgbnVsbCwgZnVuY3Rpb24oZXJyLCByZXNwb25zZVRleHQpIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gKCFlcnIgJiYgcmVzcG9uc2VUZXh0LnJlcGxhY2UoL1xcbi8sICcnKSA9PSAneWVzJyk7XG5cdFx0XHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICcoWEhSUmVxdWVzdClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnUmVzdWx0OiAnICsgcmVzdWx0KTtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFhIUlJlcXVlc3Q7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFhIUlJlcXVlc3QpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpKVxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMiksIF9fd2VicGFja19yZXF1aXJlX18oMTApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxNyksIF9fd2VicGFja19yZXF1aXJlX18oMzcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOSksIF9fd2VicGFja19yZXF1aXJlX18oMzApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NCksIF9fd2VicGFja19yZXF1aXJlX18oNDUpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhNQUMgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hY0hhc2hlciA9IENyeXB0b0pTLmFsZ28uSE1BQy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5TSEEyNTYsIGtleSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhhc2hlciwga2V5KSB7XG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFV0ZjgucGFyc2Uoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcblx0ICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIGtleS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcblx0ICAgICAgICAgICAgdmFyIG9LZXkgPSB0aGlzLl9vS2V5ID0ga2V5LmNsb25lKCk7XG5cdCAgICAgICAgICAgIHZhciBpS2V5ID0gdGhpcy5faUtleSA9IGtleS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVyQmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9LZXlXb3Jkc1tpXSBePSAweDVjNWM1YzVjO1xuXHQgICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb0tleS5zaWdCeXRlcyA9IGlLZXkuc2lnQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldFxuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SE1BQ30gVGhpcyBITUFDIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgSE1BQyBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBITUFDXG5cdCAgICAgICAgICAgIHZhciBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBobWFjO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOSkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGNvbmZvcm0gd2l0aCBFVlBfQnl0ZXNUb0tleS5cblx0ICAgICAqIHd3dy5vcGVuc3NsLm9yZy9kb2NzL2NyeXB0by9FVlBfQnl0ZXNUb0tleS5odG1sXG5cdCAgICAgKi9cblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cdCAgICAgICAgICAgIGhhc2hlcjogTUQ1LFxuXHQgICAgICAgICAgICBpdGVyYXRpb25zOiAxXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XG5cdCAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci5maW5hbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICovXG5cdCAgICBDLkV2cEtERiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XG5cdCAgICAgICAgcmV0dXJuIEV2cEtERi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuRXZwS0RGO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENpcGhlciBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHRDcnlwdG9KUy5saWIuQ2lwaGVyIHx8IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREY7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXZTaXplIFRoaXMgY2lwaGVyJ3MgSVYgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0VOQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyID0gQ19saWIuQ2lwaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcblx0ICAgICAgICAgICAgdGhpcy5feGZvcm1Nb2RlID0geGZvcm1Nb2RlO1xuXHQgICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgY2lwaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBjaXBoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3Mod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYXZhaWxhYmxlIGJsb2Nrc1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkRGF0YSA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIF9FTkNfWEZPUk1fTU9ERTogMSxcblxuXHQgICAgICAgIF9ERUNfWEZPUk1fTU9ERTogMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIGEgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBlbmNyeXB0IGFuZCBkZWNyeXB0IHNob3J0Y3V0IGZ1bmN0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaXBoZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmVuY3J5cHQoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSgpKVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTW9kZSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX21vZGUgPSBDLm1vZGUgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciBtb2RlIHRlbXBsYXRlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXJNb2RlID0gQ19saWIuQmxvY2tDaXBoZXJNb2RlID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBlbmNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRW5jcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xuXHQgICAgICAgICAgICB0aGlzLl9pdiA9IGl2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ0JDID0gQ19tb2RlLkNCQyA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgQ0JDID0gQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGVuY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gWE9SIGFuZCBlbmNyeXB0XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGRlY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRGVjcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGFuZCBYT1Jcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgZnVuY3Rpb24geG9yQmxvY2sod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIHZhciBibG9jaztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblxuXHQgICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgYmxvY2sgPSBpdjtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFhPUiBibG9ja3Ncblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gQ0JDO1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfcGFkID0gQy5wYWQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgbW9kZTogQ0JDLFxuXHQgICAgICAgICAgICBwYWRkaW5nOiBQa2NzN1xuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGNpcGhlclxuXHQgICAgICAgICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSBjZmcuaXY7XG5cdCAgICAgICAgICAgIHZhciBtb2RlID0gY2ZnLm1vZGU7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXQgYmxvY2sgbW9kZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcblx0ICAgICAgICAgICAgICAgIC8vIEtlZXAgYXQgbGVhc3Qgb25lIGJsb2NrIGluIHRoZSBidWZmZXIgZm9yIHVucGFkZGluZ1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbWluQnVmZmVyU2l6ZSA9IDE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSAmJiB0aGlzLl9tb2RlLl9fY3JlYXRvciA9PSBtb2RlQ3JlYXRvcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZS5pbml0KHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUuX19jcmVhdG9yID0gbW9kZUNyZWF0b3I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcblxuXHQgICAgICAgICAgICAvLyBGaW5hbGl6ZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBQYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVucGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXIgVGhlIGRlZmF1bHQgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXG5cdCAgICAgICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcblx0ICAgICAgICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcblx0ICAgICAgICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcblx0ICAgICAgICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICB0aGlzLm1peEluKGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdH0gZm9ybWF0dGVyIChPcHRpb25hbCkgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChmb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBGb3JtYXQgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wgZm9ybWF0dGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRBcnJheTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgdmFyIHNhbHQgPSBjaXBoZXJQYXJhbXMuc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBGb3JtYXRcblx0ICAgICAgICAgICAgaWYgKHNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgd29yZEFycmF5ID0gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZW5TU0xTdHIgVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAob3BlblNTTFN0cikge1xuXHQgICAgICAgICAgICB2YXIgc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBQYXJzZSBiYXNlNjRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gVGVzdCBmb3Igc2FsdFxuXHQgICAgICAgICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2FsdFxuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY2lwaGVyIHdyYXBwZXIgdGhhdCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBTZXJpYWxpemFibGVDaXBoZXIgPSBDX2xpYi5TZXJpYWxpemFibGVDaXBoZXIgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IGNpcGhlciBwYXJhbSBvYmplY3RzIHRvIGFuZCBmcm9tIGEgc3RyaW5nLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBjZmcpO1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVyQ2ZnID0gZW5jcnlwdG9yLmNmZztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxuXHQgICAgICAgICAgICAgICAga2V5OiBrZXksXG5cdCAgICAgICAgICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuXHQgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXG5cdCAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuXHQgICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxuXHQgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG5cdCAgICAgICAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcGFyc2U6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2tkZiA9IEMua2RmID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xLZGYgPSBDX2tkZi5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVyaXZlIGZyb20uXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0IHdpdGggdGhlIGtleSwgSVYsIGFuZCBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIpO1xuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XG5cdCAgICAgICAgICAgIGlmICghc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5yYW5kb20oNjQvOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIga2V5ID0gRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IGtleVNpemUgKyBpdlNpemUgfSkuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XG5cdCAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBzZXJpYWxpemFibGUgY2lwaGVyIHdyYXBwZXIgdGhhdCBkZXJpdmVzIHRoZSBrZXkgZnJvbSBhIHBhc3N3b3JkLFxuXHQgICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBhc3N3b3JkQmFzZWRDaXBoZXIgPSBDX2xpYi5QYXNzd29yZEJhc2VkQ2lwaGVyID0gU2VyaWFsaXphYmxlQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IFNlcmlhbGl6YWJsZUNpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgY2lwaGVydGV4dC5zYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIGNpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5IZXg7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmODtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZXF1ZXVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cblxuXG5cblxuXG52YXIgUHJvdG9jb2wgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBhY3Rpb25zID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbjtcblxuXHRmdW5jdGlvbiBQcm90b2NvbCh0cmFuc3BvcnQpIHtcblx0XHRfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXHRcdHRoaXMubWVzc2FnZVF1ZXVlID0gbmV3IF9tZXNzYWdlcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgpO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0cmFuc3BvcnQub24oJ2FjaycsIGZ1bmN0aW9uKHNlcmlhbCwgY291bnQpIHsgc2VsZi5vbkFjayhzZXJpYWwsIGNvdW50KTsgfSk7XG5cdFx0dHJhbnNwb3J0Lm9uKCduYWNrJywgZnVuY3Rpb24oc2VyaWFsLCBjb3VudCwgZXJyKSB7IHNlbGYub25OYWNrKHNlcmlhbCwgY291bnQsIGVycik7IH0pO1xuXHR9XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoUHJvdG9jb2wsIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUub25BY2sgPSBmdW5jdGlvbihzZXJpYWwsIGNvdW50KSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1Byb3RvY29sLm9uQWNrKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50KTtcblx0XHR0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5vbk5hY2sgPSBmdW5jdGlvbihzZXJpYWwsIGNvdW50LCBlcnIpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnUHJvdG9jb2wub25OYWNrKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50ICsgJzsgZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdGlmKCFlcnIpIHtcblx0XHRcdGVyciA9IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1VuYWJsZSB0byBzZW5kIG1lc3NhZ2U7IGNoYW5uZWwgbm90IHJlc3BvbmRpbmcnLCA1MDAwMSwgNTAwKTtcblx0XHR9XG5cdFx0dGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50LCBlcnIpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5vbmNlSWRsZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0dmFyIG1lc3NhZ2VRdWV1ZSA9IHRoaXMubWVzc2FnZVF1ZXVlO1xuXHRcdGlmKG1lc3NhZ2VRdWV1ZS5jb3VudCgpID09PSAwKSB7XG5cdFx0XHRsaXN0ZW5lcigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRtZXNzYWdlUXVldWUub25jZSgnaWRsZScsIGxpc3RlbmVyKTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBlbmRpbmdNZXNzYWdlKSB7XG5cdFx0aWYocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQpIHtcblx0XHRcdHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gocGVuZGluZ01lc3NhZ2UpO1xuXHRcdH1cblx0XHRpZiAoX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2hvdWxkTG9nKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTykpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdQcm90b2NvbC5zZW5kKCknLCAnc2VuZGluZyBtc2c7ICcgKyBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc3RyaW5naWZ5KHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpKTtcblx0XHR9XG5cdFx0cGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCA9IHRydWU7XG5cdFx0dGhpcy50cmFuc3BvcnQuc2VuZChwZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNwb3J0O1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5nZXRQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlUXVldWUuY29weUFsbCgpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5jbGVhclBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jbGVhcigpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnQ7XG5cdFx0dGhpcy5vbmNlSWRsZShmdW5jdGlvbigpIHtcblx0XHRcdHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG5cdFx0fSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gUGVuZGluZ01lc3NhZ2UobWVzc2FnZSwgY2FsbGJhY2spIHtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHR0aGlzLm1lcmdlZCA9IGZhbHNlO1xuXHRcdHZhciBhY3Rpb24gPSBtZXNzYWdlLmFjdGlvbjtcblx0XHR0aGlzLnNlbmRBdHRlbXB0ZWQgPSBmYWxzZTtcblx0XHR0aGlzLmFja1JlcXVpcmVkID0gKGFjdGlvbiA9PSBhY3Rpb25zLk1FU1NBR0UgfHwgYWN0aW9uID09IGFjdGlvbnMuUFJFU0VOQ0UpO1xuXHR9XG5cdFByb3RvY29sLlBlbmRpbmdNZXNzYWdlID0gUGVuZGluZ01lc3NhZ2U7XG5cblx0cmV0dXJuIFByb3RvY29sO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChQcm90b2NvbCk7XG5cblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgRG9tRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIERvbUV2ZW50KCkge31cblxuXHREb21FdmVudC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJytldmVudCwgZnVuY3Rpb24oKSB7IGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTsgfSk7XG5cdFx0fVxuXHR9O1xuXG5cdERvbUV2ZW50LnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudCwgbGlzdGVuZXIpIHtcblx0XHRpZih0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5kZXRhY2hFdmVudCgnb24nK2V2ZW50LCBmdW5jdGlvbigpIHsgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpOyB9KTtcblx0XHR9XG5cdH07XG5cblx0RG9tRXZlbnQuYWRkTWVzc2FnZUxpc3RlbmVyID0gZnVuY3Rpb24odGFyZ2V0LCBsaXN0ZW5lcikge1xuXHRcdERvbUV2ZW50LmFkZExpc3RlbmVyKHRhcmdldCwgJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0RG9tRXZlbnQucmVtb3ZlTWVzc2FnZUxpc3RlbmVyID0gZnVuY3Rpb24odGFyZ2V0LCBsaXN0ZW5lcikge1xuXHRcdERvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKHRhcmdldCwgJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0RG9tRXZlbnQuYWRkVW5sb2FkTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuXHRcdERvbUV2ZW50LmFkZExpc3RlbmVyKGdsb2JhbCwgJ3VubG9hZCcsIGxpc3RlbmVyKTtcblx0fTtcblxuXHRyZXR1cm4gRG9tRXZlbnQ7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKERvbUV2ZW50KTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMjApKSlcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCByb3VuZCBjb25zdGFudHMgdGFibGVzXG5cdCAgICB2YXIgSCA9IFtdO1xuXHQgICAgdmFyIEsgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG5cdCAgICAgICAgICAgIHZhciBzcXJ0TiA9IE1hdGguc3FydChuKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgZmFjdG9yID0gMjsgZmFjdG9yIDw9IHNxcnROOyBmYWN0b3IrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKCEobiAlIGZhY3RvcikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoKG4gLSAobiB8IDApKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIG4gPSAyO1xuXHQgICAgICAgIHZhciBuUHJpbWUgPSAwO1xuXHQgICAgICAgIHdoaWxlIChuUHJpbWUgPCA2NCkge1xuXHQgICAgICAgICAgICBpZiAoaXNQcmltZShuKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5QcmltZSA8IDgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgS1tuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDMpKTtcblxuXHQgICAgICAgICAgICAgICAgblByaW1lKys7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBuKys7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChILnNsaWNlKDApKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblx0ICAgICAgICAgICAgdmFyIGYgPSBIWzVdO1xuXHQgICAgICAgICAgICB2YXIgZyA9IEhbNl07XG5cdCAgICAgICAgICAgIHZhciBoID0gSFs3XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTAgID0gKChnYW1tYTB4IDw8IDI1KSB8IChnYW1tYTB4ID4+PiA3KSkgIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMHggPj4+IDMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXggPSBXW2kgLSAyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExICA9ICgoZ2FtbWExeCA8PCAxNSkgfCAoZ2FtbWExeCA+Pj4gMTcpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTF4ID4+PiAxMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaCAgPSAoZSAmIGYpIF4gKH5lICYgZyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqID0gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExID0gKChlIDw8IDI2KSB8IChlID4+PiA2KSkgXiAoKGUgPDwgMjEpIHwgKGUgPj4+IDExKSkgXiAoKGUgPDwgNykgIHwgKGUgPj4+IDI1KSk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuXG5cdCAgICAgICAgICAgICAgICBoID0gZztcblx0ICAgICAgICAgICAgICAgIGcgPSBmO1xuXHQgICAgICAgICAgICAgICAgZiA9IGU7XG5cdCAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gYjtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICAgICAgSFs1XSA9IChIWzVdICsgZikgfCAwO1xuXHQgICAgICAgICAgICBIWzZdID0gKEhbNl0gKyBnKSB8IDA7XG5cdCAgICAgICAgICAgIEhbN10gPSAoSFs3XSArIGgpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjU2O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsXG5cdCAgICAgICAgICAgICAgICAweGMzZDJlMWYwXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBlICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKH5iICYgZCkpICsgMHg1YTgyNzk5OTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDQwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA2MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSkgLSAweDcwZTQ0MzI0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpIC0gMHgzNTlkM2UyYTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZSA9IGQ7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSB0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEExID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEExID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTEpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTE7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOSkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLkhtYWNTSEEyNTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG5cblxuXG5cblxuXG52YXIgSlNPTlBUcmFuc3BvcnQgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlcikge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cdC8qIENhbid0IGp1c3QgdXNlIHdpbmRvdy5BYmx5LCBhcyB0aGF0IHdvbid0IGV4aXN0IGlmIHVzaW5nIHRoZSBjb21tb25qcyB2ZXJzaW9uLiAqL1xuXHR2YXIgXyA9IGdsb2JhbC5fYWJseWpzX2pzb25wID0ge307XG5cblx0LyogZXhwcmVzcyBzdHJpcHMgb3V0IHBhcmFudGhlc2VzIGZyb20gdGhlIGNhbGxiYWNrIVxuXHQgKiBLbHVkZ2UgdG8gc3RpbGwgYWxvdyBpdHMgcmVzcG9uc2VzIHRvIHdvcmssIHdoaWxlIG5vdCBrZWVwaW5nIHRoZVxuXHQgKiBmdW5jdGlvbiBmb3JtIGZvciBub3JtYWwgdXNlIGFuZCBub3QgY2x1dHRlcmluZyB3aW5kb3cuQWJseVxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vZXhwcmVzc2pzL2V4cHJlc3MvYmxvYi81YjRkNGI0YWIxMzI0NzQzNTM0ZmJjZDQ3MDlmNGU3NWJiNGI0ZTlkL2xpYi9yZXNwb25zZS5qcyNMMzA1XG5cdCAqL1xuXHRfLl8gPSBmdW5jdGlvbihpZCkgeyByZXR1cm4gX1snXycgKyBpZF0gfHwgbm9vcDsgfTtcblx0dmFyIGlkQ291bnRlciA9IDE7XG5cdHZhciBoZWFkID0gbnVsbDtcblx0dmFyIHNob3J0TmFtZSA9ICdqc29ucCc7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEpTT05QVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHRwYXJhbXMuc3RyZWFtID0gZmFsc2U7XG5cdFx0X2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcblx0fVxuXHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoSlNPTlBUcmFuc3BvcnQsIF9jb21tb25fbGliX3RyYW5zcG9ydF9jb21ldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRKU09OUFRyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmpzb25wU3VwcG9ydGVkICYmIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWxsb3dDb21ldDtcblx0fTtcblx0aWYoSlNPTlBUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IEpTT05QVHJhbnNwb3J0O1xuXHR9XG5cdGlmKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBTdXBwb3J0ZWQpIHtcblx0XHRoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0fVxuXG5cdC8qIGNvbm5lY3Rpdml0eSBjaGVjazsgc2luY2UgdGhpcyBoYXMgYSBoYXJkLWNvZGVkIGNhbGxiYWNrIGlkLFxuXHQgKiB3ZSBqdXN0IG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBjb25jdXJyZW50IHJlcXVlc3RzIChidXQgdGhlXG5cdCAqIGNvbm5lY3Rpb25tYW5hZ2VyIHNob3VsZCBlbnN1cmUgdGhpcyBkb2Vzbid0IGhhcHBlbiBhbnl3YXkgKi9cblx0dmFyIGNoZWNrc0luUHJvZ3Jlc3MgPSBudWxsO1xuXHRnbG9iYWwuSlNPTlBUcmFuc3BvcnQgPSBKU09OUFRyYW5zcG9ydFxuXG5cdEpTT05QVHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgSlNPTlBUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dmFyIGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soe2V2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyfSk7IH07XG5cdFx0dHJhbnNwb3J0Lm9uKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHR0cmFuc3BvcnQub24oJ3ByZWNvbm5lY3QnLCBmdW5jdGlvbigpIHtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnSlNPTlBUcmFuc3BvcnQudHJ5Q29ubmVjdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCk7XG5cdFx0XHR0cmFuc3BvcnQub2ZmKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG5cdFx0fSk7XG5cdFx0dHJhbnNwb3J0LmNvbm5lY3QoKTtcblx0fTtcblxuXHRKU09OUFRyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ0pTT05QVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuXHR9O1xuXG5cdHZhciBjcmVhdGVSZXF1ZXN0ID0gSlNPTlBUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbih1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcblx0XHQvKiBKU09OUCByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG5cdFx0ICogdHJhbnNwb3J0LCBvciB3aXRoIHRpbWVvdXRzIHBhc3NlZCBpbiAoZm9yIHdoZW4gdXNlZCBieSBhIHJlc3QgY2xpZW50KSxcblx0XHQgKiBvciBjb21wbGV0ZWx5IHN0YW5kYWxvbmUuICBVc2UgdGhlIGFwcHJvcHJpYXRlIHRpbWVvdXRzIGluIGVhY2ggY2FzZSAqL1xuXHRcdHRpbWVvdXRzID0gKHRoaXMgJiYgdGhpcy50aW1lb3V0cykgfHwgdGltZW91dHMgfHwgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRJTUVPVVRTO1xuXHRcdHJldHVybiBuZXcgUmVxdWVzdCh1bmRlZmluZWQsIHVyaSwgaGVhZGVycywgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNvcHkocGFyYW1zKSwgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFJlcXVlc3QoaWQsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuXHRcdF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzKTtcblx0XHRpZihpZCA9PT0gdW5kZWZpbmVkKSBpZCA9IGlkQ291bnRlcisrO1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLnVyaSA9IHVyaTtcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblx0XHR0aGlzLnBhcmFtcy5ybmQgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlYXBSYW5kU3RyKCk7XG5cdFx0aWYoaGVhZGVycykge1xuXHRcdFx0LyogSlNPTlAgZG9lc24ndCBhbGxvdyBoZWFkZXJzLiBDaGVycnktcGljayBhIGNvdXBsZSB0byB0dXJuIGludG8gcXMgcGFyYW1zICovXG5cdFx0XHRpZihoZWFkZXJzWydYLUFibHktVmVyc2lvbiddKSB0aGlzLnBhcmFtcy52ID0gaGVhZGVyc1snWC1BYmx5LVZlcnNpb24nXTtcblx0XHRcdGlmKGhlYWRlcnNbJ1gtQWJseS1MaWInXSkgdGhpcy5wYXJhbXMubGliID0gaGVhZGVyc1snWC1BYmx5LUxpYiddO1xuXHRcdH1cblx0XHR0aGlzLmJvZHkgPSBib2R5O1xuXHRcdHRoaXMubWV0aG9kID0gbWV0aG9kO1xuXHRcdHRoaXMucmVxdWVzdE1vZGUgPSByZXF1ZXN0TW9kZTtcblx0XHR0aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG5cdFx0dGhpcy5yZXF1ZXN0Q29tcGxldGUgPSBmYWxzZTtcblx0fVxuXHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoUmVxdWVzdCwgX2NvbW1vbl9saWJfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0UmVxdWVzdC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZCA9IHRoaXMuaWQsXG5cdFx0XHRib2R5ID0gdGhpcy5ib2R5LFxuXHRcdFx0bWV0aG9kID0gdGhpcy5tZXRob2QsXG5cdFx0XHR1cmkgPSB0aGlzLnVyaSxcblx0XHRcdHBhcmFtcyA9IHRoaXMucGFyYW1zLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRwYXJhbXMuY2FsbGJhY2sgPSAnX2FibHlqc19qc29ucC5fKCcgKyBpZCArICcpJztcblxuXHRcdHBhcmFtcy5lbnZlbG9wZSA9ICdqc29ucCc7XG5cdFx0aWYoYm9keSkge1xuXHRcdFx0cGFyYW1zLmJvZHkgPSBib2R5O1xuXHRcdH1cblx0XHRpZihtZXRob2QgJiYgbWV0aG9kICE9PSAnZ2V0Jykge1xuXHRcdFx0cGFyYW1zLm1ldGhvZCA9IG1ldGhvZDtcblx0XHR9XG5cblx0XHR2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHR2YXIgc3JjID0gdXJpICsgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvUXVlcnlTdHJpbmcocGFyYW1zKTtcblx0XHRzY3JpcHQuc3JjID0gc3JjO1xuXHRcdGlmKHNjcmlwdC5zcmMuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF0gIT09IHNyYy5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSkge1xuXHRcdFx0LyogVGhlIHNyYyBoYXMgYmVlbiB0cnVuY2F0ZWQuIENhbid0IGFib3J0LCBidXQgY2FuIGF0IGxlYXN0IGVtaXQgYW5cblx0XHRcdCAqIGVycm9yIHNvIHRoZSB1c2VyIGtub3dzIHdoYXQncyBnb25lIHdyb25nLiAoQ2FuJ3QgY29tcGFyZSBzdHJpbmdzXG5cdFx0XHQgKiBkaXJlY3RseSBhcyBzcmMgbWF5IGhhdmUgYSBwb3J0LCBzY3JpcHQuc3JjIHdvbid0KSAqL1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdKU09OUCBSZXF1ZXN0LmV4ZWMoKScsICdXYXJuaW5nOiB0aGUgYnJvd3NlciBhcHBlYXJzIHRvIGhhdmUgdHJ1bmNhdGVkIHRoZSBzY3JpcHQgVVJJLiBUaGlzIHdpbGwgbGlrZWx5IHJlc3VsdCBpbiB0aGUgcmVxdWVzdCBmYWlsaW5nIGR1ZSB0byBhbiB1bnBhcnNlYWJsZSBib2R5IHBhcmFtJyk7XG5cdFx0fVxuXHRcdHNjcmlwdC5hc3luYyA9IHRydWU7XG5cdFx0c2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0Jztcblx0XHRzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG5cdFx0c2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdHNlbGYuY29tcGxldGUobmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdKU09OUCBzY3JpcHQgZXJyb3IgKGV2ZW50OiAnICsgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3QoZXJyKSArICcpJywgbnVsbCwgNDAwKSk7XG5cdFx0fTtcblxuXHRcdF9bJ18nICsgaWRdID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdFx0aWYobWVzc2FnZS5zdGF0dXNDb2RlKSB7XG5cdFx0XHRcdC8qIEhhbmRsZSBhcyBlbnZlbG9wZWQganNvbnAsIGFzIGFsbCBqc29ucCB0cmFuc3BvcnQgdXNlcyBzaG91bGQgYmUgKi9cblx0XHRcdFx0dmFyIHJlc3BvbnNlID0gbWVzc2FnZS5yZXNwb25zZTtcblx0XHRcdFx0aWYobWVzc2FnZS5zdGF0dXNDb2RlID09IDIwNCkge1xuXHRcdFx0XHRcdHNlbGYuY29tcGxldGUobnVsbCwgbnVsbCwgbnVsbCwgbWVzc2FnZS5zdGF0dXNDb2RlKTtcblx0XHRcdFx0fSBlbHNlIGlmKCFyZXNwb25zZSkge1xuXHRcdFx0XHRcdHNlbGYuY29tcGxldGUobmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdJbnZhbGlkIHNlcnZlciByZXNwb25zZTogbm8gZW52ZWxvcGUgZGV0ZWN0ZWQnLCBudWxsLCA1MDApKTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDQwMCB8fCBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShyZXNwb25zZSkpIHtcblx0XHRcdFx0XHQvKiBJZiByZXNwb25zZSBpcyBhbiBhcnJheSwgaXQncyBhbiBhcnJheSBvZiBwcm90b2NvbCBtZXNzYWdlcyAtLSBldmVuIGlmXG5cdFx0XHRcdFx0ICogaXQgY29udGFpbnMgYW4gZXJyb3IgYWN0aW9uIChoZW5jZSB0aGUgbm9uc3VjY2VzcyBzdGF0dXNjb2RlKSwgd2UgY2FuXG5cdFx0XHRcdFx0ICogY29uc2lkZXIgdGhlIHJlcXVlc3QgdG8gaGF2ZSBzdWNjZWVkZWQsIGp1c3QgcGFzcyBpdCBvbiB0b1xuXHRcdFx0XHRcdCAqIG9uUHJvdG9jb2xNZXNzYWdlIHRvIGRlY2lkZSB3aGF0IHRvIGRvICovXG5cdFx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCByZXNwb25zZSwgbWVzc2FnZS5oZWFkZXJzLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBlcnIgPSByZXNwb25zZS5lcnJvciB8fCBuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0Vycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyJywgbnVsbCwgbWVzc2FnZS5zdGF0dXNDb2RlKTtcblx0XHRcdFx0XHRzZWxmLmNvbXBsZXRlKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8qIEhhbmRsZSBhcyBub24tZW52ZWxvcGVkIC0tIGFzIHdpbGwgYmUgZWcgZnJvbSBhIGN1c3RvbWVyJ3MgYXV0aFVybCBzZXJ2ZXIgKi9cblx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCBtZXNzYWdlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIHRpbWVvdXQgPSAodGhpcy5yZXF1ZXN0TW9kZSA9PSBfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SRVFfU0VORCkgPyB0aGlzLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IHRoaXMudGltZW91dHMucmVjdlRpbWVvdXQ7XG5cdFx0dGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGYuYWJvcnQoKTsgfSwgdGltZW91dCk7XG5cdFx0aGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuXHR9O1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCBzdGF0dXNDb2RlKSB7XG5cdFx0aGVhZGVycyA9IGhlYWRlcnMgfHwge307XG5cdFx0aWYoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR2YXIgY29udGVudFR5cGU7XG5cdFx0XHRpZihib2R5KSB7XG5cdFx0XHRcdGNvbnRlbnRUeXBlID0gKHR5cGVvZihib2R5KSA9PSAnc3RyaW5nJykgPyAndGV4dC9wbGFpbicgOiAnYXBwbGljYXRpb24vanNvbic7XG5cdFx0XHRcdGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gY29udGVudFR5cGU7XG5cdFx0XHRcdHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmVtaXQoJ2NvbXBsZXRlJywgZXJyLCBib2R5LCBoZWFkZXJzLCAvKiB1bnBhY2tlZDogKi8gdHJ1ZSwgc3RhdHVzQ29kZSk7XG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0XHR9XG5cdH07XG5cblx0UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRpc3Bvc2UoKTtcblx0fTtcblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRpbWVyID0gdGhpcy50aW1lcjtcblx0XHRpZih0aW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdHRoaXMudGltZXIgPSBudWxsO1xuXHRcdH1cblx0XHR2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG5cdFx0aWYoc2NyaXB0LnBhcmVudE5vZGUpIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0ZGVsZXRlIF9bdGhpcy5pZF07XG5cdFx0dGhpcy5lbWl0KCdkaXNwb3NlZCcpO1xuXHR9O1xuXG5cdGlmKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBTdXBwb3J0ZWQgJiYgIXBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SZXF1ZXN0KSB7XG5cdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHJlcSA9IGNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIF9jb21tb25fbGliX3RyYW5zcG9ydF9jb21ldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJFUV9TRU5ELCByZXN0ICYmIHJlc3Qub3B0aW9ucy50aW1lb3V0cywgbWV0aG9kKTtcblx0XHRcdHJlcS5vbmNlKCdjb21wbGV0ZScsIGNhbGxiYWNrKTtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVxLmV4ZWMoKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJlcTtcblx0XHR9O1xuXG5cdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdHZhciB1cFVybCA9IF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5qc29ucEludGVybmV0VXBVcmw7XG5cblx0XHRcdGlmKGNoZWNrc0luUHJvZ3Jlc3MpIHtcblx0XHRcdFx0Y2hlY2tzSW5Qcm9ncmVzcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tzSW5Qcm9ncmVzcyA9IFtjYWxsYmFja107XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJyhKU09OUClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIHVwVXJsKTtcblxuXHRcdFx0dmFyIHJlcSA9IG5ldyBSZXF1ZXN0KCdpc1RoZUludGVybmV0VXAnLCB1cFVybCwgbnVsbCwgbnVsbCwgbnVsbCwgX2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUkVRX1NFTkQsIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5USU1FT1VUUyk7XG5cdFx0XHRyZXEub25jZSgnY29tcGxldGUnLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSAhZXJyICYmIHJlc3BvbnNlO1xuXHRcdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJyhKU09OUClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnUmVzdWx0OiAnICsgcmVzdWx0KTtcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNoZWNrc0luUHJvZ3Jlc3MubGVuZ3RoOyBpKyspIGNoZWNrc0luUHJvZ3Jlc3NbaV0obnVsbCwgcmVzdWx0KTtcblx0XHRcdFx0Y2hlY2tzSW5Qcm9ncmVzcyA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVxLmV4ZWMoKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gSlNPTlBUcmFuc3BvcnQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEpTT05QVHJhbnNwb3J0KTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMjApKSlcblxuLyoqKi8gfSksXG4vKiA0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cblxuXG5cblxuXG5cbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlcikge1xuXHR2YXIgV2ViU29ja2V0ID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5XZWJTb2NrZXQ7XG5cdHZhciBzaG9ydE5hbWUgPSAnd2ViX3NvY2tldCc7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0dGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG5cdFx0LyogSWYgaXMgYSBicm93c2VyLCBjYW4ndCBkZXRlY3QgcGluZ3MsIHNvIHJlcXVlc3QgcHJvdG9jb2wgaGVhcnRiZWF0cyAqL1xuXHRcdHBhcmFtcy5oZWFydGJlYXRzID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51c2VQcm90b2NvbEhlYXJ0YmVhdHM7XG5cdFx0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dGhpcy53c0hvc3QgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEhvc3QocGFyYW1zLm9wdGlvbnMsIHBhcmFtcy5ob3N0LCB0cnVlKTtcblx0fVxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgX3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISFXZWJTb2NrZXQ7XG5cdH07XG5cblx0aWYoV2ViU29ja2V0VHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpXG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC50cnlDb25uZWN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgdHJhbnNwb3J0ID0gbmV3IFdlYlNvY2tldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR2YXIgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayh7ZXZlbnQ6IHRoaXMuZXZlbnQsIGVycm9yOiBlcnJ9KTsgfTtcblx0XHR0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdHRyYW5zcG9ydC5vbignd3NvcGVuJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0dHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xuXHRcdH0pO1xuXHRcdHRyYW5zcG9ydC5jb25uZWN0KCk7XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVXZWJTb2NrZXQgPSBmdW5jdGlvbih1cmksIGNvbm5lY3RQYXJhbXMpIHtcblx0XHR2YXIgcGFyYW1Db3VudCA9IDA7XG5cdFx0aWYoY29ubmVjdFBhcmFtcykge1xuXHRcdFx0Zm9yKHZhciBrZXkgaW4gY29ubmVjdFBhcmFtcylcblx0XHRcdFx0dXJpICs9IChwYXJhbUNvdW50KysgPyAnJicgOiAnPycpICsga2V5ICsgJz0nICsgY29ubmVjdFBhcmFtc1trZXldO1xuXHRcdH1cblx0XHR0aGlzLnVyaSA9IHVyaTtcblx0XHRyZXR1cm4gbmV3IFdlYlNvY2tldCh1cmkpO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ1dlYlNvY2tldFRyYW5zcG9ydDsgdXJpPScgKyB0aGlzLnVyaTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xuXHRcdF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuXHRcdHZhciBzZWxmID0gdGhpcywgcGFyYW1zID0gdGhpcy5wYXJhbXMsIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcblx0XHR2YXIgd3NTY2hlbWUgPSBvcHRpb25zLnRscyA/ICd3c3M6Ly8nIDogJ3dzOi8vJztcblx0XHR2YXIgd3NVcmkgPSB3c1NjaGVtZSArIHRoaXMud3NIb3N0ICsgJzonICsgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRQb3J0KG9wdGlvbnMpICsgJy8nO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3VyaTogJyArIHdzVXJpKTtcblx0XHR0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbihlcnIsIGF1dGhQYXJhbXMpIHtcblx0XHRcdGlmKHNlbGYuaXNEaXNwb3NlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFyYW1TdHIgPSAnJzsgZm9yKHZhciBwYXJhbSBpbiBhdXRoUGFyYW1zKSBwYXJhbVN0ciArPSAnICcgKyBwYXJhbSArICc6ICcgKyBhdXRoUGFyYW1zW3BhcmFtXSArICc7Jztcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ2F1dGhQYXJhbXM6JyArIHBhcmFtU3RyICsgJyBlcnI6ICcgKyBlcnIpO1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgY29ubmVjdFBhcmFtcyA9IHBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHdzQ29ubmVjdGlvbiA9IHNlbGYud3NDb25uZWN0aW9uID0gc2VsZi5jcmVhdGVXZWJTb2NrZXQod3NVcmksIGNvbm5lY3RQYXJhbXMpO1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24uYmluYXJ5VHlwZSA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmluYXJ5VHlwZTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLm9ub3BlbiA9IGZ1bmN0aW9uKCkgeyBzZWxmLm9uV3NPcGVuKCk7IH07XG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbmNsb3NlID0gZnVuY3Rpb24oZXYpIHsgc2VsZi5vbldzQ2xvc2UoZXYpOyB9O1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHsgc2VsZi5vbldzRGF0YShldi5kYXRhKTsgfTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbihldikgeyBzZWxmLm9uV3NFcnJvcihldik7IH07XG5cdFx0XHRcdGlmKHdzQ29ubmVjdGlvbi5vbikge1xuXHRcdFx0XHRcdC8qIG5vZGU7IGJyb3dzZXJzIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgZ2VuZXJhbCBldmVudGVtaXR0ZXIgYW5kIGNhbid0IGRldGVjdFxuXHRcdFx0XHRcdCAqIHBpbmdzLiBBbHNvLCBubyBuZWVkIHRvIHJlcGx5IHdpdGggYSBwb25nIGV4cGxpY2l0bHksIHdzIGxpYiBoYW5kbGVzIHRoYXQgKi9cblx0XHRcdFx0XHR3c0Nvbm5lY3Rpb24ub24oJ3BpbmcnLCBmdW5jdGlvbigpIHsgc2VsZi5vbkFjdGl2aXR5KCk7IH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gY3JlYXRpbmcgd2Vic29ja2V0OiBlcnIgPSAnICsgKGUuc3RhY2sgfHwgZS5tZXNzYWdlKSk7XG5cdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dmFyIHdzQ29ubmVjdGlvbiA9IHRoaXMud3NDb25uZWN0aW9uO1xuXHRcdGlmKCF3c0Nvbm5lY3Rpb24pIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpJywgJ05vIHNvY2tldCBjb25uZWN0aW9uJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHR3c0Nvbm5lY3Rpb24uc2VuZChfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2VyaWFsaXplKG1lc3NhZ2UsIHRoaXMucGFyYW1zLmZvcm1hdCkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHZhciBtc2cgPSAnRXhjZXB0aW9uIGZyb20gd3MgY29ubmVjdGlvbiB3aGVuIHRyeWluZyB0byBzZW5kOiAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZSk7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKScsIG1zZyk7XG5cdFx0XHQvKiBEb24ndCB0cnkgdG8gcmVxdWVzdCBhIGRpc2Nvbm5lY3QsIHRoYXQnbGwganVzdCBpbnZvbHZlIHNlbmRpbmcgZGF0YVxuXHRcdFx0ICogZG93biB0aGUgd2Vic29ja2V0IGFnYWluLiBKdXN0IGZpbmlzaCB0aGUgdHJhbnNwb3J0LiAqL1xuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA1MDAwMCwgNTAwKSk7XG5cdFx0fVxuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0RhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpJywgJ2RhdGEgcmVjZWl2ZWQ7IGxlbmd0aCA9ICcgKyBkYXRhLmxlbmd0aCArICc7IHR5cGUgPSAnICsgdHlwZW9mKGRhdGEpKTtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy5vblByb3RvY29sTWVzc2FnZShfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVzZXJpYWxpemUoZGF0YSwgdGhpcy5mb3JtYXQpKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIG1lc3NhZ2U6ICcgKyBlLnN0YWNrKTtcblx0XHR9XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzT3BlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc09wZW4oKScsICdvcGVuZWQgV2ViU29ja2V0Jyk7XG5cdFx0dGhpcy5lbWl0KCd3c29wZW4nKTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NDbG9zZSA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHdhc0NsZWFuLCBjb2RlLCByZWFzb247XG5cdFx0aWYodHlwZW9mKGV2KSA9PSAnb2JqZWN0Jykge1xuXHRcdFx0LyogVzNDIHNwZWMtY29tcGF0aWJsZSAqL1xuXHRcdFx0d2FzQ2xlYW4gPSBldi53YXNDbGVhbjtcblx0XHRcdGNvZGUgPSBldi5jb2RlO1xuXHRcdH0gZWxzZSAvKmlmKHR5cGVvZihldikgPT0gJ251bWJlcicpKi8ge1xuXHRcdFx0Lyogd3MgaW4gbm9kZSAqL1xuXHRcdFx0Y29kZSA9IGV2O1xuXHRcdFx0d2FzQ2xlYW4gPSAoY29kZSA9PSAxMDAwKTtcblx0XHR9XG5cdFx0ZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuXHRcdGlmKHdhc0NsZWFuKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpJywgJ0NsZWFubHkgY2xvc2VkIFdlYlNvY2tldCcpO1xuXHRcdFx0dmFyIGVyciA9IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1dlYnNvY2tldCBjbG9zZWQnLCA4MDAwMywgNDAwKTtcblx0XHRcdHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbXNnID0gJ1VuY2xlYW4gZGlzY29ubmVjdGlvbiBvZiBXZWJTb2NrZXQgOyBjb2RlID0gJyArIGNvZGUsXG5cdFx0XHRcdGVyciA9IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA4MDAwMywgNDAwKTtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKCknLCBtc2cpO1xuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG5cdFx0fVxuXHRcdHRoaXMuZW1pdCgnZGlzcG9zZWQnKTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25FcnJvcigpJywgJ0Vycm9yIGZyb20gV2ViU29ja2V0OiAnICsgZXJyLm1lc3NhZ2UpO1xuXHRcdC8qIFdhaXQgYSB0aWNrIGJlZm9yZSBhYm9ydGluZzogaWYgdGhlIHdlYnNvY2tldCB3YXMgY29ubmVjdGVkLCB0aGlzIGV2ZW50XG5cdFx0ICogd2lsbCBiZSBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBvbmNsb3NlIGV2ZW50IHdpdGggYSBjbG9zZSBjb2RlLiBBbGxvd1xuXHRcdCAqIHRoYXQgdG8gY2xvc2UgaXQgKHNvIHdlIHNlZSB0aGUgY2xvc2UgY29kZSkgcmF0aGVyIHRoYW4gYW50aWNpcGF0aW5nIGl0ICovXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHR9KTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICcnKTtcblx0XHR0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuXHRcdHZhciB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcblx0XHRpZih3c0Nvbm5lY3Rpb24pIHtcblx0XHRcdC8qIElnbm9yZSBhbnkgbWVzc2FnZXMgdGhhdCBjb21lIHRocm91Z2ggYWZ0ZXIgZGlzcG9zZSgpIGlzIGNhbGxlZCBidXQgYmVmb3JlXG5cdFx0XHQgKiB3ZWJzb2NrZXQgaXMgYWN0dWFsbHkgY2xvc2VkLiAobW9zdGx5IHdvdWxkIGJlIGhhcm1sZXNzLCBidXQgaWYgaXQncyBhXG5cdFx0XHQgKiBDT05ORUNURUQsIGl0J2xsIHJlLXRpY2sgaXNDb25uZWN0ZWQgYW5kIGNhdXNlIGFsbCBzb3J0cyBvZiBoYXZvYykgKi9cblx0XHRcdHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0ZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuXHRcdFx0LyogZGVmZXIgdW50aWwgdGhlIG5leHQgZXZlbnQgbG9vcCBjeWNsZSBiZWZvcmUgY2xvc2luZyB0aGUgc29ja2V0LFxuXHRcdFx0ICogZ2l2aW5nIHNvbWUgaW1wbGVtZW50YXRpb25zIHRoZSBvcHBvcnR1bml0eSB0byBzZW5kIGFueSBvdXRzdGFuZGluZyBjbG9zZSBtZXNzYWdlICovXG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICdjbG9zaW5nIHdlYnNvY2tldCcpO1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24uY2xvc2UoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gV2ViU29ja2V0VHJhbnNwb3J0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChXZWJTb2NrZXRUcmFuc3BvcnQpO1xuXG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQvanNvbnB0cmFuc3BvcnQuanNcbnZhciBqc29ucHRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL3V0aWxzLmpzXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2xvZ2dlci5qc1xudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2ZyYWdtZW50cy9wbGF0Zm9ybS1icm93c2VyLmpzXG52YXIgcGxhdGZvcm1fYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3RyYW5zcG9ydC9jb21ldHRyYW5zcG9ydC5qc1xudmFyIGNvbWV0dHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQveGhycmVxdWVzdC5qc1xudmFyIHhocnJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQveGhycG9sbGluZ3RyYW5zcG9ydC5qc1xuXG5cblxuXG5cblxudmFyIHhocnBvbGxpbmd0cmFuc3BvcnRfWEhSUG9sbGluZ1RyYW5zcG9ydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG5cdHZhciBzaG9ydE5hbWUgPSAneGhyX3BvbGxpbmcnO1xuXG5cdGZ1bmN0aW9uIFhIUlBvbGxpbmdUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuXHRcdHBhcmFtcy5zdHJlYW0gPSBmYWxzZTtcblx0XHRjb21ldHRyYW5zcG9ydFtcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFhIUlBvbGxpbmdUcmFuc3BvcnQsIGNvbWV0dHJhbnNwb3J0W1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRYSFJQb2xsaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ueGhyU3VwcG9ydGVkICYmIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uYWxsb3dDb21ldDtcblx0fTtcblxuXHRYSFJQb2xsaW5nVHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgWEhSUG9sbGluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR2YXIgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayh7ZXZlbnQ6IHRoaXMuZXZlbnQsIGVycm9yOiBlcnJ9KTsgfTtcblx0XHR0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdHRyYW5zcG9ydC5vbigncHJlY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnWEhSUG9sbGluZ1RyYW5zcG9ydC50cnlDb25uZWN0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0KTtcblx0XHRcdHRyYW5zcG9ydC5vZmYoWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcblx0XHR9KTtcblx0XHR0cmFuc3BvcnQuY29ubmVjdCgpO1xuXHR9O1xuXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdYSFJQb2xsaW5nVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuXHR9O1xuXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbih1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUpIHtcblx0XHRyZXR1cm4geGhycmVxdWVzdFtcImFcIiAvKiBkZWZhdWx0ICovXS5jcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGhpcy50aW1lb3V0cyk7XG5cdH07XG5cblx0aWYodHlwZW9mKGNvbm5lY3Rpb25NYW5hZ2VyKSAhPT0gJ3VuZGVmaW5lZCcgJiYgWEhSUG9sbGluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gWEhSUG9sbGluZ1RyYW5zcG9ydDtcblx0fVxuXG5cdHJldHVybiBYSFJQb2xsaW5nVHJhbnNwb3J0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhycG9sbGluZ3RyYW5zcG9ydCA9ICh4aHJwb2xsaW5ndHJhbnNwb3J0X1hIUlBvbGxpbmdUcmFuc3BvcnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3RyYW5zcG9ydC94aHJzdHJlYW1pbmd0cmFuc3BvcnQuanNcblxuXG5cblxuXG5cbnZhciB4aHJzdHJlYW1pbmd0cmFuc3BvcnRfWEhSU3RyZWFtaW5nVHJhbnNwb3J0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIpIHtcblx0dmFyIHNob3J0TmFtZSA9ICd4aHJfc3RyZWFtaW5nJztcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gWEhSU3RyZWFtaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHRjb21ldHRyYW5zcG9ydFtcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFhIUlN0cmVhbWluZ1RyYW5zcG9ydCwgY29tZXR0cmFuc3BvcnRbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnhoclN1cHBvcnRlZCAmJiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN0cmVhbWluZ1N1cHBvcnRlZCAmJiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFsbG93Q29tZXQ7XG5cdH07XG5cblx0WEhSU3RyZWFtaW5nVHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgWEhSU3RyZWFtaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHZhciBlcnJvckNiID0gZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKHtldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVycn0pOyB9O1xuXHRcdHRyYW5zcG9ydC5vbihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0dHJhbnNwb3J0Lm9uKCdwcmVjb25uZWN0JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdYSFJTdHJlYW1pbmdUcmFuc3BvcnQudHJ5Q29ubmVjdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCk7XG5cdFx0XHR0cmFuc3BvcnQub2ZmKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG5cdFx0fSk7XG5cdFx0dHJhbnNwb3J0LmNvbm5lY3QoKTtcblx0fTtcblxuXHRYSFJTdHJlYW1pbmdUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy5iYXNlVXJpICsgJzsgaXNDb25uZWN0ZWQ9JyArIHRoaXMuaXNDb25uZWN0ZWQ7XG5cdH07XG5cblx0WEhSU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24odXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG5cdFx0cmV0dXJuIHhocnJlcXVlc3RbXCJhXCIgLyogZGVmYXVsdCAqL10uY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMudGltZW91dHMpO1xuXHR9O1xuXG5cdGlmKHR5cGVvZihjb25uZWN0aW9uTWFuYWdlcikgIT09ICd1bmRlZmluZWQnICYmIFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gWEhSU3RyZWFtaW5nVHJhbnNwb3J0O1xuXHR9XG5cblx0cmV0dXJuIFhIUlN0cmVhbWluZ1RyYW5zcG9ydDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocnN0cmVhbWluZ3RyYW5zcG9ydCA9ICh4aHJzdHJlYW1pbmd0cmFuc3BvcnRfWEhSU3RyZWFtaW5nVHJhbnNwb3J0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQvaW5kZXguanNcblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbGliX3RyYW5zcG9ydCA9IF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFtcbiAganNvbnB0cmFuc3BvcnRbXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIHhocnBvbGxpbmd0cmFuc3BvcnQsXG4gIHhocnN0cmVhbWluZ3RyYW5zcG9ydFxuXSk7XG5cblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgQkUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGYxNkJFID0gQ19lbmMuVXRmMTYgPSBDX2VuYy5VdGYxNkJFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmY7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBCRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNi5wYXJzZSh1dGYxNlN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSB1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBMRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgQ19lbmMuVXRmMTZMRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0ciA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBzd2FwRW5kaWFuKCh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZik7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBMRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnBhcnNlKHV0ZjE2U3RyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHN3YXBFbmRpYW4odXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHN3YXBFbmRpYW4od29yZCkge1xuXHQgICAgICAgIHJldHVybiAoKHdvcmQgPDwgOCkgJiAweGZmMDBmZjAwKSB8ICgod29yZCA+Pj4gOCkgJiAweDAwZmYwMGZmKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmMTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4O1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQ7XG5cblx0ICAgIHZhciBIZXhGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhlIGNpcGhlcnRleHQgb2YgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQudG9TdHJpbmcoSGV4KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgY2lwaGVydGV4dCBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBIZXgucGFyc2UoaW5wdXQpO1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5mb3JtYXQuSGV4O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxNyksIF9fd2VicGFja19yZXF1aXJlX18oNDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMSkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBMb29rdXAgdGFibGVzXG5cdCAgICB2YXIgU0JPWCA9IFtdO1xuXHQgICAgdmFyIElOVl9TQk9YID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8zID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcblx0ICAgICAgICB2YXIgZCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGkgPCAxMjgpIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdhbGsgR0YoMl44KVxuXHQgICAgICAgIHZhciB4ID0gMDtcblx0ICAgICAgICB2YXIgeGkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzYm94XG5cdCAgICAgICAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuXHQgICAgICAgICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG5cdCAgICAgICAgICAgIFNCT1hbeF0gPSBzeDtcblx0ICAgICAgICAgICAgSU5WX1NCT1hbc3hdID0geDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG5cdCAgICAgICAgICAgIHZhciB4MiA9IGRbeF07XG5cdCAgICAgICAgICAgIHZhciB4NCA9IGRbeDJdO1xuXHQgICAgICAgICAgICB2YXIgeDggPSBkW3g0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgU1VCX01JWF8wW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzNbeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltzeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8zW3N4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcblx0ICAgICAgICAgICAgaWYgKCF4KSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcblx0ICAgICAgICAgICAgICAgIHhpIF49IGRbZFt4aV1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcblx0ICAgIHZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgQUVTID0gQ19hbGdvLkFFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHQ7XG5cblx0ICAgICAgICAgICAgLy8gU2tpcCByZXNldCBvZiBuUm91bmRzIGhhcyBiZWVuIHNldCBiZWZvcmUgYW5kIGtleSBkaWQgbm90IGNoYW5nZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5UHJpb3JSZXNldCA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIGtleSBzY2hlZHVsZSByb3dzXG5cdCAgICAgICAgICAgIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSAxXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCBSY29uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgXj0gUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93ICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IElOVl9TVUJfTUlYXzBbU0JPWFt0ID4+PiAyNF1dIF4gSU5WX1NVQl9NSVhfMVtTQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBJTlZfU1VCX01JWF8zW1NCT1hbdCAmIDB4ZmZdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52S2V5U2NoZWR1bGUsIElOVl9TVUJfTUlYXzAsIElOVl9TVUJfTUlYXzEsIElOVl9TVUJfTUlYXzIsIElOVl9TVUJfTUlYXzMsIElOVl9TQk9YKTtcblxuXHQgICAgICAgICAgICAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcztcblxuXHQgICAgICAgICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHMwID0gTVtvZmZzZXRdICAgICBeIGtleVNjaGVkdWxlWzBdO1xuXHQgICAgICAgICAgICB2YXIgczEgPSBNW29mZnNldCArIDFdIF4ga2V5U2NoZWR1bGVbMV07XG5cdCAgICAgICAgICAgIHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcblx0ICAgICAgICAgICAgdmFyIHMzID0gTVtvZmZzZXQgKyAzXSBeIGtleVNjaGVkdWxlWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIEtleSBzY2hlZHVsZSByb3cgY291bnRlclxuXHQgICAgICAgICAgICB2YXIga3NSb3cgPSA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBtaXggY29sdW1ucywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gU1VCX01JWF8wW3MyID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcblx0ICAgICAgICAgICAgICAgIHMwID0gdDA7XG5cdCAgICAgICAgICAgICAgICBzMSA9IHQxO1xuXHQgICAgICAgICAgICAgICAgczIgPSB0Mjtcblx0ICAgICAgICAgICAgICAgIHMzID0gdDM7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxuXHQgICAgICAgICAgICBNW29mZnNldF0gICAgID0gdDA7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0MTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDI1Ni8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLkFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5BRVM7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2ZyYWdtZW50cy9wbGF0Zm9ybS1icm93c2VyLmpzXG52YXIgcGxhdGZvcm1fYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvdXRpbHMuanNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbG9nZ2VyLmpzXG52YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9kZWZhdWx0cy5qcyArIDEgbW9kdWxlc1xudmFyIGRlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2F1dGguanMgKyAxIG1vZHVsZXNcbnZhciBhdXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9kZXZpY2VkZXRhaWxzLmpzXG5cblxudmFyIGRldmljZWRldGFpbHNfRGV2aWNlRGV0YWlscyA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBEZXZpY2VEZXRhaWxzKCkge1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5kZXZpY2VTZWNyZXQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5wbGF0Zm9ybSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmZvcm1GYWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm1ldGFkYXRhID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbiA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnB1c2ggPSB7XG5cdFx0XHRyZWNpcGllbnQ6IHVuZGVmaW5lZCxcblx0XHRcdHN0YXRlOiB1bmRlZmluZWQsXG5cdFx0XHRlcnJvclJlYXNvbjogdW5kZWZpbmVkXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0RGV2aWNlRGV0YWlscy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlkOiB0aGlzLmlkLFxuXHRcdFx0ZGV2aWNlU2VjcmV0OiB0aGlzLmRldmljZVNlY3JldCxcblx0XHRcdHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuXHRcdFx0Zm9ybUZhY3RvcjogdGhpcy5mb3JtRmFjdG9yLFxuXHRcdFx0Y2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG5cdFx0XHRtZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcblx0XHRcdGRldmljZUlkZW50aXR5VG9rZW46IHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbixcblx0XHRcdHB1c2g6IHtcblx0XHRcdFx0cmVjaXBpZW50OiB0aGlzLnB1c2gucmVjaXBpZW50LFxuXHRcdFx0XHRzdGF0ZTogdGhpcy5wdXNoLnN0YXRlLFxuXHRcdFx0XHRlcnJvclJlYXNvbjogdGhpcy5wdXNoLmVycm9yUmVhc29uXG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXHREZXZpY2VEZXRhaWxzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSAnW0RldmljZURldGFpbHMnO1xuXHRcdGlmKHRoaXMuaWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgaWQ9JyArIHRoaXMuaWQ7XG5cdFx0aWYodGhpcy5wbGF0Zm9ybSlcblx0XHRcdHJlc3VsdCArPSAnOyBwbGF0Zm9ybT0nICsgdGhpcy5wbGF0Zm9ybTtcblx0XHRpZih0aGlzLmZvcm1GYWN0b3IpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZm9ybUZhY3Rvcj0nICsgdGhpcy5mb3JtRmFjdG9yO1xuXHRcdGlmKHRoaXMuY2xpZW50SWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG5cdFx0aWYodGhpcy5tZXRhZGF0YSlcblx0XHRcdHJlc3VsdCArPSAnOyBtZXRhZGF0YT0nICsgdGhpcy5tZXRhZGF0YTtcblx0XHRpZih0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pXG5cdFx0XHRyZXN1bHQgKz0gJzsgZGV2aWNlSWRlbnRpdHlUb2tlbj0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKTtcblx0XHRpZih0aGlzLnB1c2gucmVjaXBpZW50KVxuXHRcdFx0cmVzdWx0ICs9ICc7IHB1c2gucmVjaXBpZW50PScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2gucmVjaXBpZW50KTtcblx0XHRpZih0aGlzLnB1c2guc3RhdGUpXG5cdFx0XHRyZXN1bHQgKz0gJzsgcHVzaC5zdGF0ZT0nICsgdGhpcy5wdXNoLnN0YXRlO1xuXHRcdGlmKHRoaXMucHVzaC5lcnJvclJlYXNvbilcblx0XHRcdHJlc3VsdCArPSAnOyBwdXNoLmVycm9yUmVhc29uPScgKyB0aGlzLnB1c2guZXJyb3JSZWFzb247XG5cdFx0aWYodGhpcy5wdXNoLm1ldGFkYXRhKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHB1c2gubWV0YWRhdGE9JyArIHRoaXMucHVzaC5tZXRhZGF0YTtcblx0XHRyZXN1bHQgKz0gJ10nO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0RGV2aWNlRGV0YWlscy50b1JlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQm9keTtcblxuXHREZXZpY2VEZXRhaWxzLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbihib2R5LCBmb3JtYXQpIHtcblx0XHRpZihmb3JtYXQpIHtcblx0XHRcdGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0fVxuXG5cdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNBcnJheShib2R5KSkge1xuXHRcdFx0cmV0dXJuIERldmljZURldGFpbHMuZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzKGJvZHkpO1xuXHRcdH1cblx0fTtcblxuXHREZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4obmV3IERldmljZURldGFpbHMoKSwgdmFsdWVzKTtcblx0fTtcblxuXHREZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHJlc3VsdFtpXSA9IERldmljZURldGFpbHMuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0cmV0dXJuIERldmljZURldGFpbHM7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZXZpY2VkZXRhaWxzID0gKGRldmljZWRldGFpbHNfRGV2aWNlRGV0YWlscyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2h0dHAuanNcbnZhciBodHRwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvYnVmZmVydXRpbHMuanNcbnZhciBidWZmZXJ1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcmVzb3VyY2UuanNcblxuXG5cblxuXG5cblxudmFyIHJlc291cmNlX1Jlc291cmNlID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbXNncGFjayA9IHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubXNncGFjaztcblxuXHRmdW5jdGlvbiBSZXNvdXJjZSgpIHt9XG5cblx0ZnVuY3Rpb24gd2l0aEF1dGhEZXRhaWxzKHJlc3QsIGhlYWRlcnMsIHBhcmFtcywgZXJyQ2FsbGJhY2ssIG9wQ2FsbGJhY2spIHtcblx0XHRpZiAoaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0F1dGhIZWFkZXJzKSB7XG5cdFx0XHRyZXN0LmF1dGguZ2V0QXV0aEhlYWRlcnMoZnVuY3Rpb24oZXJyLCBhdXRoSGVhZGVycykge1xuXHRcdFx0XHRpZihlcnIpXG5cdFx0XHRcdFx0ZXJyQ2FsbGJhY2soZXJyKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdG9wQ2FsbGJhY2sodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oYXV0aEhlYWRlcnMsIGhlYWRlcnMpLCBwYXJhbXMpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3QuYXV0aC5nZXRBdXRoUGFyYW1zKGZ1bmN0aW9uKGVyciwgYXV0aFBhcmFtcykge1xuXHRcdFx0XHRpZihlcnIpXG5cdFx0XHRcdFx0ZXJyQ2FsbGJhY2soZXJyKTtcblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdG9wQ2FsbGJhY2soaGVhZGVycywgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oYXV0aFBhcmFtcywgcGFyYW1zKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiB1bmVudmVsb3BlKGNhbGxiYWNrLCBmb3JtYXQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZXJyLCBib2R5LCBvdXRlckhlYWRlcnMsIHVucGFja2VkLCBvdXRlclN0YXR1c0NvZGUpIHtcblx0XHRcdGlmKGVyciAmJiAhYm9keSkge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKCF1bnBhY2tlZCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZihib2R5LnN0YXR1c0NvZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvKiBFbnZlbG9wZSBhbHJlYWR5IHVud3JhcHBlZCBieSB0aGUgdHJhbnNwb3J0ICovXG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgYm9keSwgb3V0ZXJIZWFkZXJzLCB0cnVlLCBvdXRlclN0YXR1c0NvZGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciB3cmFwcGVkU3RhdHVzQ29kZSA9IGJvZHkuc3RhdHVzQ29kZSxcblx0XHRcdFx0cmVzcG9uc2UgPSBib2R5LnJlc3BvbnNlLFxuXHRcdFx0XHR3cmFwcGVkSGVhZGVycyA9IGJvZHkuaGVhZGVycztcblxuXHRcdFx0aWYod3JhcHBlZFN0YXR1c0NvZGUgPCAyMDAgfHwgd3JhcHBlZFN0YXR1c0NvZGUgPj0gMzAwKSB7XG5cdFx0XHRcdC8qIGhhbmRsZSB3cmFwcGVkIGVycm9ycyAqL1xuXHRcdFx0XHR2YXIgd3JhcHBlZEVyciA9IChyZXNwb25zZSAmJiByZXNwb25zZS5lcnJvcikgfHwgZXJyO1xuXHRcdFx0XHRpZighd3JhcHBlZEVycikge1xuXHRcdFx0XHRcdHdyYXBwZWRFcnIgPSBuZXcgRXJyb3IoXCJFcnJvciBpbiB1bmVudmVsb3BpbmcgXCIgKyBib2R5KTtcblx0XHRcdFx0XHR3cmFwcGVkRXJyLnN0YXR1c0NvZGUgPSB3cmFwcGVkU3RhdHVzQ29kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayh3cmFwcGVkRXJyLCByZXNwb25zZSwgd3JhcHBlZEhlYWRlcnMsIHRydWUsIHdyYXBwZWRTdGF0dXNDb2RlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCB3cmFwcGVkSGVhZGVycywgdHJ1ZSwgd3JhcHBlZFN0YXR1c0NvZGUpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJhbVN0cmluZyhwYXJhbXMpIHtcblx0XHR2YXIgcGFyYW1QYWlycyA9IFtdO1xuXHRcdGlmIChwYXJhbXMpIHtcblx0XHRcdGZvciAodmFyIG5lZWRsZSBpbiBwYXJhbXMpIHtcblx0XHRcdFx0cGFyYW1QYWlycy5wdXNoKG5lZWRsZSArICc9JyArIHBhcmFtc1tuZWVkbGVdKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHBhcmFtUGFpcnMuam9pbignJicpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSB7XG5cdFx0cmV0dXJuIHBhdGggKyAocGFyYW1zID8gJz8nIDogJycpICsgcGFyYW1TdHJpbmcocGFyYW1zKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvZ1Jlc3BvbnNlSGFuZGxlcihjYWxsYmFjaywgbWV0aG9kLCBwYXRoLCBwYXJhbXMpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1JlY2VpdmVkIEVycm9yOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEVycm9yOiAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsXG5cdFx0XHRcdFx0J1JlY2VpdmVkOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEhlYWRlcnM6ICcgKyBwYXJhbVN0cmluZyhoZWFkZXJzKSArICc7IFN0YXR1c0NvZGU6ICcgKyBzdGF0dXNDb2RlICsgJzsgQm9keTogJyArIChidWZmZXJ1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0J1ZmZlcihib2R5KSA/IGJvZHkudG9TdHJpbmcoKSA6IGJvZHkpKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTsgfVxuXHRcdH1cblx0fVxuXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2goaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5tZXRob2RzV2l0aG91dEJvZHksIGZ1bmN0aW9uKG1ldGhvZCkge1xuXHRcdFJlc291cmNlW21ldGhvZF0gPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG5cdFx0XHRSZXNvdXJjZVsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIG51bGwsIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xuXHRcdH07XG5cdH0pO1xuXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2goaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5tZXRob2RzV2l0aEJvZHksIGZ1bmN0aW9uKG1ldGhvZCkge1xuXHRcdFJlc291cmNlW21ldGhvZF0gPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBib2R5LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG5cdFx0XHRSZXNvdXJjZVsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIGJvZHksIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xuXHRcdH07XG5cdH0pO1xuXG5cdFJlc291cmNlWydkbyddID0gZnVuY3Rpb24obWV0aG9kLCByZXN0LCBwYXRoLCBib2R5LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zaG91bGRMb2cobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTykpIHtcblx0XHRcdGNhbGxiYWNrID0gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCBtZXRob2QsIHBhdGgsIG9yaWdwYXJhbXMpO1xuXHRcdH1cblxuXHRcdGlmKGVudmVsb3BlKSB7XG5cdFx0XHRjYWxsYmFjayA9IChjYWxsYmFjayAmJiB1bmVudmVsb3BlKGNhbGxiYWNrLCBlbnZlbG9wZSkpO1xuXHRcdFx0KG9yaWdwYXJhbXMgPSAob3JpZ3BhcmFtcyB8fCB7fSkpWydlbnZlbG9wZSddID0gZW52ZWxvcGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZG9SZXF1ZXN0KGhlYWRlcnMsIHBhcmFtcykge1xuXHRcdFx0aWYgKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zaG91bGRMb2cobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTykpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBhcmdzID0gW3Jlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgZnVuY3Rpb24oZXJyLCByZXMsIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHRcdGlmKGVyciAmJiBhdXRoW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzVG9rZW5FcnIoZXJyKSkge1xuXHRcdFx0XHRcdC8qIHRva2VuIGhhcyBleHBpcmVkLCBzbyBnZXQgYSBuZXcgb25lICovXG5cdFx0XHRcdFx0cmVzdC5hdXRoLmF1dGhvcml6ZShudWxsLCBudWxsLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvKiByZXRyeSAuLi4gKi9cblx0XHRcdFx0XHRcdHdpdGhBdXRoRGV0YWlscyhyZXN0LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgY2FsbGJhY2ssIGRvUmVxdWVzdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG5cdFx0XHR9XTtcblx0XHRcdGlmICghYm9keSkge1xuXHRcdFx0XHRhcmdzLnNwbGljZSgzLCAxKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zaG91bGRMb2cobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTykpIHtcblx0XHRcdFx0dmFyIGRlY29kZWRCb2R5ID0gYm9keTtcblx0XHRcdFx0aWYgKChoZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnJykuaW5kZXhPZignbXNncGFjaycpID4gMCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRkZWNvZGVkQm9keSA9IG1zZ3BhY2suZGVjb2RlKGJvZHkpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGRlY29kZUVycikge1xuXHRcdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nIE1zZ1BhY2sgRGVjb2RpbmcgRXJyb3I6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZGVjb2RlRXJyKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnU2VuZGluZzsgJyArIHVybEZyb21QYXRoQW5kUGFyYW1zKHBhdGgsIHBhcmFtcykgKyAnOyBCb2R5OiAnICsgZGVjb2RlZEJvZHkpO1xuXHRcdFx0fVxuXHRcdFx0aHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdHdpdGhBdXRoRGV0YWlscyhyZXN0LCBvcmlnaGVhZGVycywgb3JpZ3BhcmFtcywgY2FsbGJhY2ssIGRvUmVxdWVzdCk7XG5cdH07XG5cblx0cmV0dXJuIFJlc291cmNlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50X3Jlc291cmNlID0gKHJlc291cmNlX1Jlc291cmNlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9wYWdpbmF0ZWRyZXNvdXJjZS5qc1xuXG5cblxuXG5cbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV9QYWdpbmF0ZWRSZXNvdXJjZSA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBnZXRSZWxQYXJhbXMobGlua1VybCkge1xuXHRcdHZhciB1cmxNYXRjaCA9IGxpbmtVcmwubWF0Y2goL15cXC5cXC8oXFx3KylcXD8oLiopJC8pO1xuXHRcdHJldHVybiB1cmxNYXRjaCAmJiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wYXJzZVF1ZXJ5U3RyaW5nKHVybE1hdGNoWzJdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlUmVsTGlua3MobGlua0hlYWRlcikge1xuXHRcdGlmKHR5cGVvZihsaW5rSGVhZGVyKSA9PSAnc3RyaW5nJylcblx0XHRcdGxpbmtIZWFkZXIgPSBsaW5rSGVhZGVyLnNwbGl0KCcsJyk7XG5cblx0XHR2YXIgcmVsUGFyYW1zID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxpbmtIZWFkZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBsaW5rTWF0Y2ggPSBsaW5rSGVhZGVyW2ldLm1hdGNoKC9eXFxzKjwoLispPjtcXHMqcmVsPVwiKFxcdyspXCIkLyk7XG5cdFx0XHRpZihsaW5rTWF0Y2gpIHtcblx0XHRcdFx0dmFyIHBhcmFtcyA9IGdldFJlbFBhcmFtcyhsaW5rTWF0Y2hbMV0pO1xuXHRcdFx0XHRpZihwYXJhbXMpXG5cdFx0XHRcdFx0cmVsUGFyYW1zW2xpbmtNYXRjaFsyXV0gPSBwYXJhbXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZWxQYXJhbXM7XG5cdH1cblxuXHRmdW5jdGlvbiBQYWdpbmF0ZWRSZXNvdXJjZShyZXN0LCBwYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgYm9keUhhbmRsZXIsIHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdFx0dGhpcy5wYXRoID0gcGF0aDtcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdHRoaXMuZW52ZWxvcGUgPSBlbnZlbG9wZTtcblx0XHR0aGlzLmJvZHlIYW5kbGVyID0gYm9keUhhbmRsZXI7XG5cdFx0dGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgfHwgZmFsc2U7XG5cdH1cblxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ubWV0aG9kc1dpdGhvdXRCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGNsaWVudF9yZXNvdXJjZVttZXRob2RdKHNlbGYucmVzdCwgc2VsZi5wYXRoLCBzZWxmLmhlYWRlcnMsIHBhcmFtcywgc2VsZi5lbnZlbG9wZSwgZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0XHRzZWxmLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSlcblxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ubWV0aG9kc1dpdGhCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGNsaWVudF9yZXNvdXJjZVttZXRob2RdKHNlbGYucmVzdCwgc2VsZi5wYXRoLCBib2R5LCBzZWxmLmhlYWRlcnMsIHBhcmFtcywgc2VsZi5lbnZlbG9wZSwgZnVuY3Rpb24oZXJyLCByZXNib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0XHRpZihjYWxsYmFjaykge1xuXHRcdFx0XHRcdHNlbGYuaGFuZGxlUGFnZShlcnIsIHJlc2JvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIHJldHVybkVyck9ubHkoZXJyLCBib2R5LCB1c2VIUFIpIHtcblx0XHQvKiBJZiB1c2luZyBodHRwUGFnaW5hdGVkUmVzcG9uc2UsIGVycm9ycyBmcm9tIEFibHkgYXJlIHJldHVybmVkIGFzIHBhcnQgb2Zcblx0XHQgKiB0aGUgSFBSLCBvbmx5IGRvIGNhbGxiYWNrKGVycikgZm9yIG5ldHdvcmsgZXJyb3JzIGV0Yy4gd2hpY2ggZG9uJ3Rcblx0XHQgKiByZXR1cm4gYSBib2R5IGFuZC9vciBoYXZlIG5vIGFibHktb3JpZ2luYXRlZCBlcnJvciBjb2RlIChub24tbnVtZXJpY1xuXHRcdCAqIGVycm9yIGNvZGVzIG9yaWdpbmF0ZSBmcm9tIG5vZGUpICovXG5cdFx0cmV0dXJuICEodXNlSFBSICYmIChib2R5IHx8IHR5cGVvZiBlcnIuY29kZSA9PT0gJ251bWJlcicpKTtcblx0fVxuXG5cdFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5oYW5kbGVQYWdlID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spIHtcblx0XHRpZihlcnIgJiYgcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUGFnaW5hdGVkUmVzb3VyY2UuaGFuZGxlUGFnZSgpJywgJ1VuZXhwZWN0ZWQgZXJyb3IgZ2V0dGluZyByZXNvdXJjZTogZXJyID0gJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBpdGVtcywgbGlua0hlYWRlciwgcmVsUGFyYW1zO1xuXHRcdHRyeSB7XG5cdFx0XHRpdGVtcyA9IHRoaXMuYm9keUhhbmRsZXIoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0LyogSWYgd2UgZ290IGFuIGVycm9yLCB0aGUgZmFpbHVyZSB0byBwYXJzZSB0aGUgYm9keSBpcyBhbG1vc3QgY2VydGFpbmx5XG5cdFx0XHQgKiBkdWUgdG8gdGhhdCwgc28gY2Igd2l0aCB0aGF0IGluIHByZWZlcmVuY2UgdG8gdGhlIHBhcnNlIGVycm9yICovXG5cdFx0XHRjYWxsYmFjayhlcnIgfHwgZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYoaGVhZGVycyAmJiAobGlua0hlYWRlciA9IChoZWFkZXJzWydMaW5rJ10gfHwgaGVhZGVyc1snbGluayddKSkpIHtcblx0XHRcdHJlbFBhcmFtcyA9IHBhcnNlUmVsTGlua3MobGlua0hlYWRlcik7XG5cdFx0fVxuXG5cdFx0aWYodGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcblx0XHRcdGNhbGxiYWNrKG51bGwsIG5ldyBIdHRwUGFnaW5hdGVkUmVzcG9uc2UodGhpcywgaXRlbXMsIGhlYWRlcnMsIHN0YXR1c0NvZGUsIHJlbFBhcmFtcywgZXJyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbGxiYWNrKG51bGwsIG5ldyBQYWdpbmF0ZWRSZXN1bHQodGhpcywgaXRlbXMsIHJlbFBhcmFtcykpO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBQYWdpbmF0ZWRSZXN1bHQocmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpIHtcblx0XHR0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XG5cdFx0dGhpcy5pdGVtcyA9IGl0ZW1zO1xuXG5cdFx0aWYocmVsUGFyYW1zKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRpZignZmlyc3QnIGluIHJlbFBhcmFtcykge1xuXHRcdFx0XHR0aGlzLmZpcnN0ID0gZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHRpZighY2IgJiYgc2VsZi5yZXNvdXJjZS5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkoc2VsZiwgJ2ZpcnN0JywgW10pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWxmLmdldChyZWxQYXJhbXMuZmlyc3QsIGNiKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmKCdjdXJyZW50JyBpbiByZWxQYXJhbXMpIHtcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gZnVuY3Rpb24oY2IpIHtcblx0XHRcdFx0XHRpZighY2IgJiYgc2VsZi5yZXNvdXJjZS5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkoc2VsZiwgJ2N1cnJlbnQnLCBbXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuZ2V0KHJlbFBhcmFtcy5jdXJyZW50LCBjYik7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm5leHQgPSBmdW5jdGlvbihjYikge1xuXHRcdFx0XHRpZighY2IgJiYgc2VsZi5yZXNvdXJjZS5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHNlbGYsICduZXh0JywgW10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCduZXh0JyBpbiByZWxQYXJhbXMpIHtcblx0XHRcdFx0XHRzZWxmLmdldChyZWxQYXJhbXMubmV4dCwgY2IpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNiKG51bGwsIG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmhhc05leHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuICgnbmV4dCcgaW4gcmVsUGFyYW1zKSB9O1xuXHRcdFx0dGhpcy5pc0xhc3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuICF0aGlzLmhhc05leHQoKTsgfVxuXHRcdH1cblx0fVxuXG5cdC8qIFdlIGFzc3VtZSB0aGF0IG9ubHkgdGhlIGluaXRpYWwgcmVxdWVzdCBjYW4gYmUgYSBQT1NULCBhbmQgdGhhdCBhY2Nlc3Npbmdcblx0ICogdGhlIHJlc3Qgb2YgYSBtdWx0aXBhZ2Ugc2V0IG9mIHJlc3VsdHMgY2FuIGFsd2F5cyBiZSBkb25lIHdpdGggR0VUICovXG5cdFBhZ2luYXRlZFJlc3VsdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXMgPSB0aGlzLnJlc291cmNlO1xuXHRcdGNsaWVudF9yZXNvdXJjZS5nZXQocmVzLnJlc3QsIHJlcy5wYXRoLCByZXMuaGVhZGVycywgcGFyYW1zLCByZXMuZW52ZWxvcGUsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRcdHJlcy5oYW5kbGVQYWdlKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcblx0XHR9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBIdHRwUGFnaW5hdGVkUmVzcG9uc2UocmVzb3VyY2UsIGl0ZW1zLCBoZWFkZXJzLCBzdGF0dXNDb2RlLCByZWxQYXJhbXMsIGVycikge1xuXHRcdFBhZ2luYXRlZFJlc3VsdC5jYWxsKHRoaXMsIHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKTtcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHRcdHRoaXMuc3VjY2VzcyA9IHN0YXR1c0NvZGUgPCAzMDAgJiYgc3RhdHVzQ29kZSA+PSAyMDA7XG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycztcblx0XHR0aGlzLmVycm9yQ29kZSA9IGVyciAmJiBlcnIuY29kZTtcblx0XHR0aGlzLmVycm9yTWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhIdHRwUGFnaW5hdGVkUmVzcG9uc2UsIFBhZ2luYXRlZFJlc3VsdCk7XG5cblx0cmV0dXJuIFBhZ2luYXRlZFJlc291cmNlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGFnaW5hdGVkcmVzb3VyY2UgPSAocGFnaW5hdGVkcmVzb3VyY2VfUGFnaW5hdGVkUmVzb3VyY2UpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8uanNcbnZhciBlcnJvcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24uanNcblxuXG52YXIgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fUHVzaENoYW5uZWxTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24oKSB7XG5cdFx0dGhpcy5jaGFubmVsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZGV2aWNlSWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0UHVzaENoYW5uZWxTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjaGFubmVsOiB0aGlzLmNoYW5uZWwsXG5cdFx0XHRkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcblx0XHRcdGNsaWVudElkOiB0aGlzLmNsaWVudElkXG5cdFx0fTtcblx0fTtcblxuXHRQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1tQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbic7XG5cdFx0aWYodGhpcy5jaGFubmVsKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGNoYW5uZWw9JyArIHRoaXMuY2hhbm5lbDtcblx0XHRpZih0aGlzLmRldmljZUlkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGRldmljZUlkPScgKyB0aGlzLmRldmljZUlkO1xuXHRcdGlmKHRoaXMuY2xpZW50SWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnRvUmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVCb2R5O1xuXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbihib2R5LCBmb3JtYXQpIHtcblx0XHRpZihmb3JtYXQpIHtcblx0XHRcdGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0fVxuXG5cdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNBcnJheShib2R5KSkge1xuXHRcdFx0cmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXNBcnJheShib2R5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMoYm9keSk7XG5cdFx0fVxuXHR9O1xuXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4obmV3IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uKCksIHZhbHVlcyk7XG5cdH07XG5cblx0UHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0dmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgcmVzdWx0W2ldID0gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0cmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24gPSAocHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fUHVzaENoYW5uZWxTdWJzY3JpcHRpb24pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3B1c2guanNcblxuXG5cblxuXG5cblxuXG52YXIgcHVzaF9QdXNoID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0ZnVuY3Rpb24gUHVzaChyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLmFkbWluID0gbmV3IEFkbWluKHJlc3QpO1xuXHR9XG5cblx0ZnVuY3Rpb24gQWRtaW4ocmVzdCkge1xuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XG5cdFx0dGhpcy5kZXZpY2VSZWdpc3RyYXRpb25zID0gbmV3IERldmljZVJlZ2lzdHJhdGlvbnMocmVzdCk7XG5cdFx0dGhpcy5jaGFubmVsU3Vic2NyaXB0aW9ucyA9IG5ldyBDaGFubmVsU3Vic2NyaXB0aW9ucyhyZXN0KTtcblx0fVxuXG5cdEFkbWluLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24ocmVjaXBpZW50LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0O1xuXHRcdHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRyZXF1ZXN0Qm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHtyZWNpcGllbnQ6IHJlY2lwaWVudH0sIHBheWxvYWQpLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0cGFyYW1zID0ge307XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcblxuXHRcdHJlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQm9keShyZXF1ZXN0Qm9keSwgZm9ybWF0KTtcblx0XHRjbGllbnRfcmVzb3VyY2UucG9zdChyZXN0LCAnL3B1c2gvcHVibGlzaCcsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gRGV2aWNlUmVnaXN0cmF0aW9ucyhyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0fVxuXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihkZXZpY2UsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3Q7XG5cdFx0dmFyIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdHJlcXVlc3RCb2R5ID0gZGV2aWNlZGV0YWlscy5mcm9tVmFsdWVzKGRldmljZSksXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdFBvc3RIZWFkZXJzKGZvcm1hdCksXG5cdFx0XHRwYXJhbXMgPSB7fTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc2F2ZScsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xuXG5cdFx0cmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVCb2R5KHJlcXVlc3RCb2R5LCBmb3JtYXQpO1xuXHRcdGNsaWVudF9yZXNvdXJjZS5wdXQocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UuaWQpLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0Y2FsbGJhY2soZXJyLCAhZXJyICYmIGRldmljZWRldGFpbHMuZnJvbVJlc3BvbnNlQm9keShib2R5LCAhdW5wYWNrZWQgJiYgZm9ybWF0KSk7XG5cdFx0fSk7XG5cdH07XG5cblx0RGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZGV2aWNlSWRPckRldGFpbHMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KSxcblx0XHRcdGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIGRldmljZUlkICE9PSAnc3RyaW5nJyB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI2dldCBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHMnLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRjbGllbnRfcmVzb3VyY2UuZ2V0KHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLCBoZWFkZXJzLCB7fSwgZmFsc2UsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdGNhbGxiYWNrKGVyciwgIWVyciAmJiBkZXZpY2VkZXRhaWxzLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCkpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdsaXN0JywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiBkZXZpY2VkZXRhaWxzLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCk7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHREZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihkZXZpY2VJZE9yRGV0YWlscywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0cGFyYW1zID0ge30sXG5cdFx0XHRkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdyZW1vdmUnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBkZXZpY2VJZCAhPT0gJ3N0cmluZycgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNyZW1vdmUgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzJywgNDAwMDAsIDQwMCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcblxuXHRcdGNsaWVudF9yZXNvdXJjZVsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcblx0fTtcblxuXHREZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdyZW1vdmVXaGVyZScsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xuXG5cdFx0Y2xpZW50X3Jlc291cmNlWydkZWxldGUnXShyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucycsIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBDaGFubmVsU3Vic2NyaXB0aW9ucyhyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0fVxuXG5cdENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0O1xuXHRcdHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRyZXF1ZXN0Qm9keSA9IHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMoc3Vic2NyaXB0aW9uKSxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KSxcblx0XHRcdHBhcmFtcyA9IHt9O1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdzYXZlJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHRyZXF1ZXN0Qm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUJvZHkocmVxdWVzdEJvZHksIGZvcm1hdCk7XG5cdFx0Y2xpZW50X3Jlc291cmNlLnBvc3QocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdGNhbGxiYWNrKGVyciwgIWVyciAmJiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbi5mcm9tUmVzcG9uc2VCb2R5KGJvZHksICF1bnBhY2tlZCAmJiBmb3JtYXQpKTtcblx0XHR9KTtcblx0fTtcblxuXHRDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2xpc3QnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbi5mcm9tUmVzcG9uc2VCb2R5KGJvZHksICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlbW92ZVdoZXJlJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHRjbGllbnRfcmVzb3VyY2VbJ2RlbGV0ZSddKHJlc3QsICcvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9ucycsIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcblx0fTtcblxuXHQvKiBDaGFubmVsU3Vic2NyaXB0aW9ucyBoYXZlIG5vIHVuaXF1ZSBpZDsgcmVtb3Zpbmcgb25lIGlzIGVxdWl2YWxlbnQgdG8gcmVtb3ZlV2hlcmUgYnkgaXRzIHByb3BlcnRpZXMgKi9cblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZSA9IENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZTtcblxuXHRDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUubGlzdENoYW5uZWxzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnbGlzdENoYW5uZWxzJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsICcvcHVzaC9jaGFubmVscycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0dmFyIGYgPSAhdW5wYWNrZWQgJiYgZm9ybWF0O1xuXG5cdFx0XHRpZihmKSB7XG5cdFx0XHRcdGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGJvZHlbaV0gPSBTdHJpbmcoYm9keVtpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYm9keTtcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdHJldHVybiBQdXNoO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcHVzaCA9IChwdXNoX1B1c2gpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2V2ZW50ZW1pdHRlci5qc1xudmFyIGV2ZW50ZW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL3ByZXNlbmNlbWVzc2FnZS5qc1xudmFyIHByZXNlbmNlbWVzc2FnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3ByZXNlbmNlLmpzXG5cblxuXG5cblxuXG5cbnZhciBwcmVzZW5jZV9QcmVzZW5jZSA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cdGZ1bmN0aW9uIFByZXNlbmNlKGNoYW5uZWwpIHtcblx0XHR0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuXHRcdHRoaXMuYmFzZVBhdGggPSBjaGFubmVsLmJhc2VQYXRoICsgJy9wcmVzZW5jZSc7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoUHJlc2VuY2UsIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblx0UHJlc2VuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdQcmVzZW5jZS5nZXQoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcmVzdCA9IHRoaXMuY2hhbm5lbC5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnM7XG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCB0aGlzLmJhc2VQYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVJlc3BvbnNlQm9keShib2R5LCBvcHRpb25zLCAhdW5wYWNrZWQgJiYgZm9ybWF0KTtcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFByZXNlbmNlLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1ByZXNlbmNlLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcblx0XHR0aGlzLl9oaXN0b3J5KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFByZXNlbmNlLnByb3RvdHlwZS5faGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ19oaXN0b3J5JywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciByZXN0ID0gdGhpcy5jaGFubmVsLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0Y2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnM7XG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9oaXN0b3J5JywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21SZXNwb25zZUJvZHkoYm9keSwgb3B0aW9ucywgIXVucGFja2VkICYmIGZvcm1hdCk7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRyZXR1cm4gUHJlc2VuY2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcHJlc2VuY2UgPSAocHJlc2VuY2VfUHJlc2VuY2UpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9jcnlwdG8uanNcbnZhciB1dGlsX2NyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9tZXNzYWdlLmpzXG52YXIgdHlwZXNfbWVzc2FnZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvY2hhbm5lbC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBjaGFubmVsX0NoYW5uZWwgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXHR2YXIgTVNHX0lEX0VOVFJPUFlfQllURVMgPSA5O1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBDaGFubmVsKHJlc3QsIG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQ2hhbm5lbCgpJywgJ3N0YXJ0ZWQ7IG5hbWUgPSAnICsgbmFtZSk7XG5cdFx0ZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdHRoaXMuYmFzZVBhdGggPSAnL2NoYW5uZWxzLycgKyBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XG5cdFx0dGhpcy5wcmVzZW5jZSA9IG5ldyBjbGllbnRfcHJlc2VuY2UodGhpcyk7XG5cdFx0dGhpcy5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhDaGFubmVsLCBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdENoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dGhpcy5jaGFubmVsT3B0aW9ucyA9IG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmKG9wdGlvbnMuY2lwaGVyKSB7XG5cdFx0XHRpZighdXRpbF9jcnlwdG9bXCJhXCIgLyogZGVmYXVsdCAqL10pIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkJyk7XG5cdFx0XHR2YXIgY2lwaGVyID0gdXRpbF9jcnlwdG9bXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0Q2lwaGVyKG9wdGlvbnMuY2lwaGVyKTtcblx0XHRcdG9wdGlvbnMuY2lwaGVyID0gY2lwaGVyLmNpcGhlclBhcmFtcztcblx0XHRcdG9wdGlvbnMuY2hhbm5lbENpcGhlciA9IGNpcGhlci5jaXBoZXI7XG5cdFx0fSBlbHNlIGlmKCdjaXBoZXInIGluIG9wdGlvbnMpIHtcblx0XHRcdC8qIERvbid0IGRlYWN0aXZhdGUgYW4gZXhpc3RpbmcgY2lwaGVyIHVubGVzcyBvcHRpb25zXG5cdFx0XHQgKiBoYXMgYSAnY2lwaGVyJyBrZXkgdGhhdCdzIGZhbHNleSAqL1xuXHRcdFx0b3B0aW9ucy5jaXBoZXIgPSBudWxsO1xuXHRcdFx0b3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0Q2hhbm5lbC5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdDaGFubmVsLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMubmFtZSk7XG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2hpc3RvcnkocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0Q2hhbm5lbC5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0Y2hhbm5lbCA9IHRoaXM7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL21lc3NhZ2VzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0ZnVuY3Rpb24gYWxsRW1wdHlJZHMobWVzc2FnZXMpIHtcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRXZlcnkobWVzc2FnZXMsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHRcdHJldHVybiAhbWVzc2FnZS5pZDtcblx0XHR9KTtcblx0fVxuXG5cdENoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0Zmlyc3QgPSBhcmd1bWVudHNbMF0sXG5cdFx0XHRzZWNvbmQgPSBhcmd1bWVudHNbMV0sXG5cdFx0XHRjYWxsYmFjayA9IGFyZ3VtZW50c1thcmdDb3VudCAtIDFdLFxuXHRcdFx0bWVzc2FnZXMsXG5cdFx0XHRwYXJhbXMsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmKHR5cGVvZihjYWxsYmFjaykgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycgfHwgZmlyc3QgPT09IG51bGwpIHtcblx0XHRcdC8qIChuYW1lLCBkYXRhLCAuLi4pICovXG5cdFx0XHRtZXNzYWdlcyA9IFt0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe25hbWU6IGZpcnN0LCBkYXRhOiBzZWNvbmR9KV07XG5cdFx0XHRwYXJhbXMgPSBhcmd1bWVudHNbMl07XG5cdFx0fSBlbHNlIGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzT2JqZWN0KGZpcnN0KSkge1xuXHRcdFx0bWVzc2FnZXMgPSBbdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKGZpcnN0KV07XG5cdFx0XHRwYXJhbXMgPSBhcmd1bWVudHNbMV07XG5cdFx0fSBlbHNlIGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkoZmlyc3QpKSB7XG5cdFx0XHRtZXNzYWdlcyA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlc0FycmF5KGZpcnN0KTtcblx0XHRcdHBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzJywgNDAwMTMsIDQwMCk7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcgfHwgIXBhcmFtcykge1xuXHRcdFx0LyogTm8gcGFyYW1zIHN1cHBsaWVkIChzbyBhZnRlci1tZXNzYWdlIGFyZ3VtZW50IGlzIGp1c3QgdGhlIGNhbGxiYWNrIG9yIHVuZGVmaW5lZCkgKi9cblx0XHRcdHBhcmFtcyA9IHt9O1xuXHRcdH1cblxuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0b3B0aW9ucyA9IHJlc3Qub3B0aW9ucyxcblx0XHRcdGZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSByZXN0Lm9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYob3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgb3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyAmJiBhbGxFbXB0eUlkcyhtZXNzYWdlcykpIHtcblx0XHRcdHZhciBtc2dJZEJhc2UgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5yYW5kb21TdHJpbmcoTVNHX0lEX0VOVFJPUFlfQllURVMpO1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChtZXNzYWdlcywgZnVuY3Rpb24obWVzc2FnZSwgaW5kZXgpIHtcblx0XHRcdFx0bWVzc2FnZS5pZCA9IG1zZ0lkQmFzZSArICc6JyArIGluZGV4LnRvU3RyaW5nKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUFycmF5KG1lc3NhZ2VzLCB0aGlzLmNoYW5uZWxPcHRpb25zLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIFJTTDFpICovXG5cdFx0XHR2YXIgc2l6ZSA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKSxcblx0XHRcdFx0bWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuXHRcdFx0aWYoc2l6ZSA+IG1heE1lc3NhZ2VTaXplKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ01heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAoIHdhcyAnICsgc2l6ZSArICcgYnl0ZXM7IGxpbWl0IGlzICcgKyBtYXhNZXNzYWdlU2l6ZSArICcgYnl0ZXMpJywgNDAwMDksIDQwMCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYuX3B1Ymxpc2godHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5zZXJpYWxpemUobWVzc2FnZXMsIGZvcm1hdCksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdH0pO1xuXHR9O1xuXG5cdENoYW5uZWwucHJvdG90eXBlLl9wdWJsaXNoID0gZnVuY3Rpb24ocmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRjbGllbnRfcmVzb3VyY2UucG9zdCh0aGlzLnJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL21lc3NhZ2VzJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRyZXR1cm4gQ2hhbm5lbDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaWVudF9jaGFubmVsID0gKGNoYW5uZWxfQ2hhbm5lbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9zdGF0cy5qc1xuXG5cbnZhciBzdGF0c19TdGF0cyA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBNZXNzYWdlQ291bnQodmFsdWVzKSB7XG5cdFx0dGhpcy5jb3VudCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmNvdW50KSB8fCAwO1xuXHRcdHRoaXMuZGF0YSA9ICh2YWx1ZXMgJiYgdmFsdWVzLmRhdGEpIHx8IDA7XG5cdFx0dGhpcy51bmNvbXByZXNzZWREYXRhID0gKHZhbHVlcyAmJiB2YWx1ZXMudW5jb21wcmVzc2VkRGF0YSkgfHwgMDtcblx0XHR0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcblx0XHR0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVzc2FnZUNhdGVnb3J5KHZhbHVlcykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRNZXNzYWdlQ291bnQuY2FsbCh0aGlzLCB2YWx1ZXMpO1xuXHRcdHRoaXMuY2F0ZWdvcnkgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKHZhbHVlcyAmJiB2YWx1ZXMuY2F0ZWdvcnkpIHtcblx0XHRcdHRoaXMuY2F0ZWdvcnkgPSB7IH07XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5mb3JJbk93bk5vbk51bGxQcm9wcyh2YWx1ZXMuY2F0ZWdvcnksIGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0c2VsZi5jYXRlZ29yeVtwcm9wXSA9IG5ldyBNZXNzYWdlQ291bnQodmFsdWVzLmNhdGVnb3J5W3Byb3BdKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFJlc291cmNlQ291bnQodmFsdWVzKSB7XG5cdFx0dGhpcy5wZWFrID0gKHZhbHVlcyAmJiB2YWx1ZXMucGVhaykgfHwgMDtcblx0XHR0aGlzLm1pbiA9ICh2YWx1ZXMgJiYgdmFsdWVzLm1pbikgfHwgMDtcblx0XHR0aGlzLm1lYW4gPSAodmFsdWVzICYmIHZhbHVlcy5tZWFuKSB8fCAwO1xuXHRcdHRoaXMub3BlbmVkID0gKHZhbHVlcyAmJiB2YWx1ZXMub3BlbmVkKSB8fCAwO1xuXHRcdHRoaXMucmVmdXNlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnJlZnVzZWQpIHx8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBSZXF1ZXN0Q291bnQodmFsdWVzKSB7XG5cdFx0dGhpcy5zdWNjZWVkZWQgPSAodmFsdWVzICYmIHZhbHVlcy5zdWNjZWVkZWQpIHx8IDA7XG5cdFx0dGhpcy5mYWlsZWQgPSAodmFsdWVzICYmIHZhbHVlcy5mYWlsZWQpIHx8IDA7XG5cdFx0dGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIENvbm5lY3Rpb25UeXBlcyh2YWx1ZXMpIHtcblx0XHR0aGlzLnBsYWluID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy5wbGFpbik7XG5cdFx0dGhpcy50bHMgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnRscyk7XG5cdFx0dGhpcy5hbGwgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBNZXNzYWdlVHlwZXModmFsdWVzKSB7XG5cdFx0dGhpcy5tZXNzYWdlcyA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5tZXNzYWdlcyk7XG5cdFx0dGhpcy5wcmVzZW5jZSA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5wcmVzZW5jZSk7XG5cdFx0dGhpcy5hbGwgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lc3NhZ2VUcmFmZmljKHZhbHVlcykge1xuXHRcdHRoaXMucmVhbHRpbWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucmVhbHRpbWUpO1xuXHRcdHRoaXMucmVzdCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5yZXN0KTtcblx0XHR0aGlzLndlYmhvb2sgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMud2ViaG9vayk7XG5cdFx0dGhpcy5zaGFyZWRRdWV1ZSA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5zaGFyZWRRdWV1ZSk7XG5cdFx0dGhpcy5leHRlcm5hbFF1ZXVlID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmV4dGVybmFsUXVldWUpO1xuXHRcdHRoaXMuaHR0cEV2ZW50ID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmh0dHBFdmVudCk7XG5cdFx0dGhpcy5wdXNoID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnB1c2gpO1xuXHRcdHRoaXMuYWxsID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG5cdH1cblxuXHRmdW5jdGlvbiBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMpIHtcblx0XHR0aGlzLmFsbCAgICAgICAgICAgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcblx0XHR0aGlzLmluYm91bmQgICAgICAgPSBuZXcgTWVzc2FnZVRyYWZmaWModmFsdWVzICYmIHZhbHVlcy5pbmJvdW5kKTtcblx0XHR0aGlzLm91dGJvdW5kICAgICAgPSBuZXcgTWVzc2FnZVRyYWZmaWModmFsdWVzICYmIHZhbHVlcy5vdXRib3VuZCk7XG5cdH1cblxuXHRmdW5jdGlvbiBYY2hnTWVzc2FnZXModmFsdWVzKSB7XG5cdFx0dGhpcy5hbGwgICAgICAgICAgID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG5cdFx0dGhpcy5wcm9kdWNlclBhaWQgID0gbmV3IE1lc3NhZ2VEaXJlY3Rpb25zKHZhbHVlcyAmJiB2YWx1ZXMucHJvZHVjZXJQYWlkKTtcblx0XHR0aGlzLmNvbnN1bWVyUGFpZCAgPSBuZXcgTWVzc2FnZURpcmVjdGlvbnModmFsdWVzICYmIHZhbHVlcy5jb25zdW1lclBhaWQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gUHVzaFN0YXRzKHZhbHVlcykge1xuXHRcdHRoaXMubWVzc2FnZXMgPSAodmFsdWVzICYmIHZhbHVlcy5tZXNzYWdlcykgfHwgMDtcblx0XHR2YXIgbm90aWZpY2F0aW9ucyA9IHZhbHVlcyAmJiB2YWx1ZXMubm90aWZpY2F0aW9ucztcblx0XHR0aGlzLm5vdGlmaWNhdGlvbnMgPSB7XG5cdFx0XHRpbnZhbGlkOiBub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuaW52YWxpZCB8fCAwLFxuXHRcdFx0YXR0ZW1wdGVkOiBub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuYXR0ZW1wdGVkIHx8IDAsXG5cdFx0XHRzdWNjZXNzZnVsOiBub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuc3VjY2Vzc2Z1bCB8fCAwLFxuXHRcdFx0ZmFpbGVkOiBub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuZmFpbGVkIHx8IDBcblx0XHR9O1xuXHRcdHRoaXMuZGlyZWN0UHVibGlzaGVzID0gKHZhbHVlcyAmJiB2YWx1ZXMuZGlyZWN0UHVibGlzaGVzKSB8fCAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gUHJvY2Vzc2VkQ291bnQodmFsdWVzKSB7XG5cdFx0dGhpcy5zdWNjZWVkZWQgPSAodmFsdWVzICYmIHZhbHVlcy5zdWNjZWVkZWQpIHx8IDA7XG5cdFx0dGhpcy5za2lwcGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc2tpcHBlZCkgfHwgMDtcblx0XHR0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIFByb2Nlc3NlZE1lc3NhZ2VzKHZhbHVlcykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLmRlbHRhID0gdW5kZWZpbmVkO1xuXHRcdGlmICh2YWx1ZXMgJiYgdmFsdWVzLmRlbHRhKSB7XG5cdFx0XHR0aGlzLmRlbHRhID0geyB9O1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZm9ySW5Pd25Ob25OdWxsUHJvcHModmFsdWVzLmRlbHRhLCBmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHRcdHNlbGYuZGVsdGFbcHJvcF0gPSBuZXcgUHJvY2Vzc2VkQ291bnQodmFsdWVzLmRlbHRhW3Byb3BdKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFN0YXRzKHZhbHVlcykge1xuXHRcdE1lc3NhZ2VEaXJlY3Rpb25zLmNhbGwodGhpcywgdmFsdWVzKTtcblx0XHR0aGlzLnBlcnNpc3RlZCAgICAgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucGVyc2lzdGVkKTtcblx0XHR0aGlzLmNvbm5lY3Rpb25zICAgPSBuZXcgQ29ubmVjdGlvblR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuY29ubmVjdGlvbnMpO1xuXHRcdHRoaXMuY2hhbm5lbHMgICAgICA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMuY2hhbm5lbHMpO1xuXHRcdHRoaXMuYXBpUmVxdWVzdHMgICA9IG5ldyBSZXF1ZXN0Q291bnQodmFsdWVzICYmIHZhbHVlcy5hcGlSZXF1ZXN0cyk7XG5cdFx0dGhpcy50b2tlblJlcXVlc3RzID0gbmV3IFJlcXVlc3RDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnRva2VuUmVxdWVzdHMpO1xuXHRcdHRoaXMueGNoZ1Byb2R1Y2VyICA9IG5ldyBYY2hnTWVzc2FnZXModmFsdWVzICYmIHZhbHVlcy54Y2hnUHJvZHVjZXIpO1xuXHRcdHRoaXMueGNoZ0NvbnN1bWVyICA9IG5ldyBYY2hnTWVzc2FnZXModmFsdWVzICYmIHZhbHVlcy54Y2hnQ29uc3VtZXIpO1xuXHRcdHRoaXMucHVzaCAgICAgICAgICA9IG5ldyBQdXNoU3RhdHModmFsdWVzICYmIHZhbHVlcy5wdXNoU3RhdHMpO1xuXHRcdHRoaXMucHJvY2Vzc2VkICAgICA9IG5ldyBQcm9jZXNzZWRNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnByb2Nlc3NlZCk7XG5cdFx0dGhpcy5pblByb2dyZXNzICAgID0gKHZhbHVlcyAmJiB2YWx1ZXMuaW5Qcm9ncmVzcykgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMudW5pdCAgICAgICAgICA9ICh2YWx1ZXMgJiYgdmFsdWVzLnVuaXQpIHx8IHVuZGVmaW5lZDtcblx0XHR0aGlzLmludGVydmFsSWQgICAgPSAodmFsdWVzICYmIHZhbHVlcy5pbnRlcnZhbElkKSB8fCB1bmRlZmluZWQ7XG5cdH1cblxuXHRTdGF0cy5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0cmV0dXJuIG5ldyBTdGF0cyh2YWx1ZXMpO1xuXHR9O1xuXG5cdHJldHVybiBTdGF0cztcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHN0YXRzID0gKHN0YXRzX1N0YXRzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZXN0LmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcmVzdF9SZXN0ID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cdHZhciBtc2dwYWNrID0gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5tc2dwYWNrO1xuXG5cdGZ1bmN0aW9uIFJlc3Qob3B0aW9ucykge1xuXHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIFJlc3QpKXtcblx0XHRcdHJldHVybiBuZXcgUmVzdChvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvKiBub3JtYWxpc2Ugb3B0aW9ucyAqL1xuXHRcdGlmKCFvcHRpb25zKSB7XG5cdFx0XHR2YXIgbXNnID0gJ25vIG9wdGlvbnMgcHJvdmlkZWQnO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVzdCgpJywgbXNnKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdH1cblx0XHRvcHRpb25zID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcblxuXHRcdGlmKG9wdGlvbnMubG9nKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc2V0TG9nKG9wdGlvbnMubG9nLmxldmVsLCBvcHRpb25zLmxvZy5oYW5kbGVyKTtcblx0XHR9XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzdCgpJywgJ2luaXRpYWxpemVkIHdpdGggY2xpZW50T3B0aW9ucyAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdChvcHRpb25zKSk7XG5cblx0XHR0aGlzLm9wdGlvbnMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3JtYWxpc2VPcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0LyogcHJvY2VzcyBvcHRpb25zICovXG5cdFx0aWYob3B0aW9ucy5rZXkpIHtcblx0XHRcdHZhciBrZXlNYXRjaCA9IG9wdGlvbnMua2V5Lm1hdGNoKC9eKFteOlxcc10rKTooW146Llxcc10rKSQvKTtcblx0XHRcdGlmKCFrZXlNYXRjaCkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ2ludmFsaWQga2V5IHBhcmFtZXRlcic7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1Jlc3QoKScsIG1zZyk7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucy5rZXlOYW1lID0ga2V5TWF0Y2hbMV07XG5cdFx0XHRvcHRpb25zLmtleVNlY3JldCA9IGtleU1hdGNoWzJdO1xuXHRcdH1cblxuXHRcdGlmKCdjbGllbnRJZCcgaW4gb3B0aW9ucykge1xuXHRcdFx0aWYoISh0eXBlb2Yob3B0aW9ucy5jbGllbnRJZCkgPT09ICdzdHJpbmcnIHx8IG9wdGlvbnMuY2xpZW50SWQgPT09IG51bGwpKVxuXHRcdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsJywgNDAwMTIsIDQwMCk7XG5cdFx0XHRlbHNlIGlmKG9wdGlvbnMuY2xpZW50SWQgPT09ICcqJylcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2Fu4oCZdCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgdXNlIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSknLCA0MDAxMiwgNDAwKTtcblx0XHR9XG5cblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZXN0KCknLCAnc3RhcnRlZDsgdmVyc2lvbiA9ICcgKyBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5saWJzdHJpbmcpO1xuXG5cdFx0dGhpcy5iYXNlVXJpID0gdGhpcy5hdXRob3JpdHkgPSBmdW5jdGlvbihob3N0KSB7IHJldHVybiBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRIdHRwU2NoZW1lKG9wdGlvbnMpICsgaG9zdCArICc6JyArIGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldFBvcnQob3B0aW9ucywgZmFsc2UpOyB9O1xuXHRcdHRoaXMuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG5cblx0XHR0aGlzLnNlcnZlclRpbWVPZmZzZXQgPSBudWxsO1xuXHRcdHRoaXMuYXV0aCA9IG5ldyBhdXRoW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcyk7XG5cdFx0dGhpcy5wdXNoID0gbmV3IHB1c2godGhpcyk7XG5cdH1cblxuXHRSZXN0LnByb3RvdHlwZS5zdGF0cyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc3RhdHMnLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycygpLFxuXHRcdFx0Zm9ybWF0ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQ7XG5cblx0XHRpZih0aGlzLm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UodGhpcywgJy9zdGF0cycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0dmFyIHN0YXRzVmFsdWVzID0gKHVucGFja2VkID8gYm9keSA6IEpTT04ucGFyc2UoYm9keSkpO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0YXRzVmFsdWVzLmxlbmd0aDsgaSsrKSBzdGF0c1ZhbHVlc1tpXSA9IHN0YXRzLmZyb21WYWx1ZXMoc3RhdHNWYWx1ZXNbaV0pO1xuXHRcdFx0cmV0dXJuIHN0YXRzVmFsdWVzO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVzdC5wcm90b3R5cGUudGltZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAndGltZScsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgaGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKCk7XG5cdFx0aWYodGhpcy5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciB0aW1lVXJpID0gZnVuY3Rpb24oaG9zdCkgeyByZXR1cm4gc2VsZi5hdXRob3JpdHkoaG9zdCkgKyAnL3RpbWUnIH07XG5cdFx0aHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5nZXQodGhpcywgdGltZVVyaSwgaGVhZGVycywgcGFyYW1zLCBmdW5jdGlvbihlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZighdW5wYWNrZWQpIHJlcyA9IEpTT04ucGFyc2UocmVzKTtcblx0XHRcdHZhciB0aW1lID0gcmVzWzBdO1xuXHRcdFx0aWYoIXRpbWUpIHtcblx0XHRcdFx0ZXJyID0gbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvciAodW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIEdFVCAvdGltZSknKTtcblx0XHRcdFx0ZXJyLnN0YXR1c0NvZGUgPSA1MDA7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIGNhbGN1bGF0ZSB0aW1lIG9mZnNldCBvbmx5IG9uY2UgZm9yIHRoaXMgZGV2aWNlIGJ5IGFkZGluZyB0byB0aGUgcHJvdG90eXBlICovXG5cdFx0XHRzZWxmLnNlcnZlclRpbWVPZmZzZXQgPSAodGltZSAtIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vdygpKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRpbWUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFJlc3QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHBhdGgsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVycywgY2FsbGJhY2spIHtcblx0XHR2YXIgdXNlQmluYXJ5ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sLFxuXHRcdFx0ZW5jb2RlciA9IHVzZUJpbmFyeSA/IG1zZ3BhY2suZW5jb2RlOiBKU09OLnN0cmluZ2lmeSxcblx0XHRcdGRlY29kZXIgPSB1c2VCaW5hcnkgPyBtc2dwYWNrLmRlY29kZSA6IEpTT04ucGFyc2UsXG5cdFx0XHRmb3JtYXQgPSB1c2VCaW5hcnkgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdDtcblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cdFx0bWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG5cdFx0dmFyIGhlYWRlcnMgPSBtZXRob2QgPT0gJ2dldCcgPyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpIDogdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdFBvc3RIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncmVxdWVzdCcsIFttZXRob2QsIHBhdGgsIHBhcmFtcywgYm9keSwgY3VzdG9tSGVhZGVyc10pO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0Ym9keSA9IGVuY29kZXIoYm9keSk7XG5cdFx0fVxuXHRcdGlmKHRoaXMub3B0aW9ucy5oZWFkZXJzKSB7XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG5cdFx0fVxuXHRcdGlmKGN1c3RvbUhlYWRlcnMpIHtcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIGN1c3RvbUhlYWRlcnMpO1xuXHRcdH1cblx0XHR2YXIgcGFnaW5hdGVkUmVzb3VyY2UgPSBuZXcgcGFnaW5hdGVkcmVzb3VyY2UodGhpcywgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKHJlc2JvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5zdXJlQXJyYXkodW5wYWNrZWQgPyByZXNib2R5IDogZGVjb2RlcihyZXNib2R5KSk7XG5cdFx0fSwgLyogdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlOiAqLyB0cnVlKTtcblxuXHRcdGlmKCF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHMsIG1ldGhvZCkpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Vuc3VwcG9ydGVkIG1ldGhvZCAnICsgbWV0aG9kLCA0MDUwMCwgNDA1KTtcblx0XHR9XG5cblx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRoQm9keSwgbWV0aG9kKSkge1xuXHRcdFx0cGFnaW5hdGVkUmVzb3VyY2VbbWV0aG9kXShwYXJhbXMsIGJvZHksIGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFnaW5hdGVkUmVzb3VyY2VbbWV0aG9kXShwYXJhbXMsIGNhbGxiYWNrKTtcblx0XHR9XG5cdH07XG5cblx0UmVzdC5wcm90b3R5cGUuc2V0TG9nID0gZnVuY3Rpb24obG9nT3B0aW9ucykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zZXRMb2cobG9nT3B0aW9ucy5sZXZlbCwgbG9nT3B0aW9ucy5oYW5kbGVyKTtcblx0fTtcblxuXHRmdW5jdGlvbiBDaGFubmVscyhyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLmFsbCA9IHt9O1xuXHR9XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuXHRcdGlmKCFjaGFubmVsKSB7XG5cdFx0XHR0aGlzLmFsbFtuYW1lXSA9IGNoYW5uZWwgPSBuZXcgY2xpZW50X2NoYW5uZWwodGhpcy5yZXN0LCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG5cdFx0fSBlbHNlIGlmKGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0XHRjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjaGFubmVsO1xuXHR9O1xuXG5cdC8qIEluY2x1ZGVkIHRvIHN1cHBvcnQgY2VydGFpbiBuaWNoZSB1c2UtY2FzZXM7IG1vc3QgdXNlcnMgc2hvdWxkIGlnbm9yZSB0aGlzLlxuXHQgKiBQbGVhc2UgZG8gbm90IHVzZSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZyAqL1xuXHRDaGFubmVscy5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRkZWxldGUgdGhpcy5hbGxbU3RyaW5nKG5hbWUpXTtcblx0fTtcblxuXHRyZXR1cm4gUmVzdDtcbn0pKCk7XG5cbnJlc3RfUmVzdC5Qcm9taXNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRvcHRpb25zID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcblx0b3B0aW9ucy5wcm9taXNlcyA9IHRydWU7XG5cdHJldHVybiBuZXcgcmVzdF9SZXN0KG9wdGlvbnMpO1xufTtcblxucmVzdF9SZXN0LkNhbGxiYWNrcyA9IHJlc3RfUmVzdDtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50X3Jlc3QgPSAocmVzdF9SZXN0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHJhbnNwb3J0L2Nvbm5lY3Rpb25tYW5hZ2VyLmpzXG52YXIgY29ubmVjdGlvbm1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZS5qc1xudmFyIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb24uanNcblxuXG5cblxuXG5cbnZhciBjb25uZWN0aW9uX0Nvbm5lY3Rpb24gPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBDb25uZWN0aW9uKGFibHksIG9wdGlvbnMpIHtcblx0XHRldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzKTtcblx0XHR0aGlzLmFibHkgPSBhYmx5O1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgY29ubmVjdGlvbm1hbmFnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10oYWJseSwgb3B0aW9ucyk7XG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGU7XG5cdFx0dGhpcy5rZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5pZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnRpbWVTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yZWNvdmVyeUtleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5zdGF0ZSA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQ7XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5lbWl0KHN0YXRlLCBzdGF0ZUNoYW5nZSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCd1cGRhdGUnLCBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgndXBkYXRlJywgc3RhdGVDaGFuZ2UpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoQ29ubmVjdGlvbiwgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRDb25uZWN0aW9uLnByb3RvdHlwZS53aGVuU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbGlzdGVuZXIpIHtcblx0XHRyZXR1cm4gZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSwgbGlzdGVuZXIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10odW5kZWZpbmVkLCBzdGF0ZSkpO1xuXHR9XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24uY29ubmVjdCgpJywgJycpO1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5waW5nKCknLCAnJyk7XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZih0aGlzLmFibHkub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdwaW5nJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5waW5nKG51bGwsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24uY2xvc2UoKScsICdjb25uZWN0aW9uS2V5ID0gJyArIHRoaXMua2V5KTtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjbG9zaW5nJ30pO1xuXHR9O1xuXG5cdHJldHVybiBDb25uZWN0aW9uO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29ubmVjdGlvbiA9IChjb25uZWN0aW9uX0Nvbm5lY3Rpb24pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9wcm90b2NvbG1lc3NhZ2UuanNcbnZhciBwcm90b2NvbG1lc3NhZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90cmFuc3BvcnQvY29ubmVjdGlvbmVycm9yLmpzXG52YXIgY29ubmVjdGlvbmVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbXVsdGljYXN0ZXIuanNcbnZhciB1dGlsX211bHRpY2FzdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvY2hhbm5lbHN0YXRlY2hhbmdlLmpzXG52YXIgQ2hhbm5lbFN0YXRlQ2hhbmdlID0gKGZ1bmN0aW9uKCkge1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBDaGFubmVsU3RhdGVDaGFuZ2UocHJldmlvdXMsIGN1cnJlbnQsIHJlc3VtZWQsIHJlYXNvbikge1xuXHRcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcblx0XHR0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuXHRcdGlmKGN1cnJlbnQgPT09ICdhdHRhY2hlZCcpIHRoaXMucmVzdW1lZCA9IHJlc3VtZWQ7XG5cdFx0aWYocmVhc29uKSB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcblx0fVxuXG5cdHJldHVybiBDaGFubmVsU3RhdGVDaGFuZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjaGFubmVsc3RhdGVjaGFuZ2UgPSAoQ2hhbm5lbFN0YXRlQ2hhbmdlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZXByZXNlbmNlLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHJlYWx0aW1lcHJlc2VuY2VfUmVhbHRpbWVQcmVzZW5jZSA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdGZ1bmN0aW9uIG1lbWJlcktleShpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uY2xpZW50SWQgKyAnOicgKyBpdGVtLmNvbm5lY3Rpb25JZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENsaWVudElkKHJlYWx0aW1lUHJlc2VuY2UpIHtcblx0XHRyZXR1cm4gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLnJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBpc0Fub255bW91c09yV2lsZGNhcmQocmVhbHRpbWVQcmVzZW5jZSkge1xuXHRcdHZhciByZWFsdGltZSA9IHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5yZWFsdGltZTtcblx0XHQvKiBJZiBub3QgY3VycmVudGx5IGNvbm5lY3RlZCwgd2UgY2FuJ3QgYXNzdW1lIHRoYXQgd2UncmUgYW4gYW5vbnltb3VzXG5cdFx0ICogY2xpZW50LCBhcyByZWFsdGltZSBtYXkgaW5mb3JtIHVzIG9mIG91ciBjbGllbnRJZCBpbiB0aGUgQ09OTkVDVEVEXG5cdFx0ICogbWVzc2FnZS4gU28gYXNzdW1lIHdlJ3JlIG5vdCBhbm9ueW1vdXMgYW5kIGxlYXZlIGl0IHRvIHJlYWx0aW1lIHRvXG5cdFx0ICogcmV0dXJuIGFuIGVycm9yIGlmIHdlIGFyZSAqL1xuXHRcdHZhciBjbGllbnRJZCA9IHJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG5cdFx0cmV0dXJuICghY2xpZW50SWQgfHwgKGNsaWVudElkID09PSAnKicpKSAmJiByZWFsdGltZS5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJztcblx0fVxuXG5cdC8qIENhbGxiYWNrIGlzIGNhbGxlZCBvbmx5IGluIHRoZSBldmVudCBvZiBhbiBlcnJvciAqL1xuXHRmdW5jdGlvbiB3YWl0QXR0YWNoZWQoY2hhbm5lbCwgY2FsbGJhY2ssIGFjdGlvbikge1xuXHRcdHN3aXRjaChjaGFubmVsLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRhY3Rpb24oKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XG5cdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0Y2hhbm5lbC5hdHRhY2goZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdFx0aWYoZXJyKSBjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdGVsc2UgYWN0aW9uKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNhbGxiYWNrKGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHJlYWx0aW1lY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcihjaGFubmVsLnN0YXRlKSkpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFJlYWx0aW1lUHJlc2VuY2UoY2hhbm5lbCwgb3B0aW9ucykge1xuXHRcdGNsaWVudF9wcmVzZW5jZS5jYWxsKHRoaXMsIGNoYW5uZWwpO1xuXHRcdHRoaXMuc3luY0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0dGhpcy5tZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMpO1xuXHRcdHRoaXMuX215TWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzKTtcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XG5cdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhSZWFsdGltZVByZXNlbmNlLCBjbGllbnRfcHJlc2VuY2UpO1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcblx0XHRpZihpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIGVudGVyIGEgcHJlc2VuY2UgY2hhbm5lbCcsIDQwMDEyLCA0MDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh1bmRlZmluZWQsIGRhdGEsICdlbnRlcicsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuXHRcdGlmKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgbXVzdCBiZSBzcGVjaWZpZWQgdG8gdXBkYXRlIHByZXNlbmNlIGRhdGEnLCA0MDAxMiwgNDAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCAndXBkYXRlJywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmVudGVyQ2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoY2xpZW50SWQsIGRhdGEsICdlbnRlcicsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51cGRhdGVDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudChjbGllbnRJZCwgZGF0YSwgJ3VwZGF0ZScsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fZW50ZXJPclVwZGF0ZUNsaWVudCA9IGZ1bmN0aW9uKGNsaWVudElkLCBkYXRhLCBhY3Rpb24sIGNhbGxiYWNrKSB7XG5cdFx0aWYgKCFjYWxsYmFjaykge1xuXHRcdFx0aWYgKHR5cGVvZihkYXRhKT09PSdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnX2VudGVyT3JVcGRhdGVDbGllbnQnLCBbY2xpZW50SWQsIGRhdGEsIGFjdGlvbl0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcblx0XHRpZighY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayhjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuJyArIGFjdGlvbiArICdDbGllbnQoKScsXG5cdFx0ICAnY2hhbm5lbCA9ICcgKyBjaGFubmVsLm5hbWUgKyAnLCBjbGllbnQgPSAnICsgKGNsaWVudElkIHx8ICcoaW1wbGljaXQpICcgKyBnZXRDbGllbnRJZCh0aGlzKSkpO1xuXG5cdFx0dmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xuXHRcdFx0YWN0aW9uIDogYWN0aW9uLFxuXHRcdFx0ZGF0YSAgIDogZGF0YVxuXHRcdH0pO1xuXHRcdGlmIChjbGllbnRJZCkge1xuXHRcdFx0cHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDtcblx0XHR9XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0cHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZShwcmVzZW5jZSwgY2hhbm5lbC5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHN3aXRjaChjaGFubmVsLnN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0XHRjaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XG5cdFx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdFx0XHRjaGFubmVsLmF0dGFjaCgpO1xuXHRcdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHRcdHNlbGYucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuXHRcdFx0XHRcdFx0cHJlc2VuY2UgOiBwcmVzZW5jZSxcblx0XHRcdFx0XHRcdGNhbGxiYWNrIDogY2FsbGJhY2tcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmFibGUgdG8gJyArIGFjdGlvbiArICcgcHJlc2VuY2UgY2hhbm5lbCB3aGlsZSBpbiAnICsgY2hhbm5lbC5zdGF0ZSArICcgc3RhdGUnLCA5MDAwMSk7XG5cdFx0XHRcdFx0ZXJyLmNvZGUgPSA5MDAwMTtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcblx0XHRpZihpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIG11c3QgaGF2ZSBiZWVuIHNwZWNpZmllZCB0byBlbnRlciBvciBsZWF2ZSBhIHByZXNlbmNlIGNoYW5uZWwnLCA0MDAxMiwgNDAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMubGVhdmVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUubGVhdmVDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodHlwZW9mKGRhdGEpPT09J2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdsZWF2ZUNsaWVudCcsIFtjbGllbnRJZCwgZGF0YV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcblx0XHRpZighY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayhjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UubGVhdmVDbGllbnQoKScsICdsZWF2aW5nOyBjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lICsgJywgY2xpZW50ID0gJyArIGNsaWVudElkKTtcblx0XHR2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7XG5cdFx0XHRhY3Rpb24gOiAnbGVhdmUnLFxuXHRcdFx0ZGF0YSAgIDogZGF0YVxuXHRcdH0pO1xuXHRcdGlmIChjbGllbnRJZCkgeyBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkOyB9XG5cblx0XHRzd2l0Y2goY2hhbm5lbC5zdGF0ZSkge1xuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHRjaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlLnB1c2goe1xuXHRcdFx0XHRcdHByZXNlbmNlIDogcHJlc2VuY2UsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgOiBjYWxsYmFja1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XG5cdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHQvKiB3ZSdyZSBub3QgYXR0YWNoZWQ7IHRoZXJlZm9yZSB3ZSBsZXQgYW55IGVudGVyZWQgc3RhdHVzXG5cdFx0XHRcdCAqIHRpbWVvdXQgYnkgaXRzZWxmIGluc3RlYWQgb2YgYXR0YWNoaW5nIGp1c3QgaW4gb3JkZXIgdG8gbGVhdmUgKi9cblx0XHRcdFx0dmFyIGVyciA9IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byBsZWF2ZSBwcmVzZW5jZSBjaGFubmVsIChpbmNvbXBhdGlibGUgc3RhdGUpJywgOTAwMDEpO1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdC8qIHRoZXJlIGlzIG5vIGNvbm5lY3Rpb247IHRoZXJlZm9yZSB3ZSBsZXRcblx0XHRcdFx0ICogYW55IGVudGVyZWQgc3RhdHVzIHRpbWVvdXQgYnkgaXRzZWxmICovXG5cdFx0XHRcdGNhbGxiYWNrKGNvbm5lY3Rpb25lcnJvcltcImFcIiAvKiBkZWZhdWx0ICovXS5mYWlsZWQpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigvKiBwYXJhbXMsIGNhbGxiYWNrICovKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdGlmKGFyZ3MubGVuZ3RoID09IDEgJiYgdHlwZW9mKGFyZ3NbMF0pID09ICdmdW5jdGlvbicpXG5cdFx0XHRhcmdzLnVuc2hpZnQobnVsbCk7XG5cblx0XHR2YXIgcGFyYW1zID0gYXJnc1swXSxcblx0XHRcdGNhbGxiYWNrID0gYXJnc1sxXSxcblx0XHRcdHdhaXRGb3JTeW5jID0gIXBhcmFtcyB8fCAoJ3dhaXRGb3JTeW5jJyBpbiBwYXJhbXMgPyBwYXJhbXMud2FpdEZvclN5bmMgOiB0cnVlKTtcblxuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnZ2V0JywgYXJncyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmV0dXJuTWVtYmVycyhtZW1iZXJzKSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBwYXJhbXMgPyBtZW1iZXJzLmxpc3QocGFyYW1zKSA6IG1lbWJlcnMudmFsdWVzKCkpO1xuXHRcdH1cblxuXHRcdC8qIFNwZWNpYWwtY2FzZSB0aGUgc3VzcGVuZGVkIHN0YXRlOiBjYW4gc3RpbGwgZ2V0IChzdGFsZSkgcHJlc2VuY2Ugc2V0IGlmIHdhaXRGb3JTeW5jIGlzIGZhbHNlICovXG5cdFx0aWYodGhpcy5jaGFubmVsLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0aWYod2FpdEZvclN5bmMpIHtcblx0XHRcdFx0Y2FsbGJhY2soZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xuXHRcdFx0XHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRcdFx0XHRjb2RlOiA5MTAwNSxcblx0XHRcdFx0XHRtZXNzYWdlOiAnUHJlc2VuY2Ugc3RhdGUgaXMgb3V0IG9mIHN5bmMgZHVlIHRvIGNoYW5uZWwgYmVpbmcgaW4gdGhlIFNVU1BFTkRFRCBzdGF0ZSdcblx0XHRcdFx0fSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuTWVtYmVycyh0aGlzLm1lbWJlcnMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR3YWl0QXR0YWNoZWQodGhpcy5jaGFubmVsLCBjYWxsYmFjaywgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbWVtYmVycyA9IHNlbGYubWVtYmVycztcblx0XHRcdGlmKHdhaXRGb3JTeW5jKSB7XG5cdFx0XHRcdG1lbWJlcnMud2FpdFN5bmMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm5NZW1iZXJzKG1lbWJlcnMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XG5cdFx0XHRpZih0aGlzLmNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0ZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcblx0XHRcdFx0cGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5jaGFubmVsLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZCwgd2FzOiBcIiArIHRoaXMuY2hhbm5lbC5zdGF0ZSwgNDAwMDAsIDQwMCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNsaWVudF9wcmVzZW5jZS5wcm90b3R5cGUuX2hpc3RvcnkuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5zZXRQcmVzZW5jZSA9IGZ1bmN0aW9uKHByZXNlbmNlU2V0LCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5zZXRQcmVzZW5jZSgpJywgJ3JlY2VpdmVkIHByZXNlbmNlIGZvciAnICsgcHJlc2VuY2VTZXQubGVuZ3RoICsgJyBwYXJ0aWNpcGFudHM7IHN5bmNDaGFubmVsU2VyaWFsID0gJyArIHN5bmNDaGFubmVsU2VyaWFsKTtcblx0XHR2YXIgc3luY0N1cnNvciwgbWF0Y2gsIG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycyxcblx0XHRcdGJyb2FkY2FzdE1lc3NhZ2VzID0gW10sIGNvbm5JZCA9IHRoaXMuY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQ7XG5cblx0XHRpZihpc1N5bmMpIHtcblx0XHRcdHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcblx0XHRcdGlmKHN5bmNDaGFubmVsU2VyaWFsICYmIChtYXRjaCA9IHN5bmNDaGFubmVsU2VyaWFsLm1hdGNoKC9eW1xcd1xcLV0rOiguKikkLykpKSB7XG5cdFx0XHRcdHN5bmNDdXJzb3IgPSBtYXRjaFsxXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2VTZXQubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHByZXNlbmNlU2V0W2ldKTtcblx0XHRcdHN3aXRjaChwcmVzZW5jZS5hY3Rpb24pIHtcblx0XHRcdFx0Y2FzZSAnbGVhdmUnOlxuXHRcdFx0XHRcdGlmKG1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKSkge1xuXHRcdFx0XHRcdFx0YnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHByZXNlbmNlLmNvbm5lY3Rpb25JZCA9PT0gY29ubklkICYmICFwcmVzZW5jZS5pc1N5bnRoZXNpemVkKCkpIHtcblx0XHRcdFx0XHRcdG15TWVtYmVycy5yZW1vdmUocHJlc2VuY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZW50ZXInOlxuXHRcdFx0XHRjYXNlICdwcmVzZW50Jzpcblx0XHRcdFx0Y2FzZSAndXBkYXRlJzpcblx0XHRcdFx0XHRpZihtZW1iZXJzLnB1dChwcmVzZW5jZSkpIHtcblx0XHRcdFx0XHRcdGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCkge1xuXHRcdFx0XHRcdFx0bXlNZW1iZXJzLnB1dChwcmVzZW5jZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvKiBpZiB0aGlzIGlzIHRoZSBsYXN0IChvciBvbmx5KSBtZXNzYWdlIGluIGEgc2VxdWVuY2Ugb2Ygc3luYyB1cGRhdGVzLCBlbmQgdGhlIHN5bmMgKi9cblx0XHRpZihpc1N5bmMgJiYgIXN5bmNDdXJzb3IpIHtcblx0XHRcdG1lbWJlcnMuZW5kU3luYygpO1xuXHRcdFx0LyogUlRQNWMyOiByZS1lbnRlciBvdXIgb3duIG1lbWJlcnMgaWYgdGhleSBoYXZlbid0IHNob3duIHVwIGluIHRoZSBzeW5jICovXG5cdFx0XHR0aGlzLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCk7XG5cdFx0XHR0aGlzLmNoYW5uZWwuc2V0SW5Qcm9ncmVzcyhyZWFsdGltZWNoYW5uZWwucHJvZ3Jlc3NPcHMuc3luYywgZmFsc2UpO1xuXHRcdFx0dGhpcy5jaGFubmVsLnN5bmNDaGFubmVsU2VyaWFsID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKiBicm9hZGNhc3QgdG8gbGlzdGVuZXJzICovXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGJyb2FkY2FzdE1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcHJlc2VuY2UgPSBicm9hZGNhc3RNZXNzYWdlc1tpXTtcblx0XHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5lbWl0KHByZXNlbmNlLmFjdGlvbiwgcHJlc2VuY2UpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vbkF0dGFjaGVkID0gZnVuY3Rpb24oaGFzUHJlc2VuY2UpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lICsgJywgaGFzUHJlc2VuY2UgPSAnICsgaGFzUHJlc2VuY2UpO1xuXG5cdFx0aWYoaGFzUHJlc2VuY2UpIHtcblx0XHRcdHRoaXMubWVtYmVycy5zdGFydFN5bmMoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fc3ludGhlc2l6ZUxlYXZlcyh0aGlzLm1lbWJlcnMudmFsdWVzKCkpO1xuXHRcdFx0dGhpcy5tZW1iZXJzLmNsZWFyKCk7XG5cdFx0XHR0aGlzLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCk7XG5cdFx0fVxuXG5cdFx0LyogTkIgdGhpcyBtdXN0IGJlIGFmdGVyIHRoZSBfZW5zdXJlTXlNZW1iZXJzUHJlc2VudCBjYWxsLCB3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHBlbmRpbmdQcmVzZW5jZSAqL1xuXHRcdHZhciBwZW5kaW5nUHJlc2VuY2UgPSB0aGlzLnBlbmRpbmdQcmVzZW5jZSxcblx0XHRcdHBlbmRpbmdQcmVzQ291bnQgPSBwZW5kaW5nUHJlc2VuY2UubGVuZ3RoO1xuXG5cdFx0aWYocGVuZGluZ1ByZXNDb3VudCkge1xuXHRcdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcblx0XHRcdHZhciBwcmVzZW5jZUFycmF5ID0gW107XG5cdFx0XHR2YXIgbXVsdGljYXN0ZXIgPSBPYmplY3QodXRpbF9tdWx0aWNhc3RlcltcImFcIiAvKiBkZWZhdWx0ICovXSkoKTtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2Uub25BdHRhY2hlZCcsICdzZW5kaW5nICcgKyBwZW5kaW5nUHJlc0NvdW50ICsgJyBxdWV1ZWQgcHJlc2VuY2UgbWVzc2FnZXMnKTtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwZW5kaW5nUHJlc0NvdW50OyBpKyspIHtcblx0XHRcdFx0dmFyIGV2ZW50ID0gcGVuZGluZ1ByZXNlbmNlW2ldO1xuXHRcdFx0XHRwcmVzZW5jZUFycmF5LnB1c2goZXZlbnQucHJlc2VuY2UpO1xuXHRcdFx0XHRtdWx0aWNhc3Rlci5wdXNoKGV2ZW50LmNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuY2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2VBcnJheSwgbXVsdGljYXN0ZXIpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5hY3RPbkNoYW5uZWxTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBoYXNQcmVzZW5jZSwgZXJyKSB7XG5cdFx0c3dpdGNoKHN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdHRoaXMub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxuXHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0dGhpcy5fY2xlYXJNeU1lbWJlcnMoKTtcblx0XHRcdFx0dGhpcy5tZW1iZXJzLmNsZWFyKCk7XG5cdFx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgJ3N1c3BlbmRlZCc6XG5cdFx0XHRcdHRoaXMuZmFpbFBlbmRpbmdQcmVzZW5jZShlcnIpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZmFpbFBlbmRpbmdQcmVzZW5jZSA9IGZ1bmN0aW9uKGVycikge1xuXHRcdGlmKHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmZhaWxQZW5kaW5nUHJlc2VuY2UnLCAnY2hhbm5lbDsgbmFtZSA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGVyciA9ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2VbaV0uY2FsbGJhY2soZXJyKTtcblx0XHRcdFx0fSBjYXRjaChlKSB7fVxuXHRcdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2NsZWFyTXlNZW1iZXJzID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbXlNZW1iZXJzLmNsZWFyKCk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycyxcblx0XHRcdHJlZW50ZXJDYiA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHR2YXIgbXNnID0gJ1ByZXNlbmNlIGF1dG8tcmUtZW50ZXIgZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0dmFyIHdyYXBwZWRFcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgOTEwMDQsIDQwMCk7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpJywgbXNnKTtcblx0XHRcdFx0XHR2YXIgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZShzZWxmLmNoYW5uZWwuc3RhdGUsIHNlbGYuY2hhbm5lbC5zdGF0ZSwgdHJ1ZSwgd3JhcHBlZEVycik7XG5cdFx0XHRcdFx0c2VsZi5jaGFubmVsLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRmb3IodmFyIG1lbWJlcktleSBpbiBteU1lbWJlcnMubWFwKSB7XG5cdFx0XHRpZighKG1lbWJlcktleSBpbiBtZW1iZXJzLm1hcCkpIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCknLCAnQXV0by1yZWVudGVyaW5nIGNsaWVudElkIFwiJyArIGVudHJ5LmNsaWVudElkICsgJ1wiIGludG8gdGhlIHByZXNlbmNlIHNldCcpO1xuXHRcdFx0XHR0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGVudHJ5LmNsaWVudElkLCBlbnRyeS5kYXRhLCAnZW50ZXInLCByZWVudGVyQ2IpO1xuXHRcdFx0XHRkZWxldGUgbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fc3ludGhlc2l6ZUxlYXZlcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdFx0dmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG5cdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0dmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xuXHRcdFx0XHRhY3Rpb246ICdsZWF2ZScsXG5cdFx0XHRcdGNvbm5lY3Rpb25JZDogaXRlbS5jb25uZWN0aW9uSWQsXG5cdFx0XHRcdGNsaWVudElkOiBpdGVtLmNsaWVudElkLFxuXHRcdFx0XHRkYXRhOiBpdGVtLmRhdGEsXG5cdFx0XHRcdGVuY29kaW5nOiBpdGVtLmVuY29kaW5nLFxuXHRcdFx0XHR0aW1lc3RhbXA6IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vdygpXG5cdFx0XHR9KTtcblx0XHRcdHN1YnNjcmlwdGlvbnMuZW1pdCgnbGVhdmUnLCBwcmVzZW5jZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyogRGVwcmVjYXRlZCAqL1xuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdwcmVzZW5jZS5vbicsICdwcmVzZW5jZS5zdWJzY3JpYmUnKTtcblx0XHR0aGlzLnN1YnNjcmliZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG5cdC8qIERlcHJlY2F0ZWQgKi9cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ3ByZXNlbmNlLm9mZicsICdwcmVzZW5jZS51bnN1YnNjcmliZScpO1xuXHRcdHRoaXMudW5zdWJzY3JpYmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbigvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLykge1xuXHRcdHZhciBhcmdzID0gcmVhbHRpbWVjaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJndW1lbnRzKTtcblx0XHR2YXIgZXZlbnQgPSBhcmdzWzBdO1xuXHRcdHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG5cdFx0dmFyIGNhbGxiYWNrID0gYXJnc1syXTtcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3N1YnNjcmliZScsIFtldmVudCwgbGlzdGVuZXJdKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnZmFpbGVkJykge1xuXHRcdFx0Y2FsbGJhY2soZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMocmVhbHRpbWVjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCdmYWlsZWQnKSkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuXHRcdGNoYW5uZWwuYXR0YWNoKGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKC8qIFtldmVudF0sIGxpc3RlbmVyICovKSB7XG5cdFx0dmFyIGFyZ3MgPSByZWFsdGltZWNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmd1bWVudHMpO1xuXHRcdHZhciBldmVudCA9IGFyZ3NbMF07XG5cdFx0dmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG5cdH07XG5cblx0ZnVuY3Rpb24gUHJlc2VuY2VNYXAocHJlc2VuY2UpIHtcblx0XHRldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzKTtcblx0XHR0aGlzLnByZXNlbmNlID0gcHJlc2VuY2U7XG5cdFx0dGhpcy5tYXAgPSB7fTtcblx0XHR0aGlzLnN5bmNJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0dGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFByZXNlbmNlTWFwLCBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXBba2V5XTtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIga2V5IGluIG1hcCkge1xuXHRcdFx0dmFyIGl0ZW0gPSBtYXBba2V5XTtcblx0XHRcdGlmKGl0ZW0uY2xpZW50SWQgPT0gY2xpZW50SWQgJiYgaXRlbS5hY3Rpb24gIT0gJ2Fic2VudCcpXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLFxuXHRcdFx0Y2xpZW50SWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNsaWVudElkLFxuXHRcdFx0Y29ubmVjdGlvbklkID0gcGFyYW1zICYmIHBhcmFtcy5jb25uZWN0aW9uSWQsXG5cdFx0XHRyZXN1bHQgPSBbXTtcblxuXHRcdGZvcih2YXIga2V5IGluIG1hcCkge1xuXHRcdFx0dmFyIGl0ZW0gPSBtYXBba2V5XTtcblx0XHRcdGlmKGl0ZW0uYWN0aW9uID09PSAnYWJzZW50JykgY29udGludWU7XG5cdFx0XHRpZihjbGllbnRJZCAmJiBjbGllbnRJZCAhPSBpdGVtLmNsaWVudElkKSBjb250aW51ZTtcblx0XHRcdGlmKGNvbm5lY3Rpb25JZCAmJiBjb25uZWN0aW9uSWQgIT0gaXRlbS5jb25uZWN0aW9uSWQpIGNvbnRpbnVlO1xuXHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZnVuY3Rpb24gbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nKSB7XG5cdFx0LyogUlRQMmIxOiBpZiBlaXRoZXIgaXMgc3ludGhlc2lzZWQsIGNvbXBhcmUgYnkgdGltZXN0YW1wICovXG5cdFx0aWYoaXRlbS5pc1N5bnRoZXNpemVkKCkgfHwgZXhpc3RpbmcuaXNTeW50aGVzaXplZCgpKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS50aW1lc3RhbXAgPiBleGlzdGluZy50aW1lc3RhbXA7XG5cdFx0fVxuXG5cdFx0LyogUlRQMmIyICovXG5cdFx0dmFyIGl0ZW1PcmRlcmluZ3MgPSBpdGVtLnBhcnNlSWQoKSxcblx0XHRcdGV4aXN0aW5nT3JkZXJpbmdzID0gZXhpc3RpbmcucGFyc2VJZCgpO1xuXHRcdGlmKGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID09PSBleGlzdGluZ09yZGVyaW5ncy5tc2dTZXJpYWwpIHtcblx0XHRcdHJldHVybiBpdGVtT3JkZXJpbmdzLmluZGV4ID4gZXhpc3RpbmdPcmRlcmluZ3MuaW5kZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBpdGVtT3JkZXJpbmdzLm1zZ1NlcmlhbCA+IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbDtcblx0XHR9XG5cdH1cblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmKGl0ZW0uYWN0aW9uID09PSAnZW50ZXInIHx8IGl0ZW0uYWN0aW9uID09PSAndXBkYXRlJykge1xuXHRcdFx0aXRlbSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKGl0ZW0pO1xuXHRcdFx0aXRlbS5hY3Rpb24gPSAncHJlc2VudCc7XG5cdFx0fVxuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwga2V5ID0gbWVtYmVyS2V5KGl0ZW0pO1xuXHRcdC8qIHdlJ3ZlIHNlZW4gdGhpcyBtZW1iZXIsIHNvIGRvIG5vdCByZW1vdmUgaXQgYXQgdGhlIGVuZCBvZiBzeW5jICovXG5cdFx0aWYodGhpcy5yZXNpZHVhbE1lbWJlcnMpXG5cdFx0XHRkZWxldGUgdGhpcy5yZXNpZHVhbE1lbWJlcnNba2V5XTtcblxuXHRcdC8qIGNvbXBhcmUgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbmV3IGl0ZW0gd2l0aCBhbnkgZXhpc3RpbmcgbWVtYmVyIChvciBBQlNFTlQgd2l0bmVzcykgKi9cblx0XHR2YXIgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG5cdFx0aWYoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRtYXBba2V5XSA9IGl0ZW07XG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGtleSBpbiBtYXApIHtcblx0XHRcdHZhciBpdGVtID0gbWFwW2tleV07XG5cdFx0XHRpZihpdGVtLmFjdGlvbiAhPSAnYWJzZW50Jylcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIGtleSA9IG1lbWJlcktleShpdGVtKTtcblx0XHR2YXIgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG5cblx0XHRpZihleGlzdGluZ0l0ZW0gJiYgIW5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyogUlRQMmYgKi9cblx0XHRpZih0aGlzLnN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHRpdGVtID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoaXRlbSk7XG5cdFx0XHRpdGVtLmFjdGlvbiA9ICdhYnNlbnQnO1xuXHRcdFx0bWFwW2tleV0gPSBpdGVtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgbWFwW2tleV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnN0YXJ0U3luYyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLnN0YXJ0U3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG5cdFx0Lyogd2UgbWlnaHQgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdoaWxlIGEgc3luYyBpcyBpbiBwcm9ncmVzcyAqL1xuXHRcdGlmKCF0aGlzLnN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNvcHkobWFwKTtcblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmVuZFN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdQcmVzZW5jZU1hcC5lbmRTeW5jKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArICc7IHN5bmNJblByb2dyZXNzID0gJyArIHN5bmNJblByb2dyZXNzKTtcblx0XHRpZihzeW5jSW5Qcm9ncmVzcykge1xuXHRcdFx0Lyogd2UgY2FuIG5vdyBzdHJpcCBvdXQgdGhlIEFCU0VOVCBtZW1iZXJzLCBhcyB3ZSBoYXZlXG5cdFx0XHQgKiByZWNlaXZlZCBhbGwgb2YgdGhlIG91dC1vZi1vcmRlciBzeW5jIG1lc3NhZ2VzICovXG5cdFx0XHRmb3IodmFyIG1lbWJlcktleSBpbiBtYXApIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gbWFwW21lbWJlcktleV07XG5cdFx0XHRcdGlmKGVudHJ5LmFjdGlvbiA9PT0gJ2Fic2VudCcpIHtcblx0XHRcdFx0XHRkZWxldGUgbWFwW21lbWJlcktleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8qIGFueSBtZW1iZXJzIHRoYXQgd2VyZSBwcmVzZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgc3luYyxcblx0XHRcdCAqIGFuZCBoYXZlIG5vdCBiZWVuIHNlZW4gaW4gc3luYywgY2FuIGJlIHJlbW92ZWQsIGFuZCBsZWF2ZSBldmVudHMgZW1pdHRlZCAqL1xuXHRcdFx0dGhpcy5wcmVzZW5jZS5fc3ludGhlc2l6ZUxlYXZlcyh1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS52YWx1ZXNBcnJheSh0aGlzLnJlc2lkdWFsTWVtYmVycykpO1xuXHRcdFx0Zm9yKHZhciBtZW1iZXJLZXkgaW4gdGhpcy5yZXNpZHVhbE1lbWJlcnMpIHtcblx0XHRcdFx0ZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuXG5cdFx0XHQvKiBmaW5pc2gsIG5vdGlmeWluZyBhbnkgd2FpdGVycyAqL1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcblx0XHR9XG5cdFx0dGhpcy5lbWl0KCdzeW5jJyk7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLndhaXRTeW5jID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHR2YXIgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLndhaXRTeW5jKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArICc7IHN5bmNJblByb2dyZXNzID0gJyArIHN5bmNJblByb2dyZXNzKTtcblx0XHRpZighc3luY0luUHJvZ3Jlc3MpIHtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub25jZSgnc3luYycsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdHRoaXMubWFwID0ge307XG5cdFx0dGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcblx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnNldEluUHJvZ3Jlc3MgPSBmdW5jdGlvbihpblByb2dyZXNzKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUHJlc2VuY2VNYXAuc2V0SW5Qcm9ncmVzcygpJywgJ2luUHJvZ3Jlc3MgPSAnICsgaW5Qcm9ncmVzcyk7XG5cdFx0dGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGluUHJvZ3Jlc3M7XG5cdFx0dGhpcy5wcmVzZW5jZS5zeW5jQ29tcGxldGUgPSAhaW5Qcm9ncmVzcztcblx0fTtcblxuXHRyZXR1cm4gUmVhbHRpbWVQcmVzZW5jZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJlYWx0aW1lcHJlc2VuY2UgPSAocmVhbHRpbWVwcmVzZW5jZV9SZWFsdGltZVByZXNlbmNlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZWNoYW5uZWwuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciByZWFsdGltZWNoYW5uZWxfUmVhbHRpbWVDaGFubmVsID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgYWN0aW9ucyA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5BY3Rpb247XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblx0dmFyIHN0YXRlY2hhbmdlT3AgPSAnc3RhdGVjaGFuZ2UnO1xuXHR2YXIgc3luY09wID0gJ3N5bmMnO1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBSZWFsdGltZUNoYW5uZWwocmVhbHRpbWUsIG5hbWUsIG9wdGlvbnMpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwoKScsICdzdGFydGVkOyBuYW1lID0gJyArIG5hbWUpO1xuXHRcdGNsaWVudF9jaGFubmVsLmNhbGwodGhpcywgcmVhbHRpbWUsIG5hbWUsIG9wdGlvbnMpO1xuXHRcdHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcblx0XHR0aGlzLnByZXNlbmNlID0gbmV3IHJlYWx0aW1lcHJlc2VuY2UodGhpcywgcmVhbHRpbWUub3B0aW9ucyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXI7XG5cdFx0dGhpcy5zdGF0ZSA9ICdpbml0aWFsaXplZCc7XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXHRcdHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0YXR0YWNoU2VyaWFsOiB1bmRlZmluZWRcblx0XHR9O1xuXHRcdHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0XHR0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcblx0XHR0aGlzLl9yZXF1ZXN0ZWRGbGFncyA9IG51bGw7XG5cdFx0dGhpcy5fbW9kZSA9IG51bGw7XG5cdFx0LyogVGVtcG9yYXJ5OyBvbmx5IHVzZWQgZm9yIHRoZSBjaGVja0NoYW5uZWxzT25SZXN1bWUgb3B0aW9uICovXG5cdFx0dGhpcy5fYXR0YWNoZWRNc2dJbmRpY2F0b3IgPSBmYWxzZTtcblx0XHR0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcblx0XHR0aGlzLl9kZWNvZGluZ0NvbnRleHQgPSB7XG5cdFx0XHRjaGFubmVsT3B0aW9uczogdGhpcy5jaGFubmVsT3B0aW9ucyxcblx0XHRcdHBsdWdpbnM6IHJlYWx0aW1lLm9wdGlvbnMucGx1Z2lucyB8fCB7IH0sXG5cdFx0XHRiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdW5kZWZpbmVkXG5cdFx0fTtcblx0XHR0aGlzLl9sYXN0UGF5bG9hZCA9IHtcblx0XHRcdG1lc3NhZ2VJZDogbnVsbCxcblx0XHRcdHByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw6IG51bGwsXG5cdFx0XHRkZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzOiBudWxsXG5cdFx0fTtcblx0XHQvKiBPbmx5IGRpZmZlcmVuY2VzIGJldHdlZW4gdGhpcyBhbmQgdGhlIHB1YmxpYyBldmVudCBlbWl0dGVyIGlzIHRoYXQgdGhpcyBlbWl0cyBhblxuXHRcdCAqIHVwZGF0ZSBldmVudCBmb3IgYWxsIEFUVEFDSEVEcywgd2hldGhlciByZXN1bWVkIG9yIG5vdCAqL1xuXHRcdHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzID0gbmV3IGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFJlYWx0aW1lQ2hhbm5lbCwgY2xpZW50X2NoYW5uZWwpO1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRcdGNvZGU6IDkwMDAxLFxuXHRcdFx0bWVzc2FnZTogJ0NoYW5uZWwgb3BlcmF0aW9uIGZhaWxlZCBhcyBjaGFubmVsIHN0YXRlIGlzICcgKyBzdGF0ZVxuXHRcdH07XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb2dyZXNzT3BzID0ge1xuXHRcdHN0YXRlY2hhbmdlOiBzdGF0ZWNoYW5nZU9wLFxuXHRcdHN5bmM6IHN5bmNPcFxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzID0gZnVuY3Rpb24oYXJncykge1xuXHRcdC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovXG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuXHRcdGlmKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRhcmdzLnVuc2hpZnQobnVsbCk7XG5cdFx0fVxuXHRcdGlmKGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PSB1bmRlZmluZWQpIHtcblx0XHRcdGFyZ3MucG9wKCk7XG5cdFx0fVxuXHRcdHJldHVybiBhcmdzO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc2V0T3B0aW9ucycsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oZXJyKXtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKScsICdTZXQgb3B0aW9ucyBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHZhciBlcnIgPSB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpO1xuXHRcdGlmKGVycikge1xuXHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y2xpZW50X2NoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHRpZiAodGhpcy5fZGVjb2RpbmdDb250ZXh0KVxuXHRcdFx0dGhpcy5fZGVjb2RpbmdDb250ZXh0LmNoYW5uZWxPcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcblx0XHRpZih0aGlzLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhvcHRpb25zKSkge1xuXHRcdFx0LyogVGhpcyBkb2VzIG5vdCBqdXN0IGRvIF9hdHRhY2godHJ1ZSwgbnVsbCwgY2FsbGJhY2spIGJlY2F1c2UgdGhhdCB3b3VsZCBwdXQgdXNcblx0XHRcdCAqIGludG8gdGhlICdhdHRhY2hpbmcnIHN0YXRlIHVudGlsIHdlIHJlY2VpdmUgdGhlIG5ldyBhdHRhY2hlZCwgd2hpY2ggaXNcblx0XHRcdCAqIGNvbmNlcHR1YWxseSBpbmNvcnJlY3Q6IHdlIGFyZSBzdGlsbCBhdHRhY2hlZCwgd2UganVzdCBoYXZlIGEgcGVuZGluZyByZXF1ZXN0IHRvXG5cdFx0XHQgKiBjaGFuZ2Ugc29tZSBjaGFubmVsIHBhcmFtcy4gUGVyIFJUTDE3IGdvaW5nIGludG8gdGhlIGF0dGFjaGluZyBzdGF0ZSB3b3VsZCBtZWFuXG5cdFx0XHQgKiByZWplY3RpbmcgbWVzc2FnZXMgdW50aWwgd2UgaGF2ZSBjb25maXJtYXRpb24gdGhhdCB0aGUgb3B0aW9ucyBoYXZlIGNoYW5nZWQsXG5cdFx0XHQgKiB3aGljaCB3b3VsZCB1bm5lY2Vzc2FyaWx5IGxvc2UgbWVzc2FnZSBjb250aW51aXR5LiAqL1xuXHRcdFx0dGhpcy5hdHRhY2hJbXBsKCk7XG5cdFx0XHR0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRcdHN3aXRjaCh0aGlzLmV2ZW50KSB7XG5cdFx0XHRcdFx0Y2FzZSAndXBkYXRlJzpcblx0XHRcdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhudWxsKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucykge1xuXHRcdGlmKG9wdGlvbnMgJiYgJ3BhcmFtcycgaW4gb3B0aW9ucyAmJiAhdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNPYmplY3Qob3B0aW9ucy5wYXJhbXMpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnb3B0aW9ucy5wYXJhbXMgbXVzdCBiZSBhbiBvYmplY3QnLCA0MDAwMCwgNDAwKTtcblx0XHR9XG5cdFx0aWYob3B0aW9ucyAmJiAnbW9kZXMnIGluIG9wdGlvbnMpe1xuXHRcdFx0aWYoIXV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkob3B0aW9ucy5tb2Rlcykpe1xuXHRcdFx0XHRyZXR1cm4gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnb3B0aW9ucy5tb2RlcyBtdXN0IGJlIGFuIGFycmF5JywgNDAwMDAsIDQwMCk7XG5cdFx0XHR9XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5tb2Rlcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdHZhciBjdXJyZW50TW9kZSA9IG9wdGlvbnMubW9kZXNbaV07XG5cdFx0XHRcdGlmKCFjdXJyZW50TW9kZSB8fCB0eXBlb2YgY3VycmVudE1vZGUgIT09ICdzdHJpbmcnIHx8ICF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uY2hhbm5lbE1vZGVzLCBTdHJpbmcucHJvdG90eXBlLnRvVXBwZXJDYXNlLmNhbGwoY3VycmVudE1vZGUpKSl7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0ludmFsaWQgY2hhbm5lbCBtb2RlOiAnICsgY3VycmVudE1vZGUsIDQwMDAwLCA0MDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuICh0aGlzLnN0YXRlID09PSAnYXR0YWNoZWQnIHx8IHRoaXMuc3RhdGUgPT09ICdhdHRhY2hpbmcnKSAmJiAob3B0aW9ucy5wYXJhbXMgfHwgb3B0aW9ucy5tb2Rlcyk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdG1lc3NhZ2VzID0gYXJndW1lbnRzWzBdLFxuXHRcdFx0Y2FsbGJhY2sgPSBhcmd1bWVudHNbYXJnQ291bnQgLSAxXTtcblxuXHRcdGlmKHR5cGVvZihjYWxsYmFjaykgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdwdWJsaXNoJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdCsrYXJnQ291bnQ7XG5cdFx0fVxuXHRcdGlmKCF0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcblx0XHRcdGNhbGxiYWNrKHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmKGFyZ0NvdW50ID09IDIpIHtcblx0XHRcdGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzT2JqZWN0KG1lc3NhZ2VzKSlcblx0XHRcdFx0bWVzc2FnZXMgPSBbdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKG1lc3NhZ2VzKV07XG5cdFx0XHRlbHNlIGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkobWVzc2FnZXMpKVxuXHRcdFx0XHRtZXNzYWdlcyA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlc0FycmF5KG1lc3NhZ2VzKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzJywgNDAwMTMsIDQwMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lc3NhZ2VzID0gW3R5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7bmFtZTogYXJndW1lbnRzWzBdLCBkYXRhOiBhcmd1bWVudHNbMV19KV07XG5cdFx0fVxuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdG1heE1lc3NhZ2VTaXplID0gdGhpcy5yZWFsdGltZS5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuXHRcdHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiBSU0wxaSAqL1xuXHRcdFx0dmFyIHNpemUgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcyk7XG5cdFx0XHRpZihzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICggd2FzICcgKyBzaXplICsgJyBieXRlczsgbGltaXQgaXMgJyArIG1heE1lc3NhZ2VTaXplICsgJyBieXRlcyknLCA0MDAwOSwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGYuX3B1Ymxpc2gobWVzc2FnZXMsIGNhbGxiYWNrKTtcblx0XHR9KTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9wdWJsaXNoID0gZnVuY3Rpb24obWVzc2FnZXMsIGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKScsICdtZXNzYWdlIGNvdW50ID0gJyArIG1lc3NhZ2VzLmxlbmd0aCk7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblx0XHRzd2l0Y2goc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRjYWxsYmFjayhlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhSZWFsdGltZUNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3Ioc3RhdGUpKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKScsICdzZW5kaW5nIG1lc3NhZ2U7IGNoYW5uZWwgc3RhdGUgaXMgJyArIHN0YXRlKTtcblx0XHRcdFx0dmFyIG1zZyA9IG5ldyBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblx0XHRcdFx0bXNnLmFjdGlvbiA9IGFjdGlvbnMuTUVTU0FHRTtcblx0XHRcdFx0bXNnLmNoYW5uZWwgPSB0aGlzLm5hbWU7XG5cdFx0XHRcdG1zZy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuXHRcdFx0XHR0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbkV2ZW50ID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwub25FdmVudCgpJywgJ3JlY2VpdmVkIG1lc3NhZ2UnKTtcblx0XHR2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucztcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtZXNzYWdlID0gbWVzc2FnZXNbaV07XG5cdFx0XHRzdWJzY3JpcHRpb25zLmVtaXQobWVzc2FnZS5uYW1lLCBtZXNzYWdlKTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmbGFncywgY2FsbGJhY2spIHtcblx0XHRpZih0eXBlb2YoZmxhZ3MpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjYWxsYmFjayA9IGZsYWdzO1xuXHRcdFx0ZmxhZ3MgPSBudWxsO1xuXHRcdH1cblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdhdHRhY2gnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLmF0dGFjaCgpJywgJ0NoYW5uZWwgYXR0YWNoIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihmbGFncykge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ2NoYW5uZWwuYXR0YWNoKCkgd2l0aCBmbGFncycsICdjaGFubmVsLnNldE9wdGlvbnMoKSB3aXRoIGNoYW5uZWxPcHRpb25zLnBhcmFtcycpO1xuXHRcdFx0LyogSWYgZmxhZ3MgcmVxdWVzdGVkLCBhbHdheXMgZG8gYSByZS1hdHRhY2guIFRPRE8gb25seSBkbyB0aGlzIGlmXG5cdFx0XHQgKiBjdXJyZW50IG1vZGUgZGlmZmVycyBmcm9tIHJlcXVlc3RlZCBtb2RlICovXG5cdFx0XHR0aGlzLl9yZXF1ZXN0ZWRGbGFncyA9IGZsYWdzO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9hdHRhY2goZmFsc2UsIG51bGwsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9hdHRhY2ggPSBmdW5jdGlvbihmb3JjZVJlYXR0YWNoLCBhdHRhY2hSZWFzb24sIGNhbGxiYWNrKSB7XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLl9hdHRhY2goKScsICdDaGFubmVsIGF0dGFjaCBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuXHRcdGlmKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zdGF0ZSAhPT0gJ2F0dGFjaGluZycgfHwgZm9yY2VSZWF0dGFjaCkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIGF0dGFjaFJlYXNvbik7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRzd2l0Y2godGhpcy5ldmVudCkge1xuXHRcdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxuXHRcdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdBdHRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBkZXRhY2ggcmVxdWVzdCcsIDkwMDAwLCA0MDkpKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmF0dGFjaEltcGwgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuYXR0YWNoSW1wbCgpJywgJ3NlbmRpbmcgQVRUQUNIIG1lc3NhZ2UnKTtcblx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgdHJ1ZSk7XG5cdFx0dmFyIGF0dGFjaE1zZyA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuQVRUQUNILCBjaGFubmVsOiB0aGlzLm5hbWUsIHBhcmFtczogdGhpcy5jaGFubmVsT3B0aW9ucy5wYXJhbXN9KTtcblx0XHRpZih0aGlzLl9yZXF1ZXN0ZWRGbGFncykge1xuXHRcdFx0YXR0YWNoTXNnLmVuY29kZU1vZGVzVG9GbGFncyh0aGlzLl9yZXF1ZXN0ZWRGbGFncyk7XG5cdFx0fSBlbHNlIGlmKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpIHtcblx0XHRcdGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3ModXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYWxsVG9VcHBlckNhc2UodGhpcy5jaGFubmVsT3B0aW9ucy5tb2RlcykpO1xuXHRcdH1cblx0XHRpZih0aGlzLl9hdHRhY2hSZXN1bWUpIHtcblx0XHRcdGF0dGFjaE1zZy5zZXRGbGFnKCdBVFRBQ0hfUkVTVU1FJyk7XG5cdFx0fVxuXHRcdGlmKHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcblx0XHRcdGF0dGFjaE1zZy5jaGFubmVsU2VyaWFsID0gdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbDtcblx0XHR9XG5cdFx0dGhpcy5zZW5kTWVzc2FnZShhdHRhY2hNc2csIG5vb3ApO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdkZXRhY2gnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblx0XHR2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuXHRcdGlmKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5yZXF1ZXN0U3RhdGUoJ2RldGFjaGluZycpO1xuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdFx0dGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRcdFx0c3dpdGNoKHRoaXMuZXZlbnQpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0RldGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGF0dGFjaCByZXF1ZXN0JywgOTAwMDAsIDQwOSkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmRldGFjaEltcGwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5kZXRhY2goKScsICdzZW5kaW5nIERFVEFDSCBtZXNzYWdlJyk7XG5cdFx0dGhpcy5zZXRJblByb2dyZXNzKHN0YXRlY2hhbmdlT3AsIHRydWUpO1xuXHRcdHZhciBtc2cgPSBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7YWN0aW9uOiBhY3Rpb25zLkRFVEFDSCwgY2hhbm5lbDogdGhpcy5uYW1lfSk7XG5cdFx0dGhpcy5zZW5kTWVzc2FnZShtc2csIChjYWxsYmFjayB8fCBub29wKSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbigvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLykge1xuXHRcdHZhciBhcmdzID0gUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJndW1lbnRzKTtcblx0XHR2YXIgZXZlbnQgPSBhcmdzWzBdO1xuXHRcdHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG5cdFx0dmFyIGNhbGxiYWNrID0gYXJnc1syXTtcblxuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3N1YnNjcmliZScsIFtldmVudCwgbGlzdGVuZXJdKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZih0aGlzLnN0YXRlID09PSAnZmFpbGVkJykge1xuXHRcdFx0Y2FsbGJhY2soZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoUmVhbHRpbWVDaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCdmYWlsZWQnKSkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0YWNoKGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oLyogW2V2ZW50XSwgbGlzdGVuZXIgKi8pIHtcblx0XHR2YXIgYXJncyA9IFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGV2ZW50ID0gYXJnc1swXTtcblx0XHR2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHQvKiBjaGVjayBwcmVjb25kaXRpb25zICovXG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2luaXRpYWxpemVkJzpcblx0XHRcdGNhc2UgJ2RldGFjaGluZyc6XG5cdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJVbmFibGUgdG8gc3luYyB0byBjaGFubmVsOyBub3QgYXR0YWNoZWRcIiwgNDAwMDApO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHR9XG5cdFx0dmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcblx0XHRpZighY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0dGhyb3cgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKTtcblx0XHR9XG5cblx0XHQvKiBzZW5kIHN5bmMgcmVxdWVzdCAqL1xuXHRcdHZhciBzeW5jTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuU1lOQywgY2hhbm5lbDogdGhpcy5uYW1lfSk7XG5cdFx0aWYodGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCkge1xuXHRcdFx0c3luY01lc3NhZ2UuY2hhbm5lbFNlcmlhbCA9IHRoaXMuc3luY0NoYW5uZWxTZXJpYWw7XG5cdFx0fVxuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoc3luY01lc3NhZ2UpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbihtc2csIGNhbGxiYWNrKSB7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5zZW5kKG1zZywgdGhpcy5yZWFsdGltZS5vcHRpb25zLnF1ZXVlTWVzc2FnZXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNlbmRQcmVzZW5jZSA9IGZ1bmN0aW9uKHByZXNlbmNlLCBjYWxsYmFjaykge1xuXHRcdHZhciBtc2cgPSBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7XG5cdFx0XHRhY3Rpb246IGFjdGlvbnMuUFJFU0VOQ0UsXG5cdFx0XHRjaGFubmVsOiB0aGlzLm5hbWUsXG5cdFx0XHRwcmVzZW5jZTogKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkocHJlc2VuY2UpID9cblx0XHRcdFx0cHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXNBcnJheShwcmVzZW5jZSkgOlxuXHRcdFx0XHRbcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMocHJlc2VuY2UpXSlcblx0XHR9KTtcblx0XHR0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHZhciBzeW5jQ2hhbm5lbFNlcmlhbCwgaXNTeW5jID0gZmFsc2U7XG5cdFx0c3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XG5cdFx0Y2FzZSBhY3Rpb25zLkFUVEFDSEVEOlxuXHRcdFx0dGhpcy5fYXR0YWNoZWRNc2dJbmRpY2F0b3IgPSB0cnVlO1xuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcblx0XHRcdHRoaXMuX21vZGUgPSBtZXNzYWdlLmdldE1vZGUoKTtcblx0XHRcdHRoaXMucGFyYW1zID0gbWVzc2FnZS5wYXJhbXMgfHwge307XG5cdFx0XHR2YXIgbW9kZXNGcm9tRmxhZ3MgPSBtZXNzYWdlLmRlY29kZU1vZGVzRnJvbUZsYWdzKCk7XG5cdFx0XHR0aGlzLm1vZGVzID0gKG1vZGVzRnJvbUZsYWdzICYmIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFsbFRvTG93ZXJDYXNlKG1vZGVzRnJvbUZsYWdzKSkgfHwgdW5kZWZpbmVkO1xuXHRcdFx0dmFyIHJlc3VtZWQgPSBtZXNzYWdlLmhhc0ZsYWcoJ1JFU1VNRUQnKTtcblx0XHRcdHZhciBoYXNQcmVzZW5jZSA9IG1lc3NhZ2UuaGFzRmxhZygnSEFTX1BSRVNFTkNFJyk7XG5cdFx0XHRpZih0aGlzLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRcdC8qIGF0dGFjaGVkIG9wZXJhdGlvbnMgdG8gY2hhbmdlIG9wdGlvbnMgc2V0IHRoZSBpbnByb2dyZXNzIG11dGV4LCBidXQgbGVhdmVcblx0XHRcdFx0ICogY2hhbm5lbCBpbiB0aGUgYXR0YWNoZWQgc3RhdGUgKi9cblx0XHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN0YXRlY2hhbmdlT3AsIGZhbHNlKTtcblx0XHRcdFx0aWYoIXJlc3VtZWQpIHtcblx0XHRcdFx0XHQvKiBPbiBhIGxvc3Mgb2YgY29udGludWl0eSwgdGhlIHByZXNlbmNlIHNldCBuZWVkcyB0byBiZSByZS1zeW5jZWQgKi9cblx0XHRcdFx0XHR0aGlzLnByZXNlbmNlLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlKHRoaXMuc3RhdGUsIHRoaXMuc3RhdGUsIHJlc3VtZWQsIG1lc3NhZ2UuZXJyb3IpO1xuXHRcdFx0XHR0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuXHRcdFx0XHRpZighcmVzdW1lZCB8fCB0aGlzLmNoYW5uZWxPcHRpb25zLnVwZGF0ZU9uQXR0YWNoZWQpIHtcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2F0dGFjaGVkJywgbWVzc2FnZS5lcnJvciwgcmVzdW1lZCwgaGFzUHJlc2VuY2UpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIGFjdGlvbnMuREVUQUNIRUQ6XG5cdFx0XHR2YXIgZXJyID0gbWVzc2FnZS5lcnJvciA/IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKG1lc3NhZ2UuZXJyb3IpIDogbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2hhbm5lbCBkZXRhY2hlZCcsIDkwMDAxLCA0MDQpO1xuXHRcdFx0aWYodGhpcy5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnZGV0YWNoZWQnLCBlcnIpO1xuXHRcdFx0fSBlbHNlIGlmKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hpbmcnKSB7XG5cdFx0XHRcdC8qIE9ubHkgcmV0cnkgaW1tZWRpYXRlbHkgaWYgd2Ugd2VyZSBwcmV2aW91c2x5IGF0dGFjaGVkLiBJZiB3ZSB3ZXJlXG5cdFx0XHRcdCAqIGF0dGFjaGluZywgZ28gaW50byBzdXNwZW5kZWQsIGZhaWwgbWVzc2FnZXMsIGFuZCB3YWl0IGEgZmV3IHNlY29uZHNcblx0XHRcdFx0ICogYmVmb3JlIHJldHJ5aW5nICovXG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ3N1c3BlbmRlZCcsIGVycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJywgZXJyKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBhY3Rpb25zLlNZTkM6XG5cdFx0XHQvKiBzeW5jcyBjYW4gaGF2ZSBjaGFubmVsU2VyaWFscywgYnV0IG1pZ2h0IG5vdCBpZiB0aGUgc3luYyBpcyBvbmUgcGFnZSBsb25nICovXG5cdFx0XHRpc1N5bmMgPSB0cnVlO1xuXHRcdFx0c3luY0NoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuXHRcdFx0Lyogc3luY3MgY2FuIGhhcHBlbiBvbiBjaGFubmVscyB3aXRoIG5vIHByZXNlbmNlIGRhdGEgYXMgcGFydCBvZiBjb25uZWN0aW9uXG5cdFx0XHQgKiByZXN1bWluZywgaW4gd2hpY2ggY2FzZSBwcm90b2NvbCBtZXNzYWdlIGhhcyBubyBwcmVzZW5jZSBwcm9wZXJ0eSAqL1xuXHRcdFx0aWYoIW1lc3NhZ2UucHJlc2VuY2UpIGJyZWFrO1xuXHRcdGNhc2UgYWN0aW9ucy5QUkVTRU5DRTpcblx0XHRcdHZhciBwcmVzZW5jZSA9IG1lc3NhZ2UucHJlc2VuY2UsXG5cdFx0XHRcdGlkID0gbWVzc2FnZS5pZCxcblx0XHRcdFx0Y29ubmVjdGlvbklkID0gbWVzc2FnZS5jb25uZWN0aW9uSWQsXG5cdFx0XHRcdHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xuXG5cdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbE9wdGlvbnM7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgcHJlc2VuY2VNc2cgPSBwcmVzZW5jZVtpXTtcblx0XHRcdFx0XHRwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVjb2RlKHByZXNlbmNlTXNnLCBvcHRpb25zKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXByZXNlbmNlTXNnLmNvbm5lY3Rpb25JZCkgcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuXHRcdFx0XHRpZighcHJlc2VuY2VNc2cudGltZXN0YW1wKSBwcmVzZW5jZU1zZy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cdFx0XHRcdGlmKCFwcmVzZW5jZU1zZy5pZCkgcHJlc2VuY2VNc2cuaWQgPSBpZCArICc6JyArIGk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnByZXNlbmNlLnNldFByZXNlbmNlKHByZXNlbmNlLCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBhY3Rpb25zLk1FU1NBR0U6XG5cblx0XHRcdC8vUlRMMTdcblx0XHRcdGlmKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ01lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBza2lwcGVkIGFzIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIgc3RhdGUgaXMgbm90IFwiYXR0YWNoZWRcIiAoc3RhdGUgaXMgXCInICsgdGhpcy5zdGF0ZSArICdcIikuJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG1lc3NhZ2VzID0gbWVzc2FnZS5tZXNzYWdlcyxcblx0XHRcdFx0Zmlyc3RNZXNzYWdlID0gbWVzc2FnZXNbMF0sXG5cdFx0XHRcdGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0sXG5cdFx0XHRcdGlkID0gbWVzc2FnZS5pZCxcblx0XHRcdFx0Y29ubmVjdGlvbklkID0gbWVzc2FnZS5jb25uZWN0aW9uSWQsXG5cdFx0XHRcdHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xuXG5cdFx0XHRpZihmaXJzdE1lc3NhZ2UuZXh0cmFzICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEgJiYgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YS5mcm9tICE9PSB0aGlzLl9sYXN0UGF5bG9hZC5tZXNzYWdlSWQpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdEZWx0YSBtZXNzYWdlIGRlY29kZSBmYWlsdXJlIC0gcHJldmlvdXMgbWVzc2FnZSBub3QgYXZhaWxhYmxlIGZvciBtZXNzYWdlIFwiJyArIG1lc3NhZ2UuaWQgKyAnXCIgb24gdGhpcyBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIi4nO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBtc2cpO1xuXHRcdFx0XHR0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAwMTgsIDQwMCkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBtc2cgPSBtZXNzYWdlc1tpXTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZShtc2csIHRoaXMuX2RlY29kaW5nQ29udGV4dCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvKiBkZWNyeXB0IGZhaWxlZCAuLiB0aGUgbW9zdCBsaWtlbHkgY2F1c2UgaXMgdGhhdCB3ZSBoYXZlIHRoZSB3cm9uZyBrZXkgKi9cblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRcdHN3aXRjaChlLmNvZGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgNDAwMTg6XG5cdFx0XHRcdFx0XHRcdC8qIGRlY29kZSBmYWlsdXJlICovXG5cdFx0XHRcdFx0XHRcdHRoaXMuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KGUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRjYXNlIDQwMDE5OlxuXHRcdFx0XHRcdFx0XHQvKiBObyB2Y2RpZmYgcGx1Z2luIHBhc3NlZCBpbiAtIG5vIHBvaW50IHJlY292ZXJpbmcsIGdpdmUgdXAgKi9cblx0XHRcdFx0XHRcdGNhc2UgNDAwMjE6XG5cdFx0XHRcdFx0XHRcdC8qIEJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBkZWx0YXMsIHNpbWlsYXJseSBubyBwb2ludCByZWNvdmVyaW5nICovXG5cdFx0XHRcdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2ZhaWxlZCcsIGUpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFtc2cuY29ubmVjdGlvbklkKSBtc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuXHRcdFx0XHRpZighbXNnLnRpbWVzdGFtcCkgbXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcblx0XHRcdFx0aWYoIW1zZy5pZCkgbXNnLmlkID0gaWQgKyAnOicgKyBpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkID0gbGFzdE1lc3NhZ2UuaWQ7XG5cdFx0XHR0aGlzLl9sYXN0UGF5bG9hZC5wcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuXHRcdFx0dGhpcy5vbkV2ZW50KG1lc3NhZ2VzKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBhY3Rpb25zLkVSUk9SOlxuXHRcdFx0LyogdGhlcmUgd2FzIGEgY2hhbm5lbC1zcGVjaWZpYyBlcnJvciAqL1xuXHRcdFx0dmFyIGVyciA9IG1lc3NhZ2UuZXJyb3I7XG5cdFx0XHRpZihlcnIgJiYgZXJyLmNvZGUgPT0gODAwMTYpIHtcblx0XHRcdFx0LyogYXR0YWNoL2RldGFjaCBvcGVyYXRpb24gYXR0ZW1wdGVkIG9uIHN1cGVyc2VkZWQgdHJhbnNwb3J0IGhhbmRsZSAqL1xuXHRcdFx0XHR0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdmYWlsZWQnLCBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhlcnIpKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsICdGYXRhbCBwcm90b2NvbCBlcnJvcjogdW5yZWNvZ25pc2VkIGFjdGlvbiAoJyArIG1lc3NhZ2UuYWN0aW9uICsgJyknKTtcblx0XHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWJvcnQoY29ubmVjdGlvbmVycm9yW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnVua25vd25DaGFubmVsRXJyKTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkgPSBmdW5jdGlvbihyZWFzb24pIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIXRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NQUpPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsICdTdGFydGluZyBkZWNvZGUgZmFpbHVyZSByZWNvdmVyeSBwcm9jZXNzLicpO1xuXHRcdFx0dGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0XHR0aGlzLl9hdHRhY2godHJ1ZSwgcmVhc29uLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25BdHRhY2hlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbkF0dGFjaGVkJywgJ2FjdGl2YXRpbmcgY2hhbm5lbDsgbmFtZSA9ICcgKyB0aGlzLm5hbWUpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUubm90aWZ5U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgcmVhc29uLCByZXN1bWVkLCBoYXNQcmVzZW5jZSkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5ub3RpZnlTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIGN1cnJlbnQgc3RhdGUgPSAnICsgdGhpcy5zdGF0ZSArICcsIG5vdGlmeWluZyBzdGF0ZSAnICsgc3RhdGUpO1xuXHRcdHRoaXMuY2xlYXJTdGF0ZVRpbWVyKCk7XG5cblx0XHRpZihzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLnByZXNlbmNlLmFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgcmVhc29uKTtcblx0XHRpZihzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHR0aGlzLnN0YXJ0UmV0cnlUaW1lcigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcblx0XHR9XG5cdFx0aWYocmVhc29uKSB7XG5cdFx0XHR0aGlzLmVycm9yUmVhc29uID0gcmVhc29uO1xuXHRcdH1cblx0XHR2YXIgY2hhbmdlID0gbmV3IGNoYW5uZWxzdGF0ZWNoYW5nZSh0aGlzLnN0YXRlLCBzdGF0ZSwgcmVzdW1lZCwgcmVhc29uKTtcblx0XHR2YXIgbG9nTGV2ZWwgPSBzdGF0ZSA9PT0gJ2ZhaWxlZCcgPyBsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SIDogbG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NQUpPUjtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ0xldmVsLCAnQ2hhbm5lbCBzdGF0ZSBmb3IgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCInLCBzdGF0ZSArIChyZWFzb24gPyAoJzsgcmVhc29uOiAnICsgcmVhc29uKSA6ICcnKSk7XG5cblx0XHQvKiBOb3RlOiB3ZSBkb24ndCBzZXQgaW5Qcm9ncmVzcyBmb3IgcGVuZGluZyBzdGF0ZXMgdW50aWwgdGhlIHJlcXVlc3QgaXMgYWN0dWFsbHkgaW4gcHJvZ3Jlc3MgKi9cblx0XHRpZihzdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0dGhpcy5vbkF0dGFjaGVkKCk7XG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3luY09wLCBoYXNQcmVzZW5jZSk7XG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgZmFsc2UpO1xuXHRcdH0gZWxzZSBpZihzdGF0ZSA9PT0gJ2RldGFjaGVkJyB8fCBzdGF0ZSA9PT0gJ2ZhaWxlZCcgfHwgc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgZmFsc2UpO1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN5bmNPcCwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdGlmKHN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHR0aGlzLl9hdHRhY2hSZXN1bWUgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZihzdGF0ZSA9PT0gJ2RldGFjaGluZycgfHwgc3RhdGUgPT09ICdmYWlsZWQnKSB7XG5cdFx0XHR0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLnN0YXRlID0gc3RhdGU7XG5cdFx0dGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMuZW1pdChzdGF0ZSwgY2hhbmdlKTtcblx0XHR0aGlzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5yZXF1ZXN0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgcmVhc29uKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLnJlcXVlc3RTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIHN0YXRlID0gJyArIHN0YXRlKTtcblx0XHR0aGlzLm5vdGlmeVN0YXRlKHN0YXRlLCByZWFzb24pO1xuXHRcdC8qIHNlbmQgdGhlIGV2ZW50IGFuZCBhd2FpdCByZXNwb25zZSAqL1xuXHRcdHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmNoZWNrUGVuZGluZ1N0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0LyogaWYgY2FuJ3Qgc2VuZCBldmVudHMsIGRvIG5vdGhpbmcgKi9cblx0XHR2YXIgY21TdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGU7XG5cdFx0LyogQWxsb3cgYXR0YWNoIG1lc3NhZ2VzIHRvIHF1ZXVlIHVwIHdoZW4gc3luY2hyb25pemluZywgc2luY2UgdGhpcyB3aWxsIGJlXG5cdFx0ICogdGhlIHN0YXRlIHdlJ2xsIGJlIGluIHdoZW4gdXBncmFkZSB0cmFuc3BvcnQuYWN0aXZlIHRyaWdnZXJzIGEgY2hlY2twZW5kaW5nc3RhdGUgKi9cblx0XHRpZighKGNtU3RhdGUuc2VuZEV2ZW50cyB8fCBjbVN0YXRlLmZvcmNlUXVldWVFdmVudHMpKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUnLCAnc2VuZEV2ZW50cyBpcyBmYWxzZTsgc3RhdGUgaXMgJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIHN0YXRlID0gJyArIHRoaXMuc3RhdGUpO1xuXHRcdC8qIE9ubHkgc3RhcnQgdGhlIHN0YXRlIHRpbWVyIHJ1bm5pbmcgd2hlbiBhY3R1YWxseSBzZW5kaW5nIHRoZSBldmVudCAqL1xuXHRcdHN3aXRjaCh0aGlzLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHR0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuXHRcdFx0XHR0aGlzLmF0dGFjaEltcGwoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0XHR0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xuXHRcdFx0XHR0aGlzLmRldGFjaEltcGwoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdC8qIHJlc3VtZSBhbnkgc3luYyBvcGVyYXRpb24gdGhhdCB3YXMgaW4gcHJvZ3Jlc3MgKi9cblx0XHRcdFx0dGhpcy5zeW5jKCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS50aW1lb3V0UGVuZGluZ1N0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDaGFubmVsIGF0dGFjaCB0aW1lZCBvdXQnLCA5MDAwNywgNDA4KTtcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnc3VzcGVuZGVkJywgZXJyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxuXHRcdFx0XHR2YXIgZXJyID0gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2hhbm5lbCBkZXRhY2ggdGltZWQgb3V0JywgOTAwMDcsIDQwOCk7XG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2F0dGFjaGVkJywgZXJyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZighdGhpcy5zdGF0ZVRpbWVyKSB7XG5cdFx0XHR0aGlzLnN0YXRlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nJywgJ3RpbWVyIGV4cGlyZWQnKTtcblx0XHRcdFx0c2VsZi5zdGF0ZVRpbWVyID0gbnVsbDtcblx0XHRcdFx0c2VsZi50aW1lb3V0UGVuZGluZ1N0YXRlKCk7XG5cdFx0XHR9LCB0aGlzLnJlYWx0aW1lLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2xlYXJTdGF0ZVRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN0YXRlVGltZXIgPSB0aGlzLnN0YXRlVGltZXI7XG5cdFx0aWYoc3RhdGVUaW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xuXHRcdFx0dGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdGFydFJldHJ5VGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYodGhpcy5yZXRyeVRpbWVyKSByZXR1cm47XG5cblx0XHR0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0LyogSWYgY29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkLCBqdXN0IGxlYXZlIGluIHN1c3BlbmRlZCwgYSByZWF0dGFjaFxuXHRcdFx0ICogd2lsbCBiZSB0cmlnZ2VyZWQgb25jZSBpdCBjb25uZWN0cyBhZ2FpbiAqL1xuXHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgc2VsZi5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHRcdHNlbGYucmV0cnlUaW1lciA9IG51bGw7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbCByZXRyeSB0aW1lciBleHBpcmVkJywgJ2F0dGVtcHRpbmcgYSBuZXcgYXR0YWNoJyk7XG5cdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzLnJlYWx0aW1lLm9wdGlvbnMudGltZW91dHMuY2hhbm5lbFJldHJ5VGltZW91dCk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jYW5jZWxSZXRyeVRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYodGhpcy5yZXRyeVRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcblx0XHRcdHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZXRJblByb2dyZXNzID0gZnVuY3Rpb24ob3BlcmF0aW9uLCB2YWx1ZSkge1xuXHRcdHRoaXMucmVzdC5jaGFubmVscy5zZXRJblByb2dyZXNzKHRoaXMsIG9wZXJhdGlvbiwgdmFsdWUpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdoaXN0b3J5JywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuXHRcdFx0aWYodGhpcy5zdGF0ZSAhPT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkXCIsIDQwMDAwLCA0MDApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShcInVudGlsQXR0YWNoIHdhcyBzcGVjaWZpZWQgYW5kIGNoYW5uZWwgaXMgYXR0YWNoZWQsIGJ1dCBhdHRhY2hTZXJpYWwgaXMgbm90IGRlZmluZWRcIiwgNDAwMDAsIDQwMCkpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuXHRcdFx0cGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbDtcblx0XHR9XG5cblx0XHRjbGllbnRfY2hhbm5lbC5wcm90b3R5cGUuX2hpc3RvcnkuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLndoZW5TdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBsaXN0ZW5lcikge1xuXHRcdHJldHVybiBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlLCBsaXN0ZW5lcik7XG5cdH1cblxuXHQvKiBAcmV0dXJucyBudWxsIChpZiBjYW4gc2FmZWx5IGJlIHJlbGVhc2VkKSB8IEVycm9ySW5mbyAoaWYgY2Fubm90KSAqL1xuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmdldFJlbGVhc2VFcnIgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcyA9IHRoaXMuc3RhdGU7XG5cdFx0aWYocyA9PT0gJ2luaXRpYWxpemVkJyB8fCBzID09PSAnZGV0YWNoZWQnIHx8IHMgPT09ICdmYWlsZWQnKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0NhbiBvbmx5IHJlbGVhc2UgYSBjaGFubmVsIGluIGEgc3RhdGUgd2hlcmUgdGhlcmUgaXMgbm8gcG9zc2liaWxpdHkgb2YgZnVydGhlciB1cGRhdGVzIGZyb20gdGhlIHNlcnZlciBiZWluZyByZWNlaXZlZCAoaW5pdGlhbGl6ZWQsIGRldGFjaGVkLCBvciBmYWlsZWQpOyB3YXMgJyArIHMsIDkwMDAxLCA0MDApO1xuXHR9XG5cblx0cmV0dXJuIFJlYWx0aW1lQ2hhbm5lbDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJlYWx0aW1lY2hhbm5lbCA9IChyZWFsdGltZWNoYW5uZWxfUmVhbHRpbWVDaGFubmVsKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9lcnJvcnJlcG9ydGVyLmpzXG52YXIgZXJyb3JyZXBvcnRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lLmpzXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciByZWFsdGltZV9SZWFsdGltZSA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBSZWFsdGltZShvcHRpb25zKSB7XG5cdFx0aWYoISh0aGlzIGluc3RhbmNlb2YgUmVhbHRpbWUpKXtcblx0XHRcdHJldHVybiBuZXcgUmVhbHRpbWUob3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWUoKScsICcnKTtcblx0XHRjbGllbnRfcmVzdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdHRoaXMuY29ubmVjdGlvbiA9IG5ldyBjb25uZWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG5cdFx0dGhpcy5jaGFubmVscyA9IG5ldyBDaGFubmVscyh0aGlzKTtcblx0XHRpZihvcHRpb25zLmF1dG9Db25uZWN0ICE9PSBmYWxzZSlcblx0XHRcdHRoaXMuY29ubmVjdCgpO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFJlYWx0aW1lLCBjbGllbnRfcmVzdCk7XG5cblx0UmVhbHRpbWUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZS5jb25uZWN0KCknLCAnJyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoKTtcblx0fTtcblxuXHRSZWFsdGltZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZS5jbG9zZSgpJywgJycpO1xuXHRcdHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIENoYW5uZWxzKHJlYWx0aW1lKSB7XG5cdFx0ZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5yZWFsdGltZSA9IHJlYWx0aW1lO1xuXHRcdHRoaXMuYWxsID0ge307XG5cdFx0dGhpcy5pblByb2dyZXNzID0ge307XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIub24oJ3RyYW5zcG9ydC5hY3RpdmUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYub25UcmFuc3BvcnRBY3RpdmUoKTtcblx0XHR9KTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhDaGFubmVscywgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUub25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuXHRcdHZhciBjaGFubmVsTmFtZSA9IG1zZy5jaGFubmVsO1xuXHRcdGlmKGNoYW5uZWxOYW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0NoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBldmVudCB1bnNwZWNpZmllZCBjaGFubmVsLCBhY3Rpb24gPSAnICsgbXNnLmFjdGlvbik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbE5hbWVdO1xuXHRcdGlmKCFjaGFubmVsKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdDaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXZlbnQgZm9yIG5vbi1leGlzdGVudCBjaGFubmVsOiAnICsgY2hhbm5lbE5hbWUpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjaGFubmVsLm9uTWVzc2FnZShtc2cpO1xuXHR9O1xuXG5cdC8qIGNhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGJlY29tZXMgY29ubmVjdGVkOyByZWF0dGVtcHQgYXR0YWNoL2RldGFjaFxuXHQgKiBmb3IgY2hhbm5lbHMgdGhhdCBhcmUgYXR0YWNoaW5nIG9yIGRldGFjaGluZy5cblx0ICogTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgdXNlIGluUHJvZ3Jlc3MgYXMgaW5Qcm9ncmVzcyBpcyBvbmx5IGNoYW5uZWxzIHdoaWNoIGhhdmUgYWxyZWFkeSBtYWRlXG5cdCogYXQgbGVhc3Qgb25lIGF0dGVtcHQgdG8gYXR0YWNoL2RldGFjaCAqL1xuXHRDaGFubmVscy5wcm90b3R5cGUub25UcmFuc3BvcnRBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0XHRmb3IodmFyIGNoYW5uZWxOYW1lIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcblx0XHRcdGlmKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hpbmcnIHx8IGNoYW5uZWwuc3RhdGUgPT09ICdkZXRhY2hpbmcnKSB7XG5cdFx0XHRcdGNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUoKTtcblx0XHRcdH0gZWxzZSBpZihjaGFubmVsLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0XHRjaGFubmVsLmF0dGFjaCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUucmVhdHRhY2ggPSBmdW5jdGlvbihyZWFzb24pIHtcblx0XHRmb3IodmFyIGNoYW5uZWxJZCBpbiB0aGlzLmFsbCkge1xuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuXHRcdFx0LyogTkIgdGhpcyBzaG91bGQgbm90IHRyaWdnZXIgZm9yIG1lcmVseSBhdHRhY2hpbmcgY2hhbm5lbHMsIGFzIHRoZXkgd2lsbFxuXHRcdFx0ICogYmUgcmVhdHRhY2hlZCBhbnl3YXkgdGhyb3VnaCB0aGUgb25UcmFuc3BvcnRBY3RpdmUgY2hlY2tQZW5kaW5nU3RhdGUgKi9cblx0XHRcdGlmKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0Y2hhbm5lbC5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIHJlYXNvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5yZXNldEF0dGFjaGVkTXNnSW5kaWNhdG9ycyA9IGZ1bmN0aW9uKCkge1xuXHRcdGZvcih2YXIgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxJZF07XG5cdFx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRjaGFubmVsLl9hdHRhY2hlZE1zZ0luZGljYXRvciA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUuY2hlY2tBdHRhY2hlZE1zZ0luZGljYXRvcnMgPSBmdW5jdGlvbihjb25uZWN0aW9uSWQpIHtcblx0XHRmb3IodmFyIGNoYW5uZWxJZCBpbiB0aGlzLmFsbCkge1xuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xuXHRcdFx0aWYoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJyAmJiBjaGFubmVsLl9hdHRhY2hlZE1zZ0luZGljYXRvciA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICczMHMgYWZ0ZXIgYSByZXN1bWUsIGZvdW5kIGNoYW5uZWwgd2hpY2ggaGFzIG5vdCByZWNlaXZlZCBhbiBhdHRhY2hlZDsgY2hhbm5lbElkID0gJyArIGNoYW5uZWxJZCArICc7IGNvbm5lY3Rpb25JZCA9ICcgKyBjb25uZWN0aW9uSWQ7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0NoYW5uZWxzLmNoZWNrQXR0YWNoZWRNc2dJbmRpY2F0b3JzKCknLCBtc2cpO1xuXHRcdFx0XHRlcnJvcnJlcG9ydGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlcG9ydCgnZXJyb3InLCBtc2csICdjaGFubmVsLW5vLWF0dGFjaGVkLWFmdGVyLXJlc3VtZScpO1xuXHRcdFx0XHRjaGFubmVsLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJyk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblxuXHQvKiBDb25uZWN0aW9uIGludGVycnVwdGlvbnMgKGllIHdoZW4gdGhlIGNvbm5lY3Rpb24gd2lsbCBubyBsb25nZXIgcXVldWVcblx0ICogZXZlbnRzKSBpbXBseSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZXMgZm9yIGFueSBjaGFubmVsIHdoaWNoIGlzIGVpdGhlclxuXHQgKiBhdHRhY2hlZCwgcGVuZGluZywgb3Igd2lsbCBhdHRlbXB0IHRvIGJlY29tZSBhdHRhY2hlZCBpbiB0aGUgZnV0dXJlICovXG5cdENoYW5uZWxzLnByb3RvdHlwZS5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvblN0YXRlLCByZWFzb24pIHtcblx0XHR2YXIgY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGUgPSB7XG5cdFx0XHQnY2xvc2luZycgIDogJ2RldGFjaGVkJyxcblx0XHRcdCdjbG9zZWQnICAgOiAnZGV0YWNoZWQnLFxuXHRcdFx0J2ZhaWxlZCcgICA6ICdmYWlsZWQnLFxuXHRcdFx0J3N1c3BlbmRlZCc6ICdzdXNwZW5kZWQnXG5cdFx0fTtcblx0XHR2YXIgZnJvbUNoYW5uZWxTdGF0ZXMgPSBbJ2F0dGFjaGluZycsICdhdHRhY2hlZCcsICdkZXRhY2hpbmcnLCAnc3VzcGVuZGVkJ107XG5cdFx0dmFyIHRvQ2hhbm5lbFN0YXRlID0gY29ubmVjdGlvblN0YXRlVG9DaGFubmVsU3RhdGVbY29ubmVjdGlvblN0YXRlXTtcblxuXHRcdGZvcih2YXIgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxJZF07XG5cdFx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihmcm9tQ2hhbm5lbFN0YXRlcywgY2hhbm5lbC5zdGF0ZSkpIHtcblx0XHRcdFx0IGNoYW5uZWwubm90aWZ5U3RhdGUodG9DaGFubmVsU3RhdGUsIHJlYXNvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuXHRcdG5hbWUgPSBTdHJpbmcobmFtZSk7XG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcblx0XHRpZighY2hhbm5lbCkge1xuXHRcdFx0Y2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdID0gbmV3IHJlYWx0aW1lY2hhbm5lbCh0aGlzLnJlYWx0aW1lLCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG5cdFx0fSBlbHNlIGlmKGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0XHRpZiAoY2hhbm5lbC5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJDaGFubmVscy5nZXQoKSBjYW5ub3QgYmUgdXNlZCB0byBzZXQgY2hhbm5lbCBvcHRpb25zIHRoYXQgd291bGQgY2F1c2UgdGhlIGNoYW5uZWwgdG8gcmVhdHRhY2guIFBsZWFzZSwgdXNlIFJlYWx0aW1lQ2hhbm5lbC5zZXRPcHRpb25zKCkgaW5zdGVhZC5cIiwgNDAwMDAsIDQwMCk7XG5cdFx0XHR9XG5cdFx0XHRjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuXHRcdH1cblx0XHRyZXR1cm4gY2hhbm5lbDtcblx0fTtcblxuXHQvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cblx0ICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cblx0Q2hhbm5lbHMucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuXHRcdGlmKCFjaGFubmVsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciByZWxlYXNlRXJyID0gY2hhbm5lbC5nZXRSZWxlYXNlRXJyKCk7XG5cdFx0aWYocmVsZWFzZUVycikge1xuXHRcdFx0dGhyb3cgcmVsZWFzZUVycjtcblx0XHR9XG5cdFx0ZGVsZXRlIHRoaXMuYWxsW25hbWVdO1xuXHR9O1xuXG5cdC8qIFJlY29yZHMgb3BlcmF0aW9ucyBjdXJyZW50bHkgcGVuZGluZyBvbiBhIHRyYW5zcG9ydDsgdXNlZCBieSBjb25uZWN0aW9uTWFuYWdlciB0byBkZWNpZGUgd2hlblxuXHQgKiBpdCdzIHNhZmUgdG8gdXBncmFkZS4gTm90ZSB0aGF0IGEgY2hhbm5lbCBtaWdodCBiZSBpbiB0aGUgYXR0YWNoaW5nIHN0YXRlIHdpdGhvdXQgYW55IHBlbmRpbmdcblx0ICogb3BlcmF0aW9ucyAoZWcgaWYgYXR0YWNoZWQgd2hpbGUgdGhlIGNvbm5lY3Rpb24gc3RhdGUgaXMgY29ubmVjdGluZykgLSBzdWNoIGEgY2hhbm5lbCBtdXN0IG5vdFxuXHQgKiBob2xkIHVwIGFuIHVwZ3JhZGUsIHNvIGlzIG5vdCBjb25zaWRlcmVkIGluUHJvZ3Jlc3MuXG5cdCAqIE9wZXJhdGlvbiBpcyBjdXJyZW50bHkgb25lIG9mIGVpdGhlciAnc3RhdGVjaGFuZ2UnIG9yICdzeW5jJyAqL1xuXHRDaGFubmVscy5wcm90b3R5cGUuc2V0SW5Qcm9ncmVzcyA9IGZ1bmN0aW9uKGNoYW5uZWwsIG9wZXJhdGlvbiwgaW5Qcm9ncmVzcykge1xuXHRcdHRoaXMuaW5Qcm9ncmVzc1tjaGFubmVsLm5hbWVdID0gdGhpcy5pblByb2dyZXNzW2NoYW5uZWwubmFtZV0gfHwge307XG5cdFx0dGhpcy5pblByb2dyZXNzW2NoYW5uZWwubmFtZV1bb3BlcmF0aW9uXSA9IGluUHJvZ3Jlc3M7XG5cdFx0aWYoIWluUHJvZ3Jlc3MgJiYgdGhpcy5oYXNOb3BlbmRpbmcoKSkge1xuXHRcdFx0dGhpcy5lbWl0KCdub3BlbmRpbmcnKTtcblx0XHR9XG5cdH07XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLm9uY2VOb3BlbmRpbmcgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuXHRcdGlmKHRoaXMuaGFzTm9wZW5kaW5nKCkpIHtcblx0XHRcdGxpc3RlbmVyKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub25jZSgnbm9wZW5kaW5nJywgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5oYXNOb3BlbmRpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRXZlcnkodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10udmFsdWVzQXJyYXkodGhpcy5pblByb2dyZXNzLCB0cnVlKSwgZnVuY3Rpb24ob3BlcmF0aW9ucykge1xuXHRcdFx0cmV0dXJuICF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5jb250YWluc1ZhbHVlKG9wZXJhdGlvbnMsIHRydWUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdHJldHVybiBSZWFsdGltZTtcbn0pKCk7XG5cbnJlYWx0aW1lX1JlYWx0aW1lLlByb21pc2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMpO1xuXHRvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcblx0cmV0dXJuIG5ldyByZWFsdGltZV9SZWFsdGltZShvcHRpb25zKTtcbn07XG5cbnJlYWx0aW1lX1JlYWx0aW1lLkNhbGxiYWNrcyA9IHJlYWx0aW1lX1JlYWx0aW1lO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcmVhbHRpbWUgPSAocmVhbHRpbWVfUmVhbHRpbWUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9tc2dwYWNrLmpzXG52YXIgdXRpbF9tc2dwYWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9pbmRleC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNsaWVudF9yZXN0LlV0aWxzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVzdC5CdWZmZXJVdGlscyA9IGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3Jlc3QuQ3J5cHRvID0gdXRpbF9jcnlwdG9bXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVzdC5EZWZhdWx0cyA9IGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3Jlc3QuSHR0cCA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVzdC5SZXNvdXJjZSA9IGNsaWVudF9yZXNvdXJjZTtcbmNsaWVudF9yZXN0Lk1lc3NhZ2UgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3Jlc3QuUHJlc2VuY2VNZXNzYWdlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuXG5jbGllbnRfcmVhbHRpbWUuVXRpbHMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5CdWZmZXJVdGlscyA9IGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLkNyeXB0byA9IHV0aWxfY3J5cHRvW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLkRlZmF1bHRzID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuSHR0cCA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuTWVzc2FnZSA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuUHJlc2VuY2VNZXNzYWdlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLlByb3RvY29sTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25tYW5hZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsaWIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIFJlc3Q6IGNsaWVudF9yZXN0LFxuICBSZWFsdGltZTogY2xpZW50X3JlYWx0aW1lLFxuICBtc2dwYWNrOiB1dGlsX21zZ3BhY2tbXCJhXCIgLyogZGVmYXVsdCAqL11cbn0pO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG59KTsiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykge1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSAob3B0aW9ucy5pbmRleE9mKCc6JykgPT0gLTEpID8ge3Rva2VuOiBvcHRpb25zfSA6IHtrZXk6IG9wdGlvbnN9O1xuICB9XG4gIG9wdGlvbnMucHJvbWlzZXMgPSB0cnVlO1xuICByZXR1cm4gb3B0aW9ucztcbn1cblxudmFyIEFibHkgPSByZXF1aXJlKCcuL25vZGVqcy9pbmRleCcpO1xuXG52YXIgUmVzdFByb21pc2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQWJseS5SZXN0KHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykpO1xufVxuT2JqZWN0LmFzc2lnbihSZXN0UHJvbWlzZSwgQWJseS5SZXN0KTtcblxudmFyIFJlYWx0aW1lUHJvbWlzZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBBYmx5LlJlYWx0aW1lKHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykpO1xufVxuT2JqZWN0LmFzc2lnbihSZWFsdGltZVByb21pc2UsIEFibHkuUmVhbHRpbWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVzdDogUmVzdFByb21pc2UsXG4gIFJlYWx0aW1lOiBSZWFsdGltZVByb21pc2Vcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpXG4gICAgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG52YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICB2YXIgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICB2YXIgaTE2ID0gaSAqIDE2XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsyXSEuL0FibHlDaGF0Q29tcG9uZW50Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsyXSEuL0FibHlDaGF0Q29tcG9uZW50Lm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsyXSEuL0FibHlDaGF0Q29tcG9uZW50Lm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRTEoKSB7XG4gICAgbGV0IG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgICAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xufSgpO1xuY29uc3QgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0MSgpIHtcbiAgICBjb25zdCBtZW1vID0ge1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxldCBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICAgIH07XG59KCk7XG5jb25zdCBzdHlsZXNJbkRvbSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIGxldCByZXN1bHQgPSAtMTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlkQ291bnRNYXAgPSB7XG4gICAgfTtcbiAgICBjb25zdCBpZGVudGlmaWVycyA9IFtdO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGNvbnN0IGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgICAgIGNvbnN0IGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGlkICsgJyAnICsgY291bnQudG9TdHJpbmcoKTtcbiAgICAgICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgICAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVycztcbn1cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovIGNvbnN0IHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQxKCkge1xuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICAgIH07XG59KCk7XG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgICBjb25zdCBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/ICdAbWVkaWEgJyArIG9iai5tZWRpYSArICcgeycgKyBvYmouY3NzICsgJ30nIDogb2JqLmNzcztcbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gICAgbGV0IGNzcyA9IG9iai5jc3M7XG4gICAgY29uc3QgbWVkaWEgPSBvYmoubWVkaWE7XG4gICAgY29uc3Qgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nO1xuICAgIH1cbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUoc3R5bGUuZmlyc3RDaGlsZCl7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5sZXQgc2luZ2xldG9uID0gbnVsbDtcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICAgIGxldCBzdHlsZTtcbiAgICBsZXQgdXBkYXRlO1xuICAgIGxldCByZW1vdmU7XG4gICAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgICAgcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGUob2JqKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgICAgIGlmIChuZXdPYmopIHtcbiAgICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtcbiAgICB9O1xuICAgIC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuICAgIH1cbiAgICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgICBsZXQgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgICAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICAgICAgZm9yKGxldCBpMSA9IDA7IGkxIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaTErKyl7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2kxXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICAgIH07XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIiwibW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgbj17NzYyOmZ1bmN0aW9uKG4pe24uZXhwb3J0cz1mdW5jdGlvbihuKXt2YXIgdD1bXTt0LnRvU3RyaW5nPWZ1bmN0aW9uIHRvU3RyaW5nKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHQpe3ZhciByPWNzc1dpdGhNYXBwaW5nVG9TdHJpbmcodCxuKTtpZih0WzJdKXtyZXR1cm5cIkBtZWRpYSBcIi5jb25jYXQodFsyXSxcIiB7XCIpLmNvbmNhdChyLFwifVwiKX1yZXR1cm4gcn0pLmpvaW4oXCJcIil9O3QuaT1mdW5jdGlvbihuLHIsbyl7aWYodHlwZW9mIG49PT1cInN0cmluZ1wiKXtuPVtbbnVsbCxuLFwiXCJdXX12YXIgZT17fTtpZihvKXtmb3IodmFyIGE9MDthPHRoaXMubGVuZ3RoO2ErKyl7dmFyIGM9dGhpc1thXVswXTtpZihjIT1udWxsKXtlW2NdPXRydWV9fX1mb3IodmFyIGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIHU9W10uY29uY2F0KG5baV0pO2lmKG8mJmVbdVswXV0pe2NvbnRpbnVlfWlmKHIpe2lmKCF1WzJdKXt1WzJdPXJ9ZWxzZXt1WzJdPVwiXCIuY29uY2F0KHIsXCIgYW5kIFwiKS5jb25jYXQodVsyXSl9fXQucHVzaCh1KX19O3JldHVybiB0fTtmdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKG4sdCl7dmFyIHI9blsxXXx8XCJcIjt2YXIgbz1uWzNdO2lmKCFvKXtyZXR1cm4gcn1pZih0JiZ0eXBlb2YgYnRvYT09PVwiZnVuY3Rpb25cIil7dmFyIGU9dG9Db21tZW50KG8pO3ZhciBhPW8uc291cmNlcy5tYXAoZnVuY3Rpb24obil7cmV0dXJuXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChvLnNvdXJjZVJvb3R8fFwiXCIpLmNvbmNhdChuLFwiICovXCIpfSk7cmV0dXJuW3JdLmNvbmNhdChhKS5jb25jYXQoW2VdKS5qb2luKFwiXFxuXCIpfXJldHVybltyXS5qb2luKFwiXFxuXCIpfWZ1bmN0aW9uIHRvQ29tbWVudChuKXt2YXIgdD1idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShuKSkpKTt2YXIgcj1cInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdCh0KTtyZXR1cm5cIi8qIyBcIi5jb25jYXQocixcIiAqL1wiKX19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe2lmKHRbcl0pe3JldHVybiB0W3JdLmV4cG9ydHN9dmFyIG89dFtyXT17ZXhwb3J0czp7fX07dmFyIGU9dHJ1ZTt0cnl7bltyXShvLG8uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtlPWZhbHNlfWZpbmFsbHl7aWYoZSlkZWxldGUgdFtyXX1yZXR1cm4gby5leHBvcnRzfV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3JldHVybiBfX25jY3dwY2tfcmVxdWlyZV9fKDc2Mil9KCk7IiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLkFibHlDaGF0Q29tcG9uZW50X2NoYXRIb2xkZXJfXzFNb1BhIHtcXHJcXG4gICAgZGlzcGxheTogZ3JpZDtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxZnIgMTAwcHg7XFxyXFxuICAgIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gICAgICAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxufVxcclxcbi5BYmx5Q2hhdENvbXBvbmVudF9jaGF0VGV4dF9fMU1GLVoge1xcclxcbiAgICBkaXNwbGF5OiAtbW96LWJveDtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgLW1vei1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXHJcXG4gICAgLW1vei1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XFxyXFxuICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgLW1vei1ib3gtYWxpZ246IHN0YXJ0O1xcclxcbiAgICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcclxcbiAgICBncmlkLWdhcDogMWVtO1xcclxcbiAgICBncmlkLWdhcDogMWVtO1xcclxcbiAgICBnYXA6IDFlbTtcXHJcXG4gICAgcGFkZGluZzogMWVtO1xcclxcbiAgICBoZWlnaHQ6IC13ZWJraXQtY2FsYygxMDB2aCAtIDQwcHggLSAxMDBweCAtIDEwMHB4IC0gMTAwcHgpO1xcclxcbiAgICBoZWlnaHQ6IC1tb3otY2FsYygxMDB2aCAtIDQwcHggLSAxMDBweCAtIDEwMHB4IC0gMTAwcHgpO1xcclxcbiAgICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA0MHB4IC0gMTAwcHggLSAxMDBweCAtIDEwMHB4KTtcXHJcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXHJcXG59XFxyXFxuLkFibHlDaGF0Q29tcG9uZW50X2Zvcm1fXzNwZkdNIHtcXHJcXG4gICAgZGlzcGxheTogZ3JpZDtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMTAwcHg7XFxyXFxuICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZWVlO1xcclxcbn1cXHJcXG4uQWJseUNoYXRDb21wb25lbnRfdGV4dGFyZWFfXzJ1YmJVIHtcXHJcXG4gICAgcGFkZGluZzogMWVtO1xcclxcbiAgICBib3JkZXI6IDA7XFxyXFxuICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sT3h5Z2VuLFVidW50dSxDYW50YXJlbGwsRmlyYSBTYW5zLERyb2lkIFNhbnMsSGVsdmV0aWNhIE5ldWUsc2Fucy1zZXJpZjtcXHJcXG4gICAgZm9udC1zaXplOiAxLjJlbTtcXHJcXG59XFxyXFxuLkFibHlDaGF0Q29tcG9uZW50X2J1dHRvbl9fMUVyYVA6ZGlzYWJsZWR7XFxyXFxuICAgIGNvbG9yOiAjZmZmO1xcclxcbiAgICBvcGFjaXR5OiAuNTtcXHJcXG59XFxyXFxuLkFibHlDaGF0Q29tcG9uZW50X2J1dHRvbl9fMUVyYVB7XFxyXFxuICAgIGJvcmRlcjogMDtcXHJcXG4gICAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsbGVmdCB0b3AsIHJpZ2h0IHRvcCxmcm9tKCMzNjM3OTUpLHRvKCMwMDVjOTcpKTtcXHJcXG4gICAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCwjMzYzNzk1LCMwMDVjOTcpO1xcclxcbiAgICBiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudChsZWZ0LCMzNjM3OTUsIzAwNWM5Nyk7XFxyXFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywjMzYzNzk1LCMwMDVjOTcpO1xcclxcbiAgICBmb250LXdlaWdodDogNzAwO1xcclxcbiAgICBmb250LXNpemU6IDEuNGVtO1xcclxcbn1cXHJcXG4uQWJseUNoYXRDb21wb25lbnRfbWVzc2FnZV9fMzZ2MUZ7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWY1Zjg7XFxyXFxuICAgIHBhZGRpbmc6IDFlbTtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gICAgLW1vei1ib3gtZmxleDogMDtcXHJcXG4gICAgICAgICBmbGV4LWdyb3c6IDA7XFxyXFxufVxcclxcbi5BYmx5Q2hhdENvbXBvbmVudF9tZXNzYWdlX18zNnYxRi5BYmx5Q2hhdENvbXBvbmVudF9kYXRhX18yQ2RRM3tcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZjVmODtcXHJcXG4gICAgcGFkZGluZzogMWVtO1xcclxcbiAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgICAgICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDEwcHg7XFxyXFxuICAgIC1tb3otYm94LWZsZXg6IDA7XFxyXFxuICAgICAgICAgZmxleC1ncm93OiAwO1xcclxcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vY29tcG9uZW50cy9BYmx5Q2hhdENvbXBvbmVudC5tb2R1bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0lBQ0ksYUFBYTtJQUNiLDZCQUE2QjtJQUM3Qiw4QkFBc0I7T0FBdEIsMkJBQXNCO1lBQXRCLHNCQUFzQjtBQUMxQjtBQUNBO0lBQ0ksaUJBQWE7SUFBYixhQUFhO0lBQ2IseUJBQXNCO0lBQXRCLDBCQUFzQjtTQUF0QixzQkFBc0I7SUFDdEIscUJBQXVCO1NBQXZCLHVCQUF1QjtJQUN2QixhQUFhO0lBQ2IsYUFBUTtJQUFSLFFBQVE7SUFDUixZQUFZO0lBQ1osMERBQWtEO0lBQWxELHVEQUFrRDtJQUFsRCxrREFBa0Q7SUFDbEQsZ0JBQWdCO0FBQ3BCO0FBQ0E7SUFDSSxhQUFhO0lBQ2IsZ0NBQWdDO0lBQ2hDLDBCQUEwQjtBQUM5QjtBQUNBO0lBQ0ksWUFBWTtJQUNaLFNBQVM7SUFDVCxvSUFBb0k7SUFDcEksZ0JBQWdCO0FBQ3BCO0FBQ0E7SUFDSSxXQUFXO0lBQ1gsV0FBVztBQUNmO0FBQ0E7SUFDSSxTQUFTO0lBQ1Qsa0ZBQWtEO0lBQWxELHlEQUFrRDtJQUFsRCxzREFBa0Q7SUFBbEQsa0RBQWtEO0lBQ2xELGdCQUFnQjtJQUNoQixnQkFBZ0I7QUFDcEI7QUFDQTtJQUNJLHlCQUF5QjtJQUN6QixZQUFZO0lBQ1osbUJBQW1CO0lBQ25CLGdCQUFZO1NBQVosWUFBWTtBQUNoQjtBQUNBO0lBQ0kseUJBQXlCO0lBQ3pCLFlBQVk7SUFDWixtQkFBbUI7UUFDZixnQ0FBZ0M7SUFDcEMsZ0JBQVk7U0FBWixZQUFZO0FBQ2hCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5jaGF0SG9sZGVyIHtcXHJcXG4gICAgZGlzcGxheTogZ3JpZDtcXHJcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxZnIgMTAwcHg7XFxyXFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxufVxcclxcbi5jaGF0VGV4dCB7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcclxcbiAgICBncmlkLWdhcDogMWVtO1xcclxcbiAgICBnYXA6IDFlbTtcXHJcXG4gICAgcGFkZGluZzogMWVtO1xcclxcbiAgICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA0MHB4IC0gMTAwcHggLSAxMDBweCAtIDEwMHB4KTtcXHJcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXHJcXG59XFxyXFxuLmZvcm0ge1xcclxcbiAgICBkaXNwbGF5OiBncmlkO1xcclxcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxMDBweDtcXHJcXG4gICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlZWU7XFxyXFxufVxcclxcbi50ZXh0YXJlYSB7XFxyXFxuICAgIHBhZGRpbmc6IDFlbTtcXHJcXG4gICAgYm9yZGVyOiAwO1xcclxcbiAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSxCbGlua01hY1N5c3RlbUZvbnQsU2Vnb2UgVUksUm9ib3RvLE94eWdlbixVYnVudHUsQ2FudGFyZWxsLEZpcmEgU2FucyxEcm9pZCBTYW5zLEhlbHZldGljYSBOZXVlLHNhbnMtc2VyaWY7XFxyXFxuICAgIGZvbnQtc2l6ZTogMS4yZW07XFxyXFxufVxcclxcbi5idXR0b246ZGlzYWJsZWR7XFxyXFxuICAgIGNvbG9yOiAjZmZmO1xcclxcbiAgICBvcGFjaXR5OiAuNTtcXHJcXG59XFxyXFxuLmJ1dHRvbntcXHJcXG4gICAgYm9yZGVyOiAwO1xcclxcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoOTBkZWcsIzM2Mzc5NSwjMDA1Yzk3KTtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gICAgZm9udC1zaXplOiAxLjRlbTtcXHJcXG59XFxyXFxuLm1lc3NhZ2V7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWY1Zjg7XFxyXFxuICAgIHBhZGRpbmc6IDFlbTtcXHJcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gICAgZmxleC1ncm93OiAwO1xcclxcbn1cXHJcXG4ubWVzc2FnZS5kYXRhe1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVmNWY4O1xcclxcbiAgICBwYWRkaW5nOiAxZW07XFxyXFxuICAgIGJvcmRlci1yYWRpdXM6IDEwcHg7XFxyXFxuICAgICAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMTBweDtcXHJcXG4gICAgZmxleC1ncm93OiAwO1xcclxcbn1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJjaGF0SG9sZGVyXCI6IFwiQWJseUNoYXRDb21wb25lbnRfY2hhdEhvbGRlcl9fMU1vUGFcIixcblx0XCJjaGF0VGV4dFwiOiBcIkFibHlDaGF0Q29tcG9uZW50X2NoYXRUZXh0X18xTUYtWlwiLFxuXHRcImZvcm1cIjogXCJBYmx5Q2hhdENvbXBvbmVudF9mb3JtX18zcGZHTVwiLFxuXHRcInRleHRhcmVhXCI6IFwiQWJseUNoYXRDb21wb25lbnRfdGV4dGFyZWFfXzJ1YmJVXCIsXG5cdFwiYnV0dG9uXCI6IFwiQWJseUNoYXRDb21wb25lbnRfYnV0dG9uX18xRXJhUFwiLFxuXHRcIm1lc3NhZ2VcIjogXCJBYmx5Q2hhdENvbXBvbmVudF9tZXNzYWdlX18zNnYxRlwiLFxuXHRcImRhdGFcIjogXCJBYmx5Q2hhdENvbXBvbmVudF9kYXRhX18yQ2RRM1wiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXlcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5TGltaXQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVJlc3RcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59IiwiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUNoYW5uZWwiLCJzdHlsZXMiLCJBYmx5Q2hhdENvbXBvbmVudCIsImlucHV0Qm94IiwibWVzc2FnZUVuZCIsIm1lc3NhZ2VUZXh0Iiwic2V0TWVzc2FnZVRleHQiLCJyZWNlaXZlZE1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJtZXNzYWdlVGV4dElzRW1wdHkiLCJ0cmltIiwibGVuZ3RoIiwibWVzc2FnZSIsImhpc3RvcnkiLCJzbGljZSIsImNoYW5uZWwiLCJhYmx5Iiwic2VuZENoYXRNZXNzYWdlIiwicHVibGlzaCIsIm5hbWUiLCJkYXRhIiwiZm9jdXMiLCJoYW5kbGVGb3JtU3VibWlzc2lvbiIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVLZXlQcmVzcyIsImNoYXJDb2RlIiwibWVzc2FnZXMiLCJtYXAiLCJpbmRleCIsImF1dGhvciIsImNvbm5lY3Rpb25JZCIsImNvbm5lY3Rpb24iLCJpZCIsInNjcm9sbEludG9WaWV3IiwiYmVoYXZpb3VyIiwiY2hhdEhvbGRlciIsImNoYXRUZXh0IiwiZWxlbWVudCIsImZvcm0iLCJlIiwidGFyZ2V0IiwidmFsdWUiLCJ0ZXh0YXJlYSIsImJ1dHRvbiIsIkFibHkiLCJSZWFsdGltZSIsIlByb21pc2UiLCJhdXRoVXJsIiwiY2hhbm5lbE5hbWUiLCJjYWxsYmFja09uTWVzc2FnZSIsImNoYW5uZWxzIiwiZ2V0Iiwib25Nb3VudCIsInN1YnNjcmliZSIsIm1zZyIsIm9uVW5tb3VudCIsInVuc3Vic2NyaWJlIiwidXNlRWZmZWN0SG9vayJdLCJzb3VyY2VSb290IjoiIn0=